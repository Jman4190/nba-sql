/* Generated by Cython 0.29.14 */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
    #error Cython requires Python 2.6+ or Python 3.3+.
#else
#define CYTHON_ABI "0_29_14"
#define CYTHON_HEX_VERSION 0x001D0EF0
#define CYTHON_FUTURE_DIVISION 1
#include <stddef.h>
#ifndef offsetof
  #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif
#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#define __PYX_COMMA ,
#ifndef HAVE_LONG_LONG
  #if PY_VERSION_HEX >= 0x02070000
    #define HAVE_LONG_LONG
  #endif
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef Py_HUGE_VAL
  #define Py_HUGE_VAL HUGE_VAL
#endif
#ifdef PYPY_VERSION
  #define CYTHON_COMPILING_IN_PYPY 1
  #define CYTHON_COMPILING_IN_PYSTON 0
  #define CYTHON_COMPILING_IN_CPYTHON 0
  #undef CYTHON_USE_TYPE_SLOTS
  #define CYTHON_USE_TYPE_SLOTS 0
  #undef CYTHON_USE_PYTYPE_LOOKUP
  #define CYTHON_USE_PYTYPE_LOOKUP 0
  #if PY_VERSION_HEX < 0x03050000
    #undef CYTHON_USE_ASYNC_SLOTS
    #define CYTHON_USE_ASYNC_SLOTS 0
  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
    #define CYTHON_USE_ASYNC_SLOTS 1
  #endif
  #undef CYTHON_USE_PYLIST_INTERNALS
  #define CYTHON_USE_PYLIST_INTERNALS 0
  #undef CYTHON_USE_UNICODE_INTERNALS
  #define CYTHON_USE_UNICODE_INTERNALS 0
  #undef CYTHON_USE_UNICODE_WRITER
  #define CYTHON_USE_UNICODE_WRITER 0
  #undef CYTHON_USE_PYLONG_INTERNALS
  #define CYTHON_USE_PYLONG_INTERNALS 0
  #undef CYTHON_AVOID_BORROWED_REFS
  #define CYTHON_AVOID_BORROWED_REFS 1
  #undef CYTHON_ASSUME_SAFE_MACROS
  #define CYTHON_ASSUME_SAFE_MACROS 0
  #undef CYTHON_UNPACK_METHODS
  #define CYTHON_UNPACK_METHODS 0
  #undef CYTHON_FAST_THREAD_STATE
  #define CYTHON_FAST_THREAD_STATE 0
  #undef CYTHON_FAST_PYCALL
  #define CYTHON_FAST_PYCALL 0
  #undef CYTHON_PEP489_MULTI_PHASE_INIT
  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
  #undef CYTHON_USE_TP_FINALIZE
  #define CYTHON_USE_TP_FINALIZE 0
  #undef CYTHON_USE_DICT_VERSIONS
  #define CYTHON_USE_DICT_VERSIONS 0
  #undef CYTHON_USE_EXC_INFO_STACK
  #define CYTHON_USE_EXC_INFO_STACK 0
#elif defined(PYSTON_VERSION)
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_PYSTON 1
  #define CYTHON_COMPILING_IN_CPYTHON 0
  #ifndef CYTHON_USE_TYPE_SLOTS
    #define CYTHON_USE_TYPE_SLOTS 1
  #endif
  #undef CYTHON_USE_PYTYPE_LOOKUP
  #define CYTHON_USE_PYTYPE_LOOKUP 0
  #undef CYTHON_USE_ASYNC_SLOTS
  #define CYTHON_USE_ASYNC_SLOTS 0
  #undef CYTHON_USE_PYLIST_INTERNALS
  #define CYTHON_USE_PYLIST_INTERNALS 0
  #ifndef CYTHON_USE_UNICODE_INTERNALS
    #define CYTHON_USE_UNICODE_INTERNALS 1
  #endif
  #undef CYTHON_USE_UNICODE_WRITER
  #define CYTHON_USE_UNICODE_WRITER 0
  #undef CYTHON_USE_PYLONG_INTERNALS
  #define CYTHON_USE_PYLONG_INTERNALS 0
  #ifndef CYTHON_AVOID_BORROWED_REFS
    #define CYTHON_AVOID_BORROWED_REFS 0
  #endif
  #ifndef CYTHON_ASSUME_SAFE_MACROS
    #define CYTHON_ASSUME_SAFE_MACROS 1
  #endif
  #ifndef CYTHON_UNPACK_METHODS
    #define CYTHON_UNPACK_METHODS 1
  #endif
  #undef CYTHON_FAST_THREAD_STATE
  #define CYTHON_FAST_THREAD_STATE 0
  #undef CYTHON_FAST_PYCALL
  #define CYTHON_FAST_PYCALL 0
  #undef CYTHON_PEP489_MULTI_PHASE_INIT
  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
  #undef CYTHON_USE_TP_FINALIZE
  #define CYTHON_USE_TP_FINALIZE 0
  #undef CYTHON_USE_DICT_VERSIONS
  #define CYTHON_USE_DICT_VERSIONS 0
  #undef CYTHON_USE_EXC_INFO_STACK
  #define CYTHON_USE_EXC_INFO_STACK 0
#else
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_PYSTON 0
  #define CYTHON_COMPILING_IN_CPYTHON 1
  #ifndef CYTHON_USE_TYPE_SLOTS
    #define CYTHON_USE_TYPE_SLOTS 1
  #endif
  #if PY_VERSION_HEX < 0x02070000
    #undef CYTHON_USE_PYTYPE_LOOKUP
    #define CYTHON_USE_PYTYPE_LOOKUP 0
  #elif !defined(CYTHON_USE_PYTYPE_LOOKUP)
    #define CYTHON_USE_PYTYPE_LOOKUP 1
  #endif
  #if PY_MAJOR_VERSION < 3
    #undef CYTHON_USE_ASYNC_SLOTS
    #define CYTHON_USE_ASYNC_SLOTS 0
  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
    #define CYTHON_USE_ASYNC_SLOTS 1
  #endif
  #if PY_VERSION_HEX < 0x02070000
    #undef CYTHON_USE_PYLONG_INTERNALS
    #define CYTHON_USE_PYLONG_INTERNALS 0
  #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
    #define CYTHON_USE_PYLONG_INTERNALS 1
  #endif
  #ifndef CYTHON_USE_PYLIST_INTERNALS
    #define CYTHON_USE_PYLIST_INTERNALS 1
  #endif
  #ifndef CYTHON_USE_UNICODE_INTERNALS
    #define CYTHON_USE_UNICODE_INTERNALS 1
  #endif
  #if PY_VERSION_HEX < 0x030300F0
    #undef CYTHON_USE_UNICODE_WRITER
    #define CYTHON_USE_UNICODE_WRITER 0
  #elif !defined(CYTHON_USE_UNICODE_WRITER)
    #define CYTHON_USE_UNICODE_WRITER 1
  #endif
  #ifndef CYTHON_AVOID_BORROWED_REFS
    #define CYTHON_AVOID_BORROWED_REFS 0
  #endif
  #ifndef CYTHON_ASSUME_SAFE_MACROS
    #define CYTHON_ASSUME_SAFE_MACROS 1
  #endif
  #ifndef CYTHON_UNPACK_METHODS
    #define CYTHON_UNPACK_METHODS 1
  #endif
  #ifndef CYTHON_FAST_THREAD_STATE
    #define CYTHON_FAST_THREAD_STATE 1
  #endif
  #ifndef CYTHON_FAST_PYCALL
    #define CYTHON_FAST_PYCALL 1
  #endif
  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
    #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
  #endif
  #ifndef CYTHON_USE_TP_FINALIZE
    #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
  #endif
  #ifndef CYTHON_USE_DICT_VERSIONS
    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
  #endif
  #ifndef CYTHON_USE_EXC_INFO_STACK
    #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
  #endif
#endif
#if !defined(CYTHON_FAST_PYCCALL)
#define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
#endif
#if CYTHON_USE_PYLONG_INTERNALS
  #include "longintrepr.h"
  #undef SHIFT
  #undef BASE
  #undef MASK
  #ifdef SIZEOF_VOID_P
    enum { __pyx_check_sizeof_voidp = 1 / (int)(SIZEOF_VOID_P == sizeof(void*)) };
  #endif
#endif
#ifndef __has_attribute
  #define __has_attribute(x) 0
#endif
#ifndef __has_cpp_attribute
  #define __has_cpp_attribute(x) 0
#endif
#ifndef CYTHON_RESTRICT
  #if defined(__GNUC__)
    #define CYTHON_RESTRICT __restrict__
  #elif defined(_MSC_VER) && _MSC_VER >= 1400
    #define CYTHON_RESTRICT __restrict
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_RESTRICT restrict
  #else
    #define CYTHON_RESTRICT
  #endif
#endif
#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif
#ifndef CYTHON_MAYBE_UNUSED_VAR
#  if defined(__cplusplus)
     template<class T> void CYTHON_MAYBE_UNUSED_VAR( const T& ) { }
#  else
#    define CYTHON_MAYBE_UNUSED_VAR(x) (void)(x)
#  endif
#endif
#ifndef CYTHON_NCP_UNUSED
# if CYTHON_COMPILING_IN_CPYTHON
#  define CYTHON_NCP_UNUSED
# else
#  define CYTHON_NCP_UNUSED CYTHON_UNUSED
# endif
#endif
#define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)
#ifdef _MSC_VER
    #ifndef _MSC_STDINT_H_
        #if _MSC_VER < 1300
           typedef unsigned char     uint8_t;
           typedef unsigned int      uint32_t;
        #else
           typedef unsigned __int8   uint8_t;
           typedef unsigned __int32  uint32_t;
        #endif
    #endif
#else
   #include <stdint.h>
#endif
#ifndef CYTHON_FALLTHROUGH
  #if defined(__cplusplus) && __cplusplus >= 201103L
    #if __has_cpp_attribute(fallthrough)
      #define CYTHON_FALLTHROUGH [[fallthrough]]
    #elif __has_cpp_attribute(clang::fallthrough)
      #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
    #elif __has_cpp_attribute(gnu::fallthrough)
      #define CYTHON_FALLTHROUGH [[gnu::fallthrough]]
    #endif
  #endif
  #ifndef CYTHON_FALLTHROUGH
    #if __has_attribute(fallthrough)
      #define CYTHON_FALLTHROUGH __attribute__((fallthrough))
    #else
      #define CYTHON_FALLTHROUGH
    #endif
  #endif
  #if defined(__clang__ ) && defined(__apple_build_version__)
    #if __apple_build_version__ < 7000000
      #undef  CYTHON_FALLTHROUGH
      #define CYTHON_FALLTHROUGH
    #endif
  #endif
#endif

#ifndef __cplusplus
  #error "Cython files generated with the C++ option must be compiled with a C++ compiler."
#endif
#ifndef CYTHON_INLINE
  #if defined(__clang__)
    #define CYTHON_INLINE __inline__ __attribute__ ((__unused__))
  #else
    #define CYTHON_INLINE inline
  #endif
#endif
template<typename T>
void __Pyx_call_destructor(T& x) {
    x.~T();
}
template<typename T>
class __Pyx_FakeReference {
  public:
    __Pyx_FakeReference() : ptr(NULL) { }
    __Pyx_FakeReference(const T& ref) : ptr(const_cast<T*>(&ref)) { }
    T *operator->() { return ptr; }
    T *operator&() { return ptr; }
    operator T&() { return *ptr; }
    template<typename U> bool operator ==(U other) { return *ptr == other; }
    template<typename U> bool operator !=(U other) { return *ptr != other; }
  private:
    T *ptr;
};

#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
  #define Py_OptimizeFlag 0
#endif
#define __PYX_BUILD_PY_SSIZE_T "n"
#define CYTHON_FORMAT_SSIZE_T "z"
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyClass_Type
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
#if PY_VERSION_HEX >= 0x030800A4 && PY_VERSION_HEX < 0x030800B2
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a, 0, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
#else
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
#endif
  #define __Pyx_DefaultClassType PyType_Type
#endif
#ifndef Py_TPFLAGS_CHECKTYPES
  #define Py_TPFLAGS_CHECKTYPES 0
#endif
#ifndef Py_TPFLAGS_HAVE_INDEX
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif
#ifndef Py_TPFLAGS_HAVE_NEWBUFFER
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#ifndef Py_TPFLAGS_HAVE_FINALIZE
  #define Py_TPFLAGS_HAVE_FINALIZE 0
#endif
#ifndef METH_STACKLESS
  #define METH_STACKLESS 0
#endif
#if PY_VERSION_HEX <= 0x030700A3 || !defined(METH_FASTCALL)
  #ifndef METH_FASTCALL
     #define METH_FASTCALL 0x80
  #endif
  typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject *const *args, Py_ssize_t nargs);
  typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject *const *args,
                                                          Py_ssize_t nargs, PyObject *kwnames);
#else
  #define __Pyx_PyCFunctionFast _PyCFunctionFast
  #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
#endif
#if CYTHON_FAST_PYCCALL
#define __Pyx_PyFastCFunction_Check(func)\
    ((PyCFunction_Check(func) && (METH_FASTCALL == (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)))))
#else
#define __Pyx_PyFastCFunction_Check(func) 0
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Malloc)
  #define PyObject_Malloc(s)   PyMem_Malloc(s)
  #define PyObject_Free(p)     PyMem_Free(p)
  #define PyObject_Realloc(p)  PyMem_Realloc(p)
#endif
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030400A1
  #define PyMem_RawMalloc(n)           PyMem_Malloc(n)
  #define PyMem_RawRealloc(p, n)       PyMem_Realloc(p, n)
  #define PyMem_RawFree(p)             PyMem_Free(p)
#endif
#if CYTHON_COMPILING_IN_PYSTON
  #define __Pyx_PyCode_HasFreeVars(co)  PyCode_HasFreeVars(co)
  #define __Pyx_PyFrame_SetLineNumber(frame, lineno) PyFrame_SetLineNumber(frame, lineno)
#else
  #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
  #define __Pyx_PyFrame_SetLineNumber(frame, lineno)  (frame)->f_lineno = (lineno)
#endif
#if !CYTHON_FAST_THREAD_STATE || PY_VERSION_HEX < 0x02070000
  #define __Pyx_PyThreadState_Current PyThreadState_GET()
#elif PY_VERSION_HEX >= 0x03060000
  #define __Pyx_PyThreadState_Current _PyThreadState_UncheckedGet()
#elif PY_VERSION_HEX >= 0x03000000
  #define __Pyx_PyThreadState_Current PyThreadState_GET()
#else
  #define __Pyx_PyThreadState_Current _PyThreadState_Current
#endif
#if PY_VERSION_HEX < 0x030700A2 && !defined(PyThread_tss_create) && !defined(Py_tss_NEEDS_INIT)
#include "pythread.h"
#define Py_tss_NEEDS_INIT 0
typedef int Py_tss_t;
static CYTHON_INLINE int PyThread_tss_create(Py_tss_t *key) {
  *key = PyThread_create_key();
  return 0;
}
static CYTHON_INLINE Py_tss_t * PyThread_tss_alloc(void) {
  Py_tss_t *key = (Py_tss_t *)PyObject_Malloc(sizeof(Py_tss_t));
  *key = Py_tss_NEEDS_INIT;
  return key;
}
static CYTHON_INLINE void PyThread_tss_free(Py_tss_t *key) {
  PyObject_Free(key);
}
static CYTHON_INLINE int PyThread_tss_is_created(Py_tss_t *key) {
  return *key != Py_tss_NEEDS_INIT;
}
static CYTHON_INLINE void PyThread_tss_delete(Py_tss_t *key) {
  PyThread_delete_key(*key);
  *key = Py_tss_NEEDS_INIT;
}
static CYTHON_INLINE int PyThread_tss_set(Py_tss_t *key, void *value) {
  return PyThread_set_key_value(*key, value);
}
static CYTHON_INLINE void * PyThread_tss_get(Py_tss_t *key) {
  return PyThread_get_key_value(*key);
}
#endif
#if CYTHON_COMPILING_IN_CPYTHON || defined(_PyDict_NewPresized)
#define __Pyx_PyDict_NewPresized(n)  ((n <= 8) ? PyDict_New() : _PyDict_NewPresized(n))
#else
#define __Pyx_PyDict_NewPresized(n)  PyDict_New()
#endif
#if PY_MAJOR_VERSION >= 3 || CYTHON_FUTURE_DIVISION
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
#endif
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && CYTHON_USE_UNICODE_INTERNALS
#define __Pyx_PyDict_GetItemStr(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
#else
#define __Pyx_PyDict_GetItemStr(dict, name)  PyDict_GetItem(dict, name)
#endif
#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
  #define CYTHON_PEP393_ENABLED 1
  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
                                              0 : _PyUnicode_Ready((PyObject *)(op)))
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   PyUnicode_MAX_CHAR_VALUE(u)
  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, ch)
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
#else
  #define CYTHON_PEP393_ENABLED 0
  #define PyUnicode_1BYTE_KIND  1
  #define PyUnicode_2BYTE_KIND  2
  #define PyUnicode_4BYTE_KIND  4
  #define __Pyx_PyUnicode_READY(op)       (0)
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((sizeof(Py_UNICODE) == 2) ? 65535 : 1114111)
  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  (((void)(k)), ((Py_UNICODE*)d)[i] = ch)
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_SIZE(u))
#endif
#if CYTHON_COMPILING_IN_PYPY
  #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
#else
  #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ?\
      PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyUnicode_Contains)
  #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyByteArray_Check)
  #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Format)
  #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
#endif
#define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None || (PyString_Check(b) && !PyString_CheckExact(b)))) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None || (PyUnicode_Check(b) && !PyUnicode_CheckExact(b)))) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
#else
  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
#endif
#if PY_MAJOR_VERSION < 3 && !defined(PyObject_ASCII)
  #define PyObject_ASCII(o)            PyObject_Repr(o)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
  #define PyObject_Unicode             PyObject_Str
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
#else
  #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif
#if CYTHON_ASSUME_SAFE_MACROS
  #define __Pyx_PySequence_SIZE(seq)  Py_SIZE(seq)
#else
  #define __Pyx_PySequence_SIZE(seq)  PySequence_Size(seq)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
  #define PyNumber_Int                 PyNumber_Long
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif
#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
  #ifndef PyUnicode_InternFromString
    #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
  #endif
#endif
#if PY_VERSION_HEX < 0x030200A4
  typedef long Py_hash_t;
  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
#else
  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : (Py_INCREF(func), func))
#else
  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
#endif
#if CYTHON_USE_ASYNC_SLOTS
  #if PY_VERSION_HEX >= 0x030500B1
    #define __Pyx_PyAsyncMethodsStruct PyAsyncMethods
    #define __Pyx_PyType_AsAsync(obj) (Py_TYPE(obj)->tp_as_async)
  #else
    #define __Pyx_PyType_AsAsync(obj) ((__Pyx_PyAsyncMethodsStruct*) (Py_TYPE(obj)->tp_reserved))
  #endif
#else
  #define __Pyx_PyType_AsAsync(obj) NULL
#endif
#ifndef __Pyx_PyAsyncMethodsStruct
    typedef struct {
        unaryfunc am_await;
        unaryfunc am_aiter;
        unaryfunc am_anext;
    } __Pyx_PyAsyncMethodsStruct;
#endif

#if defined(WIN32) || defined(MS_WINDOWS)
  #define _USE_MATH_DEFINES
#endif
#include <math.h>
#ifdef NAN
#define __PYX_NAN() ((float) NAN)
#else
static CYTHON_INLINE float __PYX_NAN() {
  float value;
  memset(&value, 0xFF, sizeof(value));
  return value;
}
#endif
#if defined(__CYGWIN__) && defined(_LDBL_EQ_DBL)
#define __Pyx_truncl trunc
#else
#define __Pyx_truncl truncl
#endif


#define __PYX_ERR(f_index, lineno, Ln_error) \
{ \
  __pyx_filename = __pyx_f[f_index]; __pyx_lineno = lineno; __pyx_clineno = __LINE__; goto Ln_error; \
}

#ifndef __PYX_EXTERN_C
  #ifdef __cplusplus
    #define __PYX_EXTERN_C extern "C"
  #else
    #define __PYX_EXTERN_C extern
  #endif
#endif

#define __PYX_HAVE__pyarrow___csv
#define __PYX_HAVE_API__pyarrow___csv
/* Early includes */
#include <stdint.h>
#include "ios"
#include "new"
#include "stdexcept"
#include "typeinfo"
#include <memory>
#include <string.h>
#include <string>
#include <utility>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <stdio.h>
#include "pythread.h"
#include "datetime.h"

    #include <type_traits>
    #include <utility>
    namespace cymove {
    template <typename T>
    inline typename std::remove_reference<T>::type&& cymove(T& t) {
        return std::move(t);
    }
    template <typename T>
    inline typename std::remove_reference<T>::type&& cymove(T&& t) {
        return std::move(t);
    }
    }  // namespace cymove
    
#include "arrow/python/platform.h"
#include <Python.h>
#include "numpy/halffloat.h"
#include "arrow/api.h"
#include "arrow/result.h"
#include "arrow/python/common.h"
#include "arrow/util/key_value_metadata.h"
#include "arrow/builder.h"
#include "arrow/io/api.h"
#include "arrow/ipc/api.h"
#include "arrow/csv/api.h"
#include "arrow/json/options.h"
#include "arrow/json/reader.h"
#include "arrow/compute/api.h"
#include "arrow/python/api.h"
#include "arrow/python/init.h"
#include "arrow/python/pyarrow.h"
#include "arrow/python/config.h"
#include "arrow/python/inference.h"
#include "arrow/extension_type.h"
#include "arrow/python/extension_type.h"
#include "arrow/python/benchmark.h"
#include "arrow/util/compression.h"
#include "arrow/util/io_util.h"
#include "arrow/util/iterator.h"
#include "arrow/util/thread_pool.h"
#include "arrow/array/concatenate.h"
#ifdef _OPENMP
#include <omp.h>
#endif /* _OPENMP */

#if defined(PYREX_WITHOUT_ASSERTIONS) && !defined(CYTHON_WITHOUT_ASSERTIONS)
#define CYTHON_WITHOUT_ASSERTIONS
#endif

typedef struct {PyObject **p; const char *s; const Py_ssize_t n; const char* encoding;
                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry;

#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_UTF8 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT (PY_MAJOR_VERSION >= 3 && __PYX_DEFAULT_STRING_ENCODING_IS_UTF8)
#define __PYX_DEFAULT_STRING_ENCODING ""
#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#define __Pyx_uchar_cast(c) ((unsigned char)c)
#define __Pyx_long_cast(x) ((long)x)
#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (\
    (sizeof(type) < sizeof(Py_ssize_t))  ||\
    (sizeof(type) > sizeof(Py_ssize_t) &&\
          likely(v < (type)PY_SSIZE_T_MAX ||\
                 v == (type)PY_SSIZE_T_MAX)  &&\
          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||\
                                v == (type)PY_SSIZE_T_MIN)))  ||\
    (sizeof(type) == sizeof(Py_ssize_t) &&\
          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||\
                               v == (type)PY_SSIZE_T_MAX)))  )
static CYTHON_INLINE int __Pyx_is_valid_index(Py_ssize_t i, Py_ssize_t limit) {
    return (size_t) i < (size_t) limit;
}
#if defined (__cplusplus) && __cplusplus >= 201103L
    #include <cstdlib>
    #define __Pyx_sst_abs(value) std::abs(value)
#elif SIZEOF_INT >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) abs(value)
#elif SIZEOF_LONG >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) labs(value)
#elif defined (_MSC_VER)
    #define __Pyx_sst_abs(value) ((Py_ssize_t)_abs64(value))
#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define __Pyx_sst_abs(value) llabs(value)
#elif defined (__GNUC__)
    #define __Pyx_sst_abs(value) __builtin_llabs(value)
#else
    #define __Pyx_sst_abs(value) ((value<0) ? -value : value)
#endif
static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject*);
static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
#define __Pyx_PyBytes_FromString        PyBytes_FromString
#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char*);
#if PY_MAJOR_VERSION < 3
    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#else
    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
#endif
#define __Pyx_PyBytes_AsWritableString(s)     ((char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsWritableSString(s)    ((signed char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsWritableUString(s)    ((unsigned char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsString(s)     ((const char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsSString(s)    ((const signed char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsUString(s)    ((const unsigned char*) PyBytes_AS_STRING(s))
#define __Pyx_PyObject_AsWritableString(s)    ((char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsWritableSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsWritableUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsSString(s)    ((const signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsUString(s)    ((const unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
#define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
#define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
#define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
#define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u) {
    const Py_UNICODE *u_end = u;
    while (*u_end++) ;
    return (size_t)(u_end - u - 1);
}
#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
#define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
#define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b);
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
#define __Pyx_PySequence_Tuple(obj)\
    (likely(PyTuple_CheckExact(obj)) ? __Pyx_NewRef(obj) : PySequence_Tuple(obj))
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
#if CYTHON_ASSUME_SAFE_MACROS
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
#else
#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
#endif
#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
#if PY_MAJOR_VERSION >= 3
#define __Pyx_PyNumber_Int(x) (PyLong_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Long(x))
#else
#define __Pyx_PyNumber_Int(x) (PyInt_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Int(x))
#endif
#define __Pyx_PyNumber_Float(x) (PyFloat_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Float(x))
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
static int __Pyx_sys_getdefaultencoding_not_ascii;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    PyObject* ascii_chars_u = NULL;
    PyObject* ascii_chars_b = NULL;
    const char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    if (strcmp(default_encoding_c, "ascii") == 0) {
        __Pyx_sys_getdefaultencoding_not_ascii = 0;
    } else {
        char ascii_chars[128];
        int c;
        for (c = 0; c < 128; c++) {
            ascii_chars[c] = c;
        }
        __Pyx_sys_getdefaultencoding_not_ascii = 1;
        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
        if (!ascii_chars_u) goto bad;
        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
        if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
            PyErr_Format(
                PyExc_ValueError,
                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
                default_encoding_c);
            goto bad;
        }
        Py_DECREF(ascii_chars_u);
        Py_DECREF(ascii_chars_b);
    }
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    Py_XDECREF(ascii_chars_u);
    Py_XDECREF(ascii_chars_b);
    return -1;
}
#endif
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
#else
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
static char* __PYX_DEFAULT_STRING_ENCODING;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c) + 1);
    if (!__PYX_DEFAULT_STRING_ENCODING) goto bad;
    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    return -1;
}
#endif
#endif


/* Test for GCC > 2.95 */
#if defined(__GNUC__)     && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)))
  #define likely(x)   __builtin_expect(!!(x), 1)
  #define unlikely(x) __builtin_expect(!!(x), 0)
#else /* !__GNUC__ or GCC < 2.95 */
  #define likely(x)   (x)
  #define unlikely(x) (x)
#endif /* __GNUC__ */
static CYTHON_INLINE void __Pyx_pretend_to_initialize(void* ptr) { (void)ptr; }

static PyObject *__pyx_m = NULL;
static PyObject *__pyx_d;
static PyObject *__pyx_b;
static PyObject *__pyx_cython_runtime = NULL;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static PyObject *__pyx_empty_unicode;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;


static const char *__pyx_f[] = {
  "pyarrow/_csv.pyx",
  "stringsource",
  "datetime.pxd",
  "type.pxd",
  "bool.pxd",
  "complex.pxd",
  "pyarrow/lib.pxd",
};
/* NoFastGil.proto */
#define __Pyx_PyGILState_Ensure PyGILState_Ensure
#define __Pyx_PyGILState_Release PyGILState_Release
#define __Pyx_FastGIL_Remember()
#define __Pyx_FastGIL_Forget()
#define __Pyx_FastGilFuncInit()

/* ForceInitThreads.proto */
#ifndef __PYX_FORCE_INIT_THREADS
  #define __PYX_FORCE_INIT_THREADS 0
#endif


/*--- Type declarations ---*/
struct __pyx_obj_7pyarrow_3lib_Message;
struct __pyx_obj_7pyarrow_3lib_MemoryPool;
struct __pyx_obj_7pyarrow_3lib_DataType;
struct __pyx_obj_7pyarrow_3lib_ListType;
struct __pyx_obj_7pyarrow_3lib_LargeListType;
struct __pyx_obj_7pyarrow_3lib_MapType;
struct __pyx_obj_7pyarrow_3lib_FixedSizeListType;
struct __pyx_obj_7pyarrow_3lib_StructType;
struct __pyx_obj_7pyarrow_3lib_DictionaryMemo;
struct __pyx_obj_7pyarrow_3lib_DictionaryType;
struct __pyx_obj_7pyarrow_3lib_TimestampType;
struct __pyx_obj_7pyarrow_3lib_Time32Type;
struct __pyx_obj_7pyarrow_3lib_Time64Type;
struct __pyx_obj_7pyarrow_3lib_DurationType;
struct __pyx_obj_7pyarrow_3lib_FixedSizeBinaryType;
struct __pyx_obj_7pyarrow_3lib_Decimal128Type;
struct __pyx_obj_7pyarrow_3lib_BaseExtensionType;
struct __pyx_obj_7pyarrow_3lib_ExtensionType;
struct __pyx_obj_7pyarrow_3lib_PyExtensionType;
struct __pyx_obj_7pyarrow_3lib_Field;
struct __pyx_obj_7pyarrow_3lib_Schema;
struct __pyx_obj_7pyarrow_3lib_Scalar;
struct __pyx_obj_7pyarrow_3lib_NAType;
struct __pyx_obj_7pyarrow_3lib_ArrayValue;
struct __pyx_obj_7pyarrow_3lib_ScalarValue;
struct __pyx_obj_7pyarrow_3lib_Int8Value;
struct __pyx_obj_7pyarrow_3lib_Int64Value;
struct __pyx_obj_7pyarrow_3lib_ListValue;
struct __pyx_obj_7pyarrow_3lib_LargeListValue;
struct __pyx_obj_7pyarrow_3lib_MapValue;
struct __pyx_obj_7pyarrow_3lib_FixedSizeListValue;
struct __pyx_obj_7pyarrow_3lib_StructValue;
struct __pyx_obj_7pyarrow_3lib_UnionValue;
struct __pyx_obj_7pyarrow_3lib_StringValue;
struct __pyx_obj_7pyarrow_3lib_FixedSizeBinaryValue;
struct __pyx_obj_7pyarrow_3lib__PandasConvertible;
struct __pyx_obj_7pyarrow_3lib_Array;
struct __pyx_obj_7pyarrow_3lib_Tensor;
struct __pyx_obj_7pyarrow_3lib_SparseCSRMatrix;
struct __pyx_obj_7pyarrow_3lib_SparseCOOTensor;
struct __pyx_obj_7pyarrow_3lib_NullArray;
struct __pyx_obj_7pyarrow_3lib_BooleanArray;
struct __pyx_obj_7pyarrow_3lib_NumericArray;
struct __pyx_obj_7pyarrow_3lib_IntegerArray;
struct __pyx_obj_7pyarrow_3lib_FloatingPointArray;
struct __pyx_obj_7pyarrow_3lib_Int8Array;
struct __pyx_obj_7pyarrow_3lib_UInt8Array;
struct __pyx_obj_7pyarrow_3lib_Int16Array;
struct __pyx_obj_7pyarrow_3lib_UInt16Array;
struct __pyx_obj_7pyarrow_3lib_Int32Array;
struct __pyx_obj_7pyarrow_3lib_UInt32Array;
struct __pyx_obj_7pyarrow_3lib_Int64Array;
struct __pyx_obj_7pyarrow_3lib_UInt64Array;
struct __pyx_obj_7pyarrow_3lib_HalfFloatArray;
struct __pyx_obj_7pyarrow_3lib_FloatArray;
struct __pyx_obj_7pyarrow_3lib_DoubleArray;
struct __pyx_obj_7pyarrow_3lib_FixedSizeBinaryArray;
struct __pyx_obj_7pyarrow_3lib_Decimal128Array;
struct __pyx_obj_7pyarrow_3lib_StructArray;
struct __pyx_obj_7pyarrow_3lib_ListArray;
struct __pyx_obj_7pyarrow_3lib_LargeListArray;
struct __pyx_obj_7pyarrow_3lib_MapArray;
struct __pyx_obj_7pyarrow_3lib_FixedSizeListArray;
struct __pyx_obj_7pyarrow_3lib_UnionArray;
struct __pyx_obj_7pyarrow_3lib_StringArray;
struct __pyx_obj_7pyarrow_3lib_BinaryArray;
struct __pyx_obj_7pyarrow_3lib_DictionaryArray;
struct __pyx_obj_7pyarrow_3lib_ExtensionArray;
struct __pyx_obj_7pyarrow_3lib_ChunkedArray;
struct __pyx_obj_7pyarrow_3lib_Table;
struct __pyx_obj_7pyarrow_3lib_RecordBatch;
struct __pyx_obj_7pyarrow_3lib_Buffer;
struct __pyx_obj_7pyarrow_3lib_ResizableBuffer;
struct __pyx_obj_7pyarrow_3lib_NativeFile;
struct __pyx_obj_7pyarrow_3lib_BufferedInputStream;
struct __pyx_obj_7pyarrow_3lib_BufferedOutputStream;
struct __pyx_obj_7pyarrow_3lib_CompressedInputStream;
struct __pyx_obj_7pyarrow_3lib_CompressedOutputStream;
struct __pyx_obj_7pyarrow_3lib__CRecordBatchWriter;
struct __pyx_obj_7pyarrow_3lib__CRecordBatchReader;
struct __pyx_obj_7pyarrow_3lib_CastOptions;
struct __pyx_obj_7pyarrow_4_csv_ReadOptions;
struct __pyx_obj_7pyarrow_4_csv_ParseOptions;
struct __pyx_obj_7pyarrow_4_csv_ConvertOptions;
struct __pyx_opt_args_7pyarrow_3lib_ensure_type;

/* "pyarrow/lib.pxd":553
 * 
 * # Default is allow_none=False
 * cdef DataType ensure_type(object type, c_bool allow_none=*)             # <<<<<<<<<<<<<<
 * 
 * cdef shared_ptr[CKeyValueMetadata] pyarrow_unwrap_metadata(object meta)
 */
struct __pyx_opt_args_7pyarrow_3lib_ensure_type {
  int __pyx_n;
  bool allow_none;
};

/* "pyarrow/lib.pxd":36
 * cdef int check_status(const CStatus& status) nogil except -1
 * 
 * cdef class Message:             # <<<<<<<<<<<<<<
 *     cdef:
 *         unique_ptr[CMessage] message
 */
struct __pyx_obj_7pyarrow_3lib_Message {
  PyObject_HEAD
  std::unique_ptr< arrow::ipc::Message>  message;
};


/* "pyarrow/lib.pxd":41
 * 
 * 
 * cdef class MemoryPool:             # <<<<<<<<<<<<<<
 *     cdef:
 *         CMemoryPool* pool
 */
struct __pyx_obj_7pyarrow_3lib_MemoryPool {
  PyObject_HEAD
  struct __pyx_vtabstruct_7pyarrow_3lib_MemoryPool *__pyx_vtab;
   arrow::MemoryPool *pool;
};


/* "pyarrow/lib.pxd":51
 * 
 * 
 * cdef class DataType:             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CDataType] sp_type
 */
struct __pyx_obj_7pyarrow_3lib_DataType {
  PyObject_HEAD
  struct __pyx_vtabstruct_7pyarrow_3lib_DataType *__pyx_vtab;
  std::shared_ptr< arrow::DataType>  sp_type;
   arrow::DataType *type;
  PyObject *pep3118_format;
  PyObject *__weakref__;
};


/* "pyarrow/lib.pxd":62
 * 
 * 
 * cdef class ListType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CListType* list_type
 */
struct __pyx_obj_7pyarrow_3lib_ListType {
  struct __pyx_obj_7pyarrow_3lib_DataType __pyx_base;
   arrow::ListType const *list_type;
};


/* "pyarrow/lib.pxd":67
 * 
 * 
 * cdef class LargeListType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CLargeListType* list_type
 */
struct __pyx_obj_7pyarrow_3lib_LargeListType {
  struct __pyx_obj_7pyarrow_3lib_DataType __pyx_base;
   arrow::LargeListType const *list_type;
};


/* "pyarrow/lib.pxd":72
 * 
 * 
 * cdef class MapType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CMapType* map_type
 */
struct __pyx_obj_7pyarrow_3lib_MapType {
  struct __pyx_obj_7pyarrow_3lib_DataType __pyx_base;
   arrow::MapType const *map_type;
};


/* "pyarrow/lib.pxd":77
 * 
 * 
 * cdef class FixedSizeListType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CFixedSizeListType* list_type
 */
struct __pyx_obj_7pyarrow_3lib_FixedSizeListType {
  struct __pyx_obj_7pyarrow_3lib_DataType __pyx_base;
   arrow::FixedSizeListType const *list_type;
};


/* "pyarrow/lib.pxd":82
 * 
 * 
 * cdef class StructType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CStructType* struct_type
 */
struct __pyx_obj_7pyarrow_3lib_StructType {
  struct __pyx_obj_7pyarrow_3lib_DataType __pyx_base;
   arrow::StructType const *struct_type;
};


/* "pyarrow/lib.pxd":90
 * 
 * 
 * cdef class DictionaryMemo:             # <<<<<<<<<<<<<<
 *     cdef:
 *         # Even though the CDictionaryMemo instance is private, we allocate
 */
struct __pyx_obj_7pyarrow_3lib_DictionaryMemo {
  PyObject_HEAD
  std::shared_ptr< arrow::ipc::DictionaryMemo>  sp_memo;
   arrow::ipc::DictionaryMemo *memo;
};


/* "pyarrow/lib.pxd":98
 * 
 * 
 * cdef class DictionaryType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CDictionaryType* dict_type
 */
struct __pyx_obj_7pyarrow_3lib_DictionaryType {
  struct __pyx_obj_7pyarrow_3lib_DataType __pyx_base;
   arrow::DictionaryType const *dict_type;
};


/* "pyarrow/lib.pxd":103
 * 
 * 
 * cdef class TimestampType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CTimestampType* ts_type
 */
struct __pyx_obj_7pyarrow_3lib_TimestampType {
  struct __pyx_obj_7pyarrow_3lib_DataType __pyx_base;
   arrow::TimestampType const *ts_type;
};


/* "pyarrow/lib.pxd":108
 * 
 * 
 * cdef class Time32Type(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CTime32Type* time_type
 */
struct __pyx_obj_7pyarrow_3lib_Time32Type {
  struct __pyx_obj_7pyarrow_3lib_DataType __pyx_base;
   arrow::Time32Type const *time_type;
};


/* "pyarrow/lib.pxd":113
 * 
 * 
 * cdef class Time64Type(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CTime64Type* time_type
 */
struct __pyx_obj_7pyarrow_3lib_Time64Type {
  struct __pyx_obj_7pyarrow_3lib_DataType __pyx_base;
   arrow::Time64Type const *time_type;
};


/* "pyarrow/lib.pxd":118
 * 
 * 
 * cdef class DurationType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CDurationType* duration_type
 */
struct __pyx_obj_7pyarrow_3lib_DurationType {
  struct __pyx_obj_7pyarrow_3lib_DataType __pyx_base;
   arrow::DurationType const *duration_type;
};


/* "pyarrow/lib.pxd":123
 * 
 * 
 * cdef class FixedSizeBinaryType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CFixedSizeBinaryType* fixed_size_binary_type
 */
struct __pyx_obj_7pyarrow_3lib_FixedSizeBinaryType {
  struct __pyx_obj_7pyarrow_3lib_DataType __pyx_base;
   arrow::FixedSizeBinaryType const *fixed_size_binary_type;
};


/* "pyarrow/lib.pxd":128
 * 
 * 
 * cdef class Decimal128Type(FixedSizeBinaryType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CDecimal128Type* decimal128_type
 */
struct __pyx_obj_7pyarrow_3lib_Decimal128Type {
  struct __pyx_obj_7pyarrow_3lib_FixedSizeBinaryType __pyx_base;
   arrow::Decimal128Type const *decimal128_type;
};


/* "pyarrow/lib.pxd":133
 * 
 * 
 * cdef class BaseExtensionType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CExtensionType* ext_type
 */
struct __pyx_obj_7pyarrow_3lib_BaseExtensionType {
  struct __pyx_obj_7pyarrow_3lib_DataType __pyx_base;
   arrow::ExtensionType const *ext_type;
};


/* "pyarrow/lib.pxd":138
 * 
 * 
 * cdef class ExtensionType(BaseExtensionType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CPyExtensionType* cpy_ext_type
 */
struct __pyx_obj_7pyarrow_3lib_ExtensionType {
  struct __pyx_obj_7pyarrow_3lib_BaseExtensionType __pyx_base;
   arrow::py::PyExtensionType const *cpy_ext_type;
};


/* "pyarrow/lib.pxd":143
 * 
 * 
 * cdef class PyExtensionType(ExtensionType):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_PyExtensionType {
  struct __pyx_obj_7pyarrow_3lib_ExtensionType __pyx_base;
};


/* "pyarrow/lib.pxd":147
 * 
 * 
 * cdef class Field:             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CField] sp_field
 */
struct __pyx_obj_7pyarrow_3lib_Field {
  PyObject_HEAD
  struct __pyx_vtabstruct_7pyarrow_3lib_Field *__pyx_vtab;
  std::shared_ptr< arrow::Field>  sp_field;
   arrow::Field *field;
  struct __pyx_obj_7pyarrow_3lib_DataType *type;
};


/* "pyarrow/lib.pxd":158
 * 
 * 
 * cdef class Schema:             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CSchema] sp_schema
 */
struct __pyx_obj_7pyarrow_3lib_Schema {
  PyObject_HEAD
  struct __pyx_vtabstruct_7pyarrow_3lib_Schema *__pyx_vtab;
  std::shared_ptr< arrow::Schema>  sp_schema;
   arrow::Schema *schema;
};


/* "pyarrow/lib.pxd":167
 * 
 * 
 * cdef class Scalar:             # <<<<<<<<<<<<<<
 *     cdef readonly:
 *         DataType type
 */
struct __pyx_obj_7pyarrow_3lib_Scalar {
  PyObject_HEAD
  struct __pyx_obj_7pyarrow_3lib_DataType *type;
};


/* "pyarrow/lib.pxd":172
 * 
 * 
 * cdef class NAType(Scalar):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_NAType {
  struct __pyx_obj_7pyarrow_3lib_Scalar __pyx_base;
};


/* "pyarrow/lib.pxd":176
 * 
 * 
 * cdef class ArrayValue(Scalar):             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CArray] sp_array
 */
struct __pyx_obj_7pyarrow_3lib_ArrayValue {
  struct __pyx_obj_7pyarrow_3lib_Scalar __pyx_base;
  struct __pyx_vtabstruct_7pyarrow_3lib_ArrayValue *__pyx_vtab;
  std::shared_ptr< arrow::Array>  sp_array;
  int64_t index;
};


/* "pyarrow/lib.pxd":186
 *     cdef void _set_array(self, const shared_ptr[CArray]& sp_array)
 * 
 * cdef class ScalarValue(Scalar):             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CScalar] sp_scalar
 */
struct __pyx_obj_7pyarrow_3lib_ScalarValue {
  struct __pyx_obj_7pyarrow_3lib_Scalar __pyx_base;
  struct __pyx_vtabstruct_7pyarrow_3lib_ScalarValue *__pyx_vtab;
  std::shared_ptr< arrow::Scalar>  sp_scalar;
};


/* "pyarrow/lib.pxd":192
 *     cdef void init(self, const shared_ptr[CScalar]& sp_scalar)
 * 
 * cdef class Int8Value(ArrayValue):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_Int8Value {
  struct __pyx_obj_7pyarrow_3lib_ArrayValue __pyx_base;
};


/* "pyarrow/lib.pxd":196
 * 
 * 
 * cdef class Int64Value(ArrayValue):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_Int64Value {
  struct __pyx_obj_7pyarrow_3lib_ArrayValue __pyx_base;
};


/* "pyarrow/lib.pxd":200
 * 
 * 
 * cdef class ListValue(ArrayValue):             # <<<<<<<<<<<<<<
 *     cdef readonly:
 *         DataType value_type
 */
struct __pyx_obj_7pyarrow_3lib_ListValue {
  struct __pyx_obj_7pyarrow_3lib_ArrayValue __pyx_base;
  struct __pyx_obj_7pyarrow_3lib_DataType *value_type;
   arrow::ListArray *ap;
};


/* "pyarrow/lib.pxd":211
 * 
 * 
 * cdef class LargeListValue(ArrayValue):             # <<<<<<<<<<<<<<
 *     cdef readonly:
 *         DataType value_type
 */
struct __pyx_obj_7pyarrow_3lib_LargeListValue {
  struct __pyx_obj_7pyarrow_3lib_ArrayValue __pyx_base;
  struct __pyx_obj_7pyarrow_3lib_DataType *value_type;
   arrow::LargeListArray *ap;
};


/* "pyarrow/lib.pxd":222
 * 
 * 
 * cdef class MapValue(ArrayValue):             # <<<<<<<<<<<<<<
 *     cdef readonly:
 *         DataType key_type
 */
struct __pyx_obj_7pyarrow_3lib_MapValue {
  struct __pyx_obj_7pyarrow_3lib_ArrayValue __pyx_base;
  struct __pyx_obj_7pyarrow_3lib_DataType *key_type;
  struct __pyx_obj_7pyarrow_3lib_DataType *item_type;
   arrow::MapArray *ap;
};


/* "pyarrow/lib.pxd":234
 * 
 * 
 * cdef class FixedSizeListValue(ArrayValue):             # <<<<<<<<<<<<<<
 *     cdef readonly:
 *         DataType value_type
 */
struct __pyx_obj_7pyarrow_3lib_FixedSizeListValue {
  struct __pyx_obj_7pyarrow_3lib_ArrayValue __pyx_base;
  struct __pyx_obj_7pyarrow_3lib_DataType *value_type;
   arrow::FixedSizeListArray *ap;
};


/* "pyarrow/lib.pxd":245
 * 
 * 
 * cdef class StructValue(ArrayValue):             # <<<<<<<<<<<<<<
 *     cdef:
 *         CStructArray* ap
 */
struct __pyx_obj_7pyarrow_3lib_StructValue {
  struct __pyx_obj_7pyarrow_3lib_ArrayValue __pyx_base;
   arrow::StructArray *ap;
};


/* "pyarrow/lib.pxd":250
 * 
 * 
 * cdef class UnionValue(ArrayValue):             # <<<<<<<<<<<<<<
 *     cdef:
 *         CUnionArray* ap
 */
struct __pyx_obj_7pyarrow_3lib_UnionValue {
  struct __pyx_obj_7pyarrow_3lib_ArrayValue __pyx_base;
   arrow::UnionArray *ap;
  PyObject *value_types;
};


/* "pyarrow/lib.pxd":258
 * 
 * 
 * cdef class StringValue(ArrayValue):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_StringValue {
  struct __pyx_obj_7pyarrow_3lib_ArrayValue __pyx_base;
};


/* "pyarrow/lib.pxd":262
 * 
 * 
 * cdef class FixedSizeBinaryValue(ArrayValue):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_FixedSizeBinaryValue {
  struct __pyx_obj_7pyarrow_3lib_ArrayValue __pyx_base;
};


/* "pyarrow/lib.pxd":266
 * 
 * 
 * cdef class _PandasConvertible:             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib__PandasConvertible {
  PyObject_HEAD
};


/* "pyarrow/lib.pxd":270
 * 
 * 
 * cdef class Array(_PandasConvertible):             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CArray] sp_array
 */
struct __pyx_obj_7pyarrow_3lib_Array {
  struct __pyx_obj_7pyarrow_3lib__PandasConvertible __pyx_base;
  struct __pyx_vtabstruct_7pyarrow_3lib_Array *__pyx_vtab;
  std::shared_ptr< arrow::Array>  sp_array;
   arrow::Array *ap;
  PyObject *__weakref__;
  struct __pyx_obj_7pyarrow_3lib_DataType *type;
  PyObject *_name;
};


/* "pyarrow/lib.pxd":286
 * 
 * 
 * cdef class Tensor:             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CTensor] sp_tensor
 */
struct __pyx_obj_7pyarrow_3lib_Tensor {
  PyObject_HEAD
  struct __pyx_vtabstruct_7pyarrow_3lib_Tensor *__pyx_vtab;
  std::shared_ptr< arrow::Tensor>  sp_tensor;
   arrow::Tensor *tp;
  struct __pyx_obj_7pyarrow_3lib_DataType *type;
};


/* "pyarrow/lib.pxd":297
 * 
 * 
 * cdef class SparseCSRMatrix:             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CSparseCSRMatrix] sp_sparse_tensor
 */
struct __pyx_obj_7pyarrow_3lib_SparseCSRMatrix {
  PyObject_HEAD
  struct __pyx_vtabstruct_7pyarrow_3lib_SparseCSRMatrix *__pyx_vtab;
  std::shared_ptr< arrow::SparseCSRMatrix>  sp_sparse_tensor;
   arrow::SparseCSRMatrix *stp;
  struct __pyx_obj_7pyarrow_3lib_DataType *type;
};


/* "pyarrow/lib.pxd":308
 * 
 * 
 * cdef class SparseCOOTensor:             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CSparseCOOTensor] sp_sparse_tensor
 */
struct __pyx_obj_7pyarrow_3lib_SparseCOOTensor {
  PyObject_HEAD
  struct __pyx_vtabstruct_7pyarrow_3lib_SparseCOOTensor *__pyx_vtab;
  std::shared_ptr< arrow::SparseCOOTensor>  sp_sparse_tensor;
   arrow::SparseCOOTensor *stp;
  struct __pyx_obj_7pyarrow_3lib_DataType *type;
};


/* "pyarrow/lib.pxd":319
 * 
 * 
 * cdef class NullArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_NullArray {
  struct __pyx_obj_7pyarrow_3lib_Array __pyx_base;
};


/* "pyarrow/lib.pxd":323
 * 
 * 
 * cdef class BooleanArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_BooleanArray {
  struct __pyx_obj_7pyarrow_3lib_Array __pyx_base;
};


/* "pyarrow/lib.pxd":327
 * 
 * 
 * cdef class NumericArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_NumericArray {
  struct __pyx_obj_7pyarrow_3lib_Array __pyx_base;
};


/* "pyarrow/lib.pxd":331
 * 
 * 
 * cdef class IntegerArray(NumericArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_IntegerArray {
  struct __pyx_obj_7pyarrow_3lib_NumericArray __pyx_base;
};


/* "pyarrow/lib.pxd":335
 * 
 * 
 * cdef class FloatingPointArray(NumericArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_FloatingPointArray {
  struct __pyx_obj_7pyarrow_3lib_NumericArray __pyx_base;
};


/* "pyarrow/lib.pxd":339
 * 
 * 
 * cdef class Int8Array(IntegerArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_Int8Array {
  struct __pyx_obj_7pyarrow_3lib_IntegerArray __pyx_base;
};


/* "pyarrow/lib.pxd":343
 * 
 * 
 * cdef class UInt8Array(IntegerArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_UInt8Array {
  struct __pyx_obj_7pyarrow_3lib_IntegerArray __pyx_base;
};


/* "pyarrow/lib.pxd":347
 * 
 * 
 * cdef class Int16Array(IntegerArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_Int16Array {
  struct __pyx_obj_7pyarrow_3lib_IntegerArray __pyx_base;
};


/* "pyarrow/lib.pxd":351
 * 
 * 
 * cdef class UInt16Array(IntegerArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_UInt16Array {
  struct __pyx_obj_7pyarrow_3lib_IntegerArray __pyx_base;
};


/* "pyarrow/lib.pxd":355
 * 
 * 
 * cdef class Int32Array(IntegerArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_Int32Array {
  struct __pyx_obj_7pyarrow_3lib_IntegerArray __pyx_base;
};


/* "pyarrow/lib.pxd":359
 * 
 * 
 * cdef class UInt32Array(IntegerArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_UInt32Array {
  struct __pyx_obj_7pyarrow_3lib_IntegerArray __pyx_base;
};


/* "pyarrow/lib.pxd":363
 * 
 * 
 * cdef class Int64Array(IntegerArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_Int64Array {
  struct __pyx_obj_7pyarrow_3lib_IntegerArray __pyx_base;
};


/* "pyarrow/lib.pxd":367
 * 
 * 
 * cdef class UInt64Array(IntegerArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_UInt64Array {
  struct __pyx_obj_7pyarrow_3lib_IntegerArray __pyx_base;
};


/* "pyarrow/lib.pxd":371
 * 
 * 
 * cdef class HalfFloatArray(FloatingPointArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_HalfFloatArray {
  struct __pyx_obj_7pyarrow_3lib_FloatingPointArray __pyx_base;
};


/* "pyarrow/lib.pxd":375
 * 
 * 
 * cdef class FloatArray(FloatingPointArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_FloatArray {
  struct __pyx_obj_7pyarrow_3lib_FloatingPointArray __pyx_base;
};


/* "pyarrow/lib.pxd":379
 * 
 * 
 * cdef class DoubleArray(FloatingPointArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_DoubleArray {
  struct __pyx_obj_7pyarrow_3lib_FloatingPointArray __pyx_base;
};


/* "pyarrow/lib.pxd":383
 * 
 * 
 * cdef class FixedSizeBinaryArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_FixedSizeBinaryArray {
  struct __pyx_obj_7pyarrow_3lib_Array __pyx_base;
};


/* "pyarrow/lib.pxd":387
 * 
 * 
 * cdef class Decimal128Array(FixedSizeBinaryArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_Decimal128Array {
  struct __pyx_obj_7pyarrow_3lib_FixedSizeBinaryArray __pyx_base;
};


/* "pyarrow/lib.pxd":391
 * 
 * 
 * cdef class StructArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_StructArray {
  struct __pyx_obj_7pyarrow_3lib_Array __pyx_base;
};


/* "pyarrow/lib.pxd":395
 * 
 * 
 * cdef class ListArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_ListArray {
  struct __pyx_obj_7pyarrow_3lib_Array __pyx_base;
};


/* "pyarrow/lib.pxd":399
 * 
 * 
 * cdef class LargeListArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_LargeListArray {
  struct __pyx_obj_7pyarrow_3lib_Array __pyx_base;
};


/* "pyarrow/lib.pxd":403
 * 
 * 
 * cdef class MapArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_MapArray {
  struct __pyx_obj_7pyarrow_3lib_Array __pyx_base;
};


/* "pyarrow/lib.pxd":407
 * 
 * 
 * cdef class FixedSizeListArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_FixedSizeListArray {
  struct __pyx_obj_7pyarrow_3lib_Array __pyx_base;
};


/* "pyarrow/lib.pxd":411
 * 
 * 
 * cdef class UnionArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_UnionArray {
  struct __pyx_obj_7pyarrow_3lib_Array __pyx_base;
};


/* "pyarrow/lib.pxd":415
 * 
 * 
 * cdef class StringArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_StringArray {
  struct __pyx_obj_7pyarrow_3lib_Array __pyx_base;
};


/* "pyarrow/lib.pxd":419
 * 
 * 
 * cdef class BinaryArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_BinaryArray {
  struct __pyx_obj_7pyarrow_3lib_Array __pyx_base;
};


/* "pyarrow/lib.pxd":423
 * 
 * 
 * cdef class DictionaryArray(Array):             # <<<<<<<<<<<<<<
 *     cdef:
 *         object _indices, _dictionary
 */
struct __pyx_obj_7pyarrow_3lib_DictionaryArray {
  struct __pyx_obj_7pyarrow_3lib_Array __pyx_base;
  PyObject *_indices;
  PyObject *_dictionary;
};


/* "pyarrow/lib.pxd":428
 * 
 * 
 * cdef class ExtensionArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_ExtensionArray {
  struct __pyx_obj_7pyarrow_3lib_Array __pyx_base;
};


/* "pyarrow/lib.pxd":439
 * 
 * 
 * cdef class ChunkedArray(_PandasConvertible):             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CChunkedArray] sp_chunked_array
 */
struct __pyx_obj_7pyarrow_3lib_ChunkedArray {
  struct __pyx_obj_7pyarrow_3lib__PandasConvertible __pyx_base;
  struct __pyx_vtabstruct_7pyarrow_3lib_ChunkedArray *__pyx_vtab;
  std::shared_ptr< arrow::ChunkedArray>  sp_chunked_array;
   arrow::ChunkedArray *chunked_array;
  PyObject *_name;
};


/* "pyarrow/lib.pxd":452
 * 
 * 
 * cdef class Table(_PandasConvertible):             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CTable] sp_table
 */
struct __pyx_obj_7pyarrow_3lib_Table {
  struct __pyx_obj_7pyarrow_3lib__PandasConvertible __pyx_base;
  struct __pyx_vtabstruct_7pyarrow_3lib_Table *__pyx_vtab;
  std::shared_ptr< arrow::Table>  sp_table;
   arrow::Table *table;
};


/* "pyarrow/lib.pxd":460
 * 
 * 
 * cdef class RecordBatch(_PandasConvertible):             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CRecordBatch] sp_batch
 */
struct __pyx_obj_7pyarrow_3lib_RecordBatch {
  struct __pyx_obj_7pyarrow_3lib__PandasConvertible __pyx_base;
  struct __pyx_vtabstruct_7pyarrow_3lib_RecordBatch *__pyx_vtab;
  std::shared_ptr< arrow::RecordBatch>  sp_batch;
   arrow::RecordBatch *batch;
  struct __pyx_obj_7pyarrow_3lib_Schema *_schema;
};


/* "pyarrow/lib.pxd":469
 * 
 * 
 * cdef class Buffer:             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CBuffer] buffer
 */
struct __pyx_obj_7pyarrow_3lib_Buffer {
  PyObject_HEAD
  struct __pyx_vtabstruct_7pyarrow_3lib_Buffer *__pyx_vtab;
  std::shared_ptr< arrow::Buffer>  buffer;
  Py_ssize_t shape[1];
  Py_ssize_t strides[1];
};


/* "pyarrow/lib.pxd":479
 * 
 * 
 * cdef class ResizableBuffer(Buffer):             # <<<<<<<<<<<<<<
 * 
 *     cdef void init_rz(self, const shared_ptr[CResizableBuffer]& buffer)
 */
struct __pyx_obj_7pyarrow_3lib_ResizableBuffer {
  struct __pyx_obj_7pyarrow_3lib_Buffer __pyx_base;
};


/* "pyarrow/lib.pxd":484
 * 
 * 
 * cdef class NativeFile:             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CInputStream] input_stream
 */
struct __pyx_obj_7pyarrow_3lib_NativeFile {
  PyObject_HEAD
  struct __pyx_vtabstruct_7pyarrow_3lib_NativeFile *__pyx_vtab;
  std::shared_ptr< arrow::io::InputStream>  input_stream;
  std::shared_ptr< arrow::io::RandomAccessFile>  random_access;
  std::shared_ptr< arrow::io::OutputStream>  output_stream;
  int is_readable;
  int is_writable;
  int is_seekable;
  int own_file;
  PyObject *__weakref__;
};


/* "pyarrow/lib.pxd":508
 * 
 * 
 * cdef class BufferedInputStream(NativeFile):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_BufferedInputStream {
  struct __pyx_obj_7pyarrow_3lib_NativeFile __pyx_base;
};


/* "pyarrow/lib.pxd":512
 * 
 * 
 * cdef class BufferedOutputStream(NativeFile):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_BufferedOutputStream {
  struct __pyx_obj_7pyarrow_3lib_NativeFile __pyx_base;
};


/* "pyarrow/lib.pxd":516
 * 
 * 
 * cdef class CompressedInputStream(NativeFile):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_CompressedInputStream {
  struct __pyx_obj_7pyarrow_3lib_NativeFile __pyx_base;
};


/* "pyarrow/lib.pxd":520
 * 
 * 
 * cdef class CompressedOutputStream(NativeFile):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pyarrow_3lib_CompressedOutputStream {
  struct __pyx_obj_7pyarrow_3lib_NativeFile __pyx_base;
};


/* "pyarrow/lib.pxd":524
 * 
 * 
 * cdef class _CRecordBatchWriter:             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CRecordBatchWriter] writer
 */
struct __pyx_obj_7pyarrow_3lib__CRecordBatchWriter {
  PyObject_HEAD
  std::shared_ptr< arrow::ipc::RecordBatchWriter>  writer;
};


/* "pyarrow/lib.pxd":529
 * 
 * 
 * cdef class _CRecordBatchReader:             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CRecordBatchReader] reader
 */
struct __pyx_obj_7pyarrow_3lib__CRecordBatchReader {
  PyObject_HEAD
  std::shared_ptr< arrow::RecordBatchReader>  reader;
};


/* "pyarrow/lib.pxd":534
 * 
 * 
 * cdef class CastOptions:             # <<<<<<<<<<<<<<
 *     cdef:
 *         CCastOptions options
 */
struct __pyx_obj_7pyarrow_3lib_CastOptions {
  PyObject_HEAD
  struct __pyx_vtabstruct_7pyarrow_3lib_CastOptions *__pyx_vtab;
   arrow::compute::CastOptions options;
};


/* "pyarrow/_csv.pyx":42
 * 
 * 
 * cdef class ReadOptions:             # <<<<<<<<<<<<<<
 *     """
 *     Options for reading CSV files.
 */
struct __pyx_obj_7pyarrow_4_csv_ReadOptions {
  PyObject_HEAD
   arrow::csv::ReadOptions options;
};


/* "pyarrow/_csv.pyx":151
 * 
 * 
 * cdef class ParseOptions:             # <<<<<<<<<<<<<<
 *     """
 *     Options for parsing CSV files.
 */
struct __pyx_obj_7pyarrow_4_csv_ParseOptions {
  PyObject_HEAD
   arrow::csv::ParseOptions options;
};


/* "pyarrow/_csv.pyx":287
 * 
 * 
 * cdef class ConvertOptions:             # <<<<<<<<<<<<<<
 *     """
 *     Options for converting CSV data.
 */
struct __pyx_obj_7pyarrow_4_csv_ConvertOptions {
  PyObject_HEAD
   arrow::csv::ConvertOptions options;
};



/* "pyarrow/lib.pxd":41
 * 
 * 
 * cdef class MemoryPool:             # <<<<<<<<<<<<<<
 *     cdef:
 *         CMemoryPool* pool
 */

struct __pyx_vtabstruct_7pyarrow_3lib_MemoryPool {
  void (*init)(struct __pyx_obj_7pyarrow_3lib_MemoryPool *,  arrow::MemoryPool *);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_MemoryPool *__pyx_vtabptr_7pyarrow_3lib_MemoryPool;


/* "pyarrow/lib.pxd":51
 * 
 * 
 * cdef class DataType:             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CDataType] sp_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_DataType {
  void (*init)(struct __pyx_obj_7pyarrow_3lib_DataType *, std::shared_ptr< arrow::DataType>  const &);
  struct __pyx_obj_7pyarrow_3lib_Field *(*child)(struct __pyx_obj_7pyarrow_3lib_DataType *, int);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_DataType *__pyx_vtabptr_7pyarrow_3lib_DataType;


/* "pyarrow/lib.pxd":62
 * 
 * 
 * cdef class ListType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CListType* list_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_ListType {
  struct __pyx_vtabstruct_7pyarrow_3lib_DataType __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_ListType *__pyx_vtabptr_7pyarrow_3lib_ListType;


/* "pyarrow/lib.pxd":67
 * 
 * 
 * cdef class LargeListType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CLargeListType* list_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_LargeListType {
  struct __pyx_vtabstruct_7pyarrow_3lib_DataType __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_LargeListType *__pyx_vtabptr_7pyarrow_3lib_LargeListType;


/* "pyarrow/lib.pxd":72
 * 
 * 
 * cdef class MapType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CMapType* map_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_MapType {
  struct __pyx_vtabstruct_7pyarrow_3lib_DataType __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_MapType *__pyx_vtabptr_7pyarrow_3lib_MapType;


/* "pyarrow/lib.pxd":77
 * 
 * 
 * cdef class FixedSizeListType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CFixedSizeListType* list_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeListType {
  struct __pyx_vtabstruct_7pyarrow_3lib_DataType __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeListType *__pyx_vtabptr_7pyarrow_3lib_FixedSizeListType;


/* "pyarrow/lib.pxd":82
 * 
 * 
 * cdef class StructType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CStructType* struct_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_StructType {
  struct __pyx_vtabstruct_7pyarrow_3lib_DataType __pyx_base;
  struct __pyx_obj_7pyarrow_3lib_Field *(*field)(struct __pyx_obj_7pyarrow_3lib_StructType *, int);
  struct __pyx_obj_7pyarrow_3lib_Field *(*field_by_name)(struct __pyx_obj_7pyarrow_3lib_StructType *, PyObject *);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_StructType *__pyx_vtabptr_7pyarrow_3lib_StructType;


/* "pyarrow/lib.pxd":98
 * 
 * 
 * cdef class DictionaryType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CDictionaryType* dict_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_DictionaryType {
  struct __pyx_vtabstruct_7pyarrow_3lib_DataType __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_DictionaryType *__pyx_vtabptr_7pyarrow_3lib_DictionaryType;


/* "pyarrow/lib.pxd":103
 * 
 * 
 * cdef class TimestampType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CTimestampType* ts_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_TimestampType {
  struct __pyx_vtabstruct_7pyarrow_3lib_DataType __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_TimestampType *__pyx_vtabptr_7pyarrow_3lib_TimestampType;


/* "pyarrow/lib.pxd":108
 * 
 * 
 * cdef class Time32Type(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CTime32Type* time_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_Time32Type {
  struct __pyx_vtabstruct_7pyarrow_3lib_DataType __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_Time32Type *__pyx_vtabptr_7pyarrow_3lib_Time32Type;


/* "pyarrow/lib.pxd":113
 * 
 * 
 * cdef class Time64Type(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CTime64Type* time_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_Time64Type {
  struct __pyx_vtabstruct_7pyarrow_3lib_DataType __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_Time64Type *__pyx_vtabptr_7pyarrow_3lib_Time64Type;


/* "pyarrow/lib.pxd":118
 * 
 * 
 * cdef class DurationType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CDurationType* duration_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_DurationType {
  struct __pyx_vtabstruct_7pyarrow_3lib_DataType __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_DurationType *__pyx_vtabptr_7pyarrow_3lib_DurationType;


/* "pyarrow/lib.pxd":123
 * 
 * 
 * cdef class FixedSizeBinaryType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CFixedSizeBinaryType* fixed_size_binary_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeBinaryType {
  struct __pyx_vtabstruct_7pyarrow_3lib_DataType __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeBinaryType *__pyx_vtabptr_7pyarrow_3lib_FixedSizeBinaryType;


/* "pyarrow/lib.pxd":128
 * 
 * 
 * cdef class Decimal128Type(FixedSizeBinaryType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CDecimal128Type* decimal128_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_Decimal128Type {
  struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeBinaryType __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_Decimal128Type *__pyx_vtabptr_7pyarrow_3lib_Decimal128Type;


/* "pyarrow/lib.pxd":133
 * 
 * 
 * cdef class BaseExtensionType(DataType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CExtensionType* ext_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_BaseExtensionType {
  struct __pyx_vtabstruct_7pyarrow_3lib_DataType __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_BaseExtensionType *__pyx_vtabptr_7pyarrow_3lib_BaseExtensionType;


/* "pyarrow/lib.pxd":138
 * 
 * 
 * cdef class ExtensionType(BaseExtensionType):             # <<<<<<<<<<<<<<
 *     cdef:
 *         const CPyExtensionType* cpy_ext_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_ExtensionType {
  struct __pyx_vtabstruct_7pyarrow_3lib_BaseExtensionType __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_ExtensionType *__pyx_vtabptr_7pyarrow_3lib_ExtensionType;


/* "pyarrow/lib.pxd":143
 * 
 * 
 * cdef class PyExtensionType(ExtensionType):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_PyExtensionType {
  struct __pyx_vtabstruct_7pyarrow_3lib_ExtensionType __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_PyExtensionType *__pyx_vtabptr_7pyarrow_3lib_PyExtensionType;


/* "pyarrow/lib.pxd":147
 * 
 * 
 * cdef class Field:             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CField] sp_field
 */

struct __pyx_vtabstruct_7pyarrow_3lib_Field {
  void (*init)(struct __pyx_obj_7pyarrow_3lib_Field *, std::shared_ptr< arrow::Field>  const &);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_Field *__pyx_vtabptr_7pyarrow_3lib_Field;


/* "pyarrow/lib.pxd":158
 * 
 * 
 * cdef class Schema:             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CSchema] sp_schema
 */

struct __pyx_vtabstruct_7pyarrow_3lib_Schema {
  void (*init)(struct __pyx_obj_7pyarrow_3lib_Schema *, std::vector<std::shared_ptr< arrow::Field> >  const &);
  void (*init_schema)(struct __pyx_obj_7pyarrow_3lib_Schema *, std::shared_ptr< arrow::Schema>  const &);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_Schema *__pyx_vtabptr_7pyarrow_3lib_Schema;


/* "pyarrow/lib.pxd":176
 * 
 * 
 * cdef class ArrayValue(Scalar):             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CArray] sp_array
 */

struct __pyx_vtabstruct_7pyarrow_3lib_ArrayValue {
  void (*init)(struct __pyx_obj_7pyarrow_3lib_ArrayValue *, struct __pyx_obj_7pyarrow_3lib_DataType *, std::shared_ptr< arrow::Array>  const &, int64_t);
  void (*_set_array)(struct __pyx_obj_7pyarrow_3lib_ArrayValue *, std::shared_ptr< arrow::Array>  const &);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_ArrayValue *__pyx_vtabptr_7pyarrow_3lib_ArrayValue;


/* "pyarrow/lib.pxd":186
 *     cdef void _set_array(self, const shared_ptr[CArray]& sp_array)
 * 
 * cdef class ScalarValue(Scalar):             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CScalar] sp_scalar
 */

struct __pyx_vtabstruct_7pyarrow_3lib_ScalarValue {
  void (*init)(struct __pyx_obj_7pyarrow_3lib_ScalarValue *, std::shared_ptr< arrow::Scalar>  const &);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_ScalarValue *__pyx_vtabptr_7pyarrow_3lib_ScalarValue;


/* "pyarrow/lib.pxd":192
 *     cdef void init(self, const shared_ptr[CScalar]& sp_scalar)
 * 
 * cdef class Int8Value(ArrayValue):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_Int8Value {
  struct __pyx_vtabstruct_7pyarrow_3lib_ArrayValue __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_Int8Value *__pyx_vtabptr_7pyarrow_3lib_Int8Value;


/* "pyarrow/lib.pxd":196
 * 
 * 
 * cdef class Int64Value(ArrayValue):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_Int64Value {
  struct __pyx_vtabstruct_7pyarrow_3lib_ArrayValue __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_Int64Value *__pyx_vtabptr_7pyarrow_3lib_Int64Value;


/* "pyarrow/lib.pxd":200
 * 
 * 
 * cdef class ListValue(ArrayValue):             # <<<<<<<<<<<<<<
 *     cdef readonly:
 *         DataType value_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_ListValue {
  struct __pyx_vtabstruct_7pyarrow_3lib_ArrayValue __pyx_base;
  PyObject *(*getitem)(struct __pyx_obj_7pyarrow_3lib_ListValue *, int64_t);
  int64_t (*length)(struct __pyx_obj_7pyarrow_3lib_ListValue *);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_ListValue *__pyx_vtabptr_7pyarrow_3lib_ListValue;


/* "pyarrow/lib.pxd":211
 * 
 * 
 * cdef class LargeListValue(ArrayValue):             # <<<<<<<<<<<<<<
 *     cdef readonly:
 *         DataType value_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_LargeListValue {
  struct __pyx_vtabstruct_7pyarrow_3lib_ArrayValue __pyx_base;
  PyObject *(*getitem)(struct __pyx_obj_7pyarrow_3lib_LargeListValue *, int64_t);
  int64_t (*length)(struct __pyx_obj_7pyarrow_3lib_LargeListValue *);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_LargeListValue *__pyx_vtabptr_7pyarrow_3lib_LargeListValue;


/* "pyarrow/lib.pxd":222
 * 
 * 
 * cdef class MapValue(ArrayValue):             # <<<<<<<<<<<<<<
 *     cdef readonly:
 *         DataType key_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_MapValue {
  struct __pyx_vtabstruct_7pyarrow_3lib_ArrayValue __pyx_base;
  PyObject *(*getitem)(struct __pyx_obj_7pyarrow_3lib_MapValue *, int64_t);
  int64_t (*length)(struct __pyx_obj_7pyarrow_3lib_MapValue *);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_MapValue *__pyx_vtabptr_7pyarrow_3lib_MapValue;


/* "pyarrow/lib.pxd":234
 * 
 * 
 * cdef class FixedSizeListValue(ArrayValue):             # <<<<<<<<<<<<<<
 *     cdef readonly:
 *         DataType value_type
 */

struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeListValue {
  struct __pyx_vtabstruct_7pyarrow_3lib_ArrayValue __pyx_base;
  PyObject *(*getitem)(struct __pyx_obj_7pyarrow_3lib_FixedSizeListValue *, int64_t);
  int64_t (*length)(struct __pyx_obj_7pyarrow_3lib_FixedSizeListValue *);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeListValue *__pyx_vtabptr_7pyarrow_3lib_FixedSizeListValue;


/* "pyarrow/lib.pxd":245
 * 
 * 
 * cdef class StructValue(ArrayValue):             # <<<<<<<<<<<<<<
 *     cdef:
 *         CStructArray* ap
 */

struct __pyx_vtabstruct_7pyarrow_3lib_StructValue {
  struct __pyx_vtabstruct_7pyarrow_3lib_ArrayValue __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_StructValue *__pyx_vtabptr_7pyarrow_3lib_StructValue;


/* "pyarrow/lib.pxd":250
 * 
 * 
 * cdef class UnionValue(ArrayValue):             # <<<<<<<<<<<<<<
 *     cdef:
 *         CUnionArray* ap
 */

struct __pyx_vtabstruct_7pyarrow_3lib_UnionValue {
  struct __pyx_vtabstruct_7pyarrow_3lib_ArrayValue __pyx_base;
  PyObject *(*getitem)(struct __pyx_obj_7pyarrow_3lib_UnionValue *, int64_t);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_UnionValue *__pyx_vtabptr_7pyarrow_3lib_UnionValue;


/* "pyarrow/lib.pxd":258
 * 
 * 
 * cdef class StringValue(ArrayValue):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_StringValue {
  struct __pyx_vtabstruct_7pyarrow_3lib_ArrayValue __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_StringValue *__pyx_vtabptr_7pyarrow_3lib_StringValue;


/* "pyarrow/lib.pxd":262
 * 
 * 
 * cdef class FixedSizeBinaryValue(ArrayValue):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeBinaryValue {
  struct __pyx_vtabstruct_7pyarrow_3lib_ArrayValue __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeBinaryValue *__pyx_vtabptr_7pyarrow_3lib_FixedSizeBinaryValue;


/* "pyarrow/lib.pxd":270
 * 
 * 
 * cdef class Array(_PandasConvertible):             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CArray] sp_array
 */

struct __pyx_vtabstruct_7pyarrow_3lib_Array {
  void (*init)(struct __pyx_obj_7pyarrow_3lib_Array *, std::shared_ptr< arrow::Array>  const &);
  PyObject *(*getitem)(struct __pyx_obj_7pyarrow_3lib_Array *, int64_t);
  int64_t (*length)(struct __pyx_obj_7pyarrow_3lib_Array *);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_Array *__pyx_vtabptr_7pyarrow_3lib_Array;


/* "pyarrow/lib.pxd":286
 * 
 * 
 * cdef class Tensor:             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CTensor] sp_tensor
 */

struct __pyx_vtabstruct_7pyarrow_3lib_Tensor {
  void (*init)(struct __pyx_obj_7pyarrow_3lib_Tensor *, std::shared_ptr< arrow::Tensor>  const &);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_Tensor *__pyx_vtabptr_7pyarrow_3lib_Tensor;


/* "pyarrow/lib.pxd":297
 * 
 * 
 * cdef class SparseCSRMatrix:             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CSparseCSRMatrix] sp_sparse_tensor
 */

struct __pyx_vtabstruct_7pyarrow_3lib_SparseCSRMatrix {
  void (*init)(struct __pyx_obj_7pyarrow_3lib_SparseCSRMatrix *, std::shared_ptr< arrow::SparseCSRMatrix>  const &);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_SparseCSRMatrix *__pyx_vtabptr_7pyarrow_3lib_SparseCSRMatrix;


/* "pyarrow/lib.pxd":308
 * 
 * 
 * cdef class SparseCOOTensor:             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CSparseCOOTensor] sp_sparse_tensor
 */

struct __pyx_vtabstruct_7pyarrow_3lib_SparseCOOTensor {
  void (*init)(struct __pyx_obj_7pyarrow_3lib_SparseCOOTensor *, std::shared_ptr< arrow::SparseCOOTensor>  const &);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_SparseCOOTensor *__pyx_vtabptr_7pyarrow_3lib_SparseCOOTensor;


/* "pyarrow/lib.pxd":319
 * 
 * 
 * cdef class NullArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_NullArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_Array __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_NullArray *__pyx_vtabptr_7pyarrow_3lib_NullArray;


/* "pyarrow/lib.pxd":323
 * 
 * 
 * cdef class BooleanArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_BooleanArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_Array __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_BooleanArray *__pyx_vtabptr_7pyarrow_3lib_BooleanArray;


/* "pyarrow/lib.pxd":327
 * 
 * 
 * cdef class NumericArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_NumericArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_Array __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_NumericArray *__pyx_vtabptr_7pyarrow_3lib_NumericArray;


/* "pyarrow/lib.pxd":331
 * 
 * 
 * cdef class IntegerArray(NumericArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_IntegerArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_NumericArray __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_IntegerArray *__pyx_vtabptr_7pyarrow_3lib_IntegerArray;


/* "pyarrow/lib.pxd":335
 * 
 * 
 * cdef class FloatingPointArray(NumericArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_FloatingPointArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_NumericArray __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_FloatingPointArray *__pyx_vtabptr_7pyarrow_3lib_FloatingPointArray;


/* "pyarrow/lib.pxd":339
 * 
 * 
 * cdef class Int8Array(IntegerArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_Int8Array {
  struct __pyx_vtabstruct_7pyarrow_3lib_IntegerArray __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_Int8Array *__pyx_vtabptr_7pyarrow_3lib_Int8Array;


/* "pyarrow/lib.pxd":343
 * 
 * 
 * cdef class UInt8Array(IntegerArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_UInt8Array {
  struct __pyx_vtabstruct_7pyarrow_3lib_IntegerArray __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_UInt8Array *__pyx_vtabptr_7pyarrow_3lib_UInt8Array;


/* "pyarrow/lib.pxd":347
 * 
 * 
 * cdef class Int16Array(IntegerArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_Int16Array {
  struct __pyx_vtabstruct_7pyarrow_3lib_IntegerArray __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_Int16Array *__pyx_vtabptr_7pyarrow_3lib_Int16Array;


/* "pyarrow/lib.pxd":351
 * 
 * 
 * cdef class UInt16Array(IntegerArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_UInt16Array {
  struct __pyx_vtabstruct_7pyarrow_3lib_IntegerArray __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_UInt16Array *__pyx_vtabptr_7pyarrow_3lib_UInt16Array;


/* "pyarrow/lib.pxd":355
 * 
 * 
 * cdef class Int32Array(IntegerArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_Int32Array {
  struct __pyx_vtabstruct_7pyarrow_3lib_IntegerArray __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_Int32Array *__pyx_vtabptr_7pyarrow_3lib_Int32Array;


/* "pyarrow/lib.pxd":359
 * 
 * 
 * cdef class UInt32Array(IntegerArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_UInt32Array {
  struct __pyx_vtabstruct_7pyarrow_3lib_IntegerArray __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_UInt32Array *__pyx_vtabptr_7pyarrow_3lib_UInt32Array;


/* "pyarrow/lib.pxd":363
 * 
 * 
 * cdef class Int64Array(IntegerArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_Int64Array {
  struct __pyx_vtabstruct_7pyarrow_3lib_IntegerArray __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_Int64Array *__pyx_vtabptr_7pyarrow_3lib_Int64Array;


/* "pyarrow/lib.pxd":367
 * 
 * 
 * cdef class UInt64Array(IntegerArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_UInt64Array {
  struct __pyx_vtabstruct_7pyarrow_3lib_IntegerArray __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_UInt64Array *__pyx_vtabptr_7pyarrow_3lib_UInt64Array;


/* "pyarrow/lib.pxd":371
 * 
 * 
 * cdef class HalfFloatArray(FloatingPointArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_HalfFloatArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_FloatingPointArray __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_HalfFloatArray *__pyx_vtabptr_7pyarrow_3lib_HalfFloatArray;


/* "pyarrow/lib.pxd":375
 * 
 * 
 * cdef class FloatArray(FloatingPointArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_FloatArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_FloatingPointArray __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_FloatArray *__pyx_vtabptr_7pyarrow_3lib_FloatArray;


/* "pyarrow/lib.pxd":379
 * 
 * 
 * cdef class DoubleArray(FloatingPointArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_DoubleArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_FloatingPointArray __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_DoubleArray *__pyx_vtabptr_7pyarrow_3lib_DoubleArray;


/* "pyarrow/lib.pxd":383
 * 
 * 
 * cdef class FixedSizeBinaryArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeBinaryArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_Array __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeBinaryArray *__pyx_vtabptr_7pyarrow_3lib_FixedSizeBinaryArray;


/* "pyarrow/lib.pxd":387
 * 
 * 
 * cdef class Decimal128Array(FixedSizeBinaryArray):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_Decimal128Array {
  struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeBinaryArray __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_Decimal128Array *__pyx_vtabptr_7pyarrow_3lib_Decimal128Array;


/* "pyarrow/lib.pxd":391
 * 
 * 
 * cdef class StructArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_StructArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_Array __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_StructArray *__pyx_vtabptr_7pyarrow_3lib_StructArray;


/* "pyarrow/lib.pxd":395
 * 
 * 
 * cdef class ListArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_ListArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_Array __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_ListArray *__pyx_vtabptr_7pyarrow_3lib_ListArray;


/* "pyarrow/lib.pxd":399
 * 
 * 
 * cdef class LargeListArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_LargeListArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_Array __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_LargeListArray *__pyx_vtabptr_7pyarrow_3lib_LargeListArray;


/* "pyarrow/lib.pxd":403
 * 
 * 
 * cdef class MapArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_MapArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_Array __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_MapArray *__pyx_vtabptr_7pyarrow_3lib_MapArray;


/* "pyarrow/lib.pxd":407
 * 
 * 
 * cdef class FixedSizeListArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeListArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_Array __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeListArray *__pyx_vtabptr_7pyarrow_3lib_FixedSizeListArray;


/* "pyarrow/lib.pxd":411
 * 
 * 
 * cdef class UnionArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_UnionArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_Array __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_UnionArray *__pyx_vtabptr_7pyarrow_3lib_UnionArray;


/* "pyarrow/lib.pxd":415
 * 
 * 
 * cdef class StringArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_StringArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_Array __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_StringArray *__pyx_vtabptr_7pyarrow_3lib_StringArray;


/* "pyarrow/lib.pxd":419
 * 
 * 
 * cdef class BinaryArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_BinaryArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_Array __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_BinaryArray *__pyx_vtabptr_7pyarrow_3lib_BinaryArray;


/* "pyarrow/lib.pxd":423
 * 
 * 
 * cdef class DictionaryArray(Array):             # <<<<<<<<<<<<<<
 *     cdef:
 *         object _indices, _dictionary
 */

struct __pyx_vtabstruct_7pyarrow_3lib_DictionaryArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_Array __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_DictionaryArray *__pyx_vtabptr_7pyarrow_3lib_DictionaryArray;


/* "pyarrow/lib.pxd":428
 * 
 * 
 * cdef class ExtensionArray(Array):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_ExtensionArray {
  struct __pyx_vtabstruct_7pyarrow_3lib_Array __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_ExtensionArray *__pyx_vtabptr_7pyarrow_3lib_ExtensionArray;


/* "pyarrow/lib.pxd":439
 * 
 * 
 * cdef class ChunkedArray(_PandasConvertible):             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CChunkedArray] sp_chunked_array
 */

struct __pyx_vtabstruct_7pyarrow_3lib_ChunkedArray {
  void (*init)(struct __pyx_obj_7pyarrow_3lib_ChunkedArray *, std::shared_ptr< arrow::ChunkedArray>  const &);
  PyObject *(*getitem)(struct __pyx_obj_7pyarrow_3lib_ChunkedArray *, int64_t);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_ChunkedArray *__pyx_vtabptr_7pyarrow_3lib_ChunkedArray;


/* "pyarrow/lib.pxd":452
 * 
 * 
 * cdef class Table(_PandasConvertible):             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CTable] sp_table
 */

struct __pyx_vtabstruct_7pyarrow_3lib_Table {
  void (*init)(struct __pyx_obj_7pyarrow_3lib_Table *, std::shared_ptr< arrow::Table>  const &);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_Table *__pyx_vtabptr_7pyarrow_3lib_Table;


/* "pyarrow/lib.pxd":460
 * 
 * 
 * cdef class RecordBatch(_PandasConvertible):             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CRecordBatch] sp_batch
 */

struct __pyx_vtabstruct_7pyarrow_3lib_RecordBatch {
  void (*init)(struct __pyx_obj_7pyarrow_3lib_RecordBatch *, std::shared_ptr< arrow::RecordBatch>  const &);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_RecordBatch *__pyx_vtabptr_7pyarrow_3lib_RecordBatch;


/* "pyarrow/lib.pxd":469
 * 
 * 
 * cdef class Buffer:             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CBuffer] buffer
 */

struct __pyx_vtabstruct_7pyarrow_3lib_Buffer {
  void (*init)(struct __pyx_obj_7pyarrow_3lib_Buffer *, std::shared_ptr< arrow::Buffer>  const &);
  PyObject *(*getitem)(struct __pyx_obj_7pyarrow_3lib_Buffer *, int64_t);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_Buffer *__pyx_vtabptr_7pyarrow_3lib_Buffer;


/* "pyarrow/lib.pxd":479
 * 
 * 
 * cdef class ResizableBuffer(Buffer):             # <<<<<<<<<<<<<<
 * 
 *     cdef void init_rz(self, const shared_ptr[CResizableBuffer]& buffer)
 */

struct __pyx_vtabstruct_7pyarrow_3lib_ResizableBuffer {
  struct __pyx_vtabstruct_7pyarrow_3lib_Buffer __pyx_base;
  void (*init_rz)(struct __pyx_obj_7pyarrow_3lib_ResizableBuffer *, std::shared_ptr< arrow::ResizableBuffer>  const &);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_ResizableBuffer *__pyx_vtabptr_7pyarrow_3lib_ResizableBuffer;


/* "pyarrow/lib.pxd":484
 * 
 * 
 * cdef class NativeFile:             # <<<<<<<<<<<<<<
 *     cdef:
 *         shared_ptr[CInputStream] input_stream
 */

struct __pyx_vtabstruct_7pyarrow_3lib_NativeFile {
  PyObject *(*set_random_access_file)(struct __pyx_obj_7pyarrow_3lib_NativeFile *, std::shared_ptr< arrow::io::RandomAccessFile> );
  PyObject *(*set_input_stream)(struct __pyx_obj_7pyarrow_3lib_NativeFile *, std::shared_ptr< arrow::io::InputStream> );
  PyObject *(*set_output_stream)(struct __pyx_obj_7pyarrow_3lib_NativeFile *, std::shared_ptr< arrow::io::OutputStream> );
  std::shared_ptr< arrow::io::RandomAccessFile>  (*get_random_access_file)(struct __pyx_obj_7pyarrow_3lib_NativeFile *);
  std::shared_ptr< arrow::io::InputStream>  (*get_input_stream)(struct __pyx_obj_7pyarrow_3lib_NativeFile *);
  std::shared_ptr< arrow::io::OutputStream>  (*get_output_stream)(struct __pyx_obj_7pyarrow_3lib_NativeFile *);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_NativeFile *__pyx_vtabptr_7pyarrow_3lib_NativeFile;


/* "pyarrow/lib.pxd":508
 * 
 * 
 * cdef class BufferedInputStream(NativeFile):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_BufferedInputStream {
  struct __pyx_vtabstruct_7pyarrow_3lib_NativeFile __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_BufferedInputStream *__pyx_vtabptr_7pyarrow_3lib_BufferedInputStream;


/* "pyarrow/lib.pxd":512
 * 
 * 
 * cdef class BufferedOutputStream(NativeFile):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_BufferedOutputStream {
  struct __pyx_vtabstruct_7pyarrow_3lib_NativeFile __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_BufferedOutputStream *__pyx_vtabptr_7pyarrow_3lib_BufferedOutputStream;


/* "pyarrow/lib.pxd":516
 * 
 * 
 * cdef class CompressedInputStream(NativeFile):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_CompressedInputStream {
  struct __pyx_vtabstruct_7pyarrow_3lib_NativeFile __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_CompressedInputStream *__pyx_vtabptr_7pyarrow_3lib_CompressedInputStream;


/* "pyarrow/lib.pxd":520
 * 
 * 
 * cdef class CompressedOutputStream(NativeFile):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_7pyarrow_3lib_CompressedOutputStream {
  struct __pyx_vtabstruct_7pyarrow_3lib_NativeFile __pyx_base;
};
static struct __pyx_vtabstruct_7pyarrow_3lib_CompressedOutputStream *__pyx_vtabptr_7pyarrow_3lib_CompressedOutputStream;


/* "pyarrow/lib.pxd":534
 * 
 * 
 * cdef class CastOptions:             # <<<<<<<<<<<<<<
 *     cdef:
 *         CCastOptions options
 */

struct __pyx_vtabstruct_7pyarrow_3lib_CastOptions {
  PyObject *(*wrap)( arrow::compute::CastOptions);
   arrow::compute::CastOptions (*unwrap)(struct __pyx_obj_7pyarrow_3lib_CastOptions *);
};
static struct __pyx_vtabstruct_7pyarrow_3lib_CastOptions *__pyx_vtabptr_7pyarrow_3lib_CastOptions;

/* --- Runtime support code (head) --- */
/* Refnanny.proto */
#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif
#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
#ifdef WITH_THREAD
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          if (acquire_gil) {\
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
              PyGILState_Release(__pyx_gilstate_save);\
          } else {\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
          }
#else
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
#endif
  #define __Pyx_RefNannyFinishContext()\
          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
#else
  #define __Pyx_RefNannyDeclarations
  #define __Pyx_RefNannySetupContext(name, acquire_gil)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XINCREF(r) Py_XINCREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
  #define __Pyx_XGOTREF(r)
  #define __Pyx_XGIVEREF(r)
#endif
#define __Pyx_XDECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_XDECREF(tmp);\
    } while (0)
#define __Pyx_DECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_DECREF(tmp);\
    } while (0)
#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)

/* PyObjectGetAttrStr.proto */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name);
#else
#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
#endif

/* GetBuiltinName.proto */
static PyObject *__Pyx_GetBuiltinName(PyObject *name);

/* UnicodeAsUCS4.proto */
static CYTHON_INLINE Py_UCS4 __Pyx_PyUnicode_AsPy_UCS4(PyObject*);

/* object_ord.proto */
#if PY_MAJOR_VERSION >= 3
#define __Pyx_PyObject_Ord(c)\
    (likely(PyUnicode_Check(c)) ? (long)__Pyx_PyUnicode_AsPy_UCS4(c) : __Pyx__PyObject_Ord(c))
#else
#define __Pyx_PyObject_Ord(c) __Pyx__PyObject_Ord(c)
#endif
static long __Pyx__PyObject_Ord(PyObject* c);

/* PyObjectCall.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
#else
#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
#endif

/* PyThreadStateGet.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
#define __Pyx_PyThreadState_assign  __pyx_tstate = __Pyx_PyThreadState_Current;
#define __Pyx_PyErr_Occurred()  __pyx_tstate->curexc_type
#else
#define __Pyx_PyThreadState_declare
#define __Pyx_PyThreadState_assign
#define __Pyx_PyErr_Occurred()  PyErr_Occurred()
#endif

/* PyErrFetchRestore.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyErr_Clear() __Pyx_ErrRestore(NULL, NULL, NULL)
#define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_PyErr_SetNone(exc) (Py_INCREF(exc), __Pyx_ErrRestore((exc), NULL, NULL))
#else
#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
#endif
#else
#define __Pyx_PyErr_Clear() PyErr_Clear()
#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
#define __Pyx_ErrRestoreWithState(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
#define __Pyx_ErrRestoreInState(tstate, type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetchInState(tstate, type, value, tb)  PyErr_Fetch(type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
#endif

/* RaiseException.proto */
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);

/* RaiseDoubleKeywords.proto */
static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);

/* ParseKeywords.proto */
static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],\
    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,\
    const char* function_name);

/* RaiseArgTupleInvalid.proto */
static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);

/* PyObjectSetAttrStr.proto */
#if CYTHON_USE_TYPE_SLOTS
#define __Pyx_PyObject_DelAttrStr(o,n) __Pyx_PyObject_SetAttrStr(o, n, NULL)
static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value);
#else
#define __Pyx_PyObject_DelAttrStr(o,n)   PyObject_DelAttr(o,n)
#define __Pyx_PyObject_SetAttrStr(o,n,v) PyObject_SetAttr(o,n,v)
#endif

/* ListCompAppend.proto */
#if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
static CYTHON_INLINE int __Pyx_ListComp_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len)) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        Py_SIZE(list) = len+1;
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_ListComp_Append(L,x) PyList_Append(L,x)
#endif

/* PyDictVersioning.proto */
#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
#define __PYX_DICT_VERSION_INIT  ((PY_UINT64_T) -1)
#define __PYX_GET_DICT_VERSION(dict)  (((PyDictObject*)(dict))->ma_version_tag)
#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)\
    (version_var) = __PYX_GET_DICT_VERSION(dict);\
    (cache_var) = (value);
#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP) {\
    static PY_UINT64_T __pyx_dict_version = 0;\
    static PyObject *__pyx_dict_cached_value = NULL;\
    if (likely(__PYX_GET_DICT_VERSION(DICT) == __pyx_dict_version)) {\
        (VAR) = __pyx_dict_cached_value;\
    } else {\
        (VAR) = __pyx_dict_cached_value = (LOOKUP);\
        __pyx_dict_version = __PYX_GET_DICT_VERSION(DICT);\
    }\
}
static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj);
static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj);
static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version);
#else
#define __PYX_GET_DICT_VERSION(dict)  (0)
#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)
#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP)  (VAR) = (LOOKUP);
#endif

/* GetModuleGlobalName.proto */
#if CYTHON_USE_DICT_VERSIONS
#define __Pyx_GetModuleGlobalName(var, name)  {\
    static PY_UINT64_T __pyx_dict_version = 0;\
    static PyObject *__pyx_dict_cached_value = NULL;\
    (var) = (likely(__pyx_dict_version == __PYX_GET_DICT_VERSION(__pyx_d))) ?\
        (likely(__pyx_dict_cached_value) ? __Pyx_NewRef(__pyx_dict_cached_value) : __Pyx_GetBuiltinName(name)) :\
        __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
}
#define __Pyx_GetModuleGlobalNameUncached(var, name)  {\
    PY_UINT64_T __pyx_dict_version;\
    PyObject *__pyx_dict_cached_value;\
    (var) = __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
}
static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value);
#else
#define __Pyx_GetModuleGlobalName(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
#define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
#endif

/* PyCFunctionFastCall.proto */
#if CYTHON_FAST_PYCCALL
static CYTHON_INLINE PyObject *__Pyx_PyCFunction_FastCall(PyObject *func, PyObject **args, Py_ssize_t nargs);
#else
#define __Pyx_PyCFunction_FastCall(func, args, nargs)  (assert(0), NULL)
#endif

/* PyFunctionFastCall.proto */
#if CYTHON_FAST_PYCALL
#define __Pyx_PyFunction_FastCall(func, args, nargs)\
    __Pyx_PyFunction_FastCallDict((func), (args), (nargs), NULL)
#if 1 || PY_VERSION_HEX < 0x030600B1
static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs);
#else
#define __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs) _PyFunction_FastCallDict(func, args, nargs, kwargs)
#endif
#define __Pyx_BUILD_ASSERT_EXPR(cond)\
    (sizeof(char [1 - 2*!(cond)]) - 1)
#ifndef Py_MEMBER_SIZE
#define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)
#endif
  static size_t __pyx_pyframe_localsplus_offset = 0;
  #include "frameobject.h"
  #define __Pxy_PyFrame_Initialize_Offsets()\
    ((void)__Pyx_BUILD_ASSERT_EXPR(sizeof(PyFrameObject) == offsetof(PyFrameObject, f_localsplus) + Py_MEMBER_SIZE(PyFrameObject, f_localsplus)),\
     (void)(__pyx_pyframe_localsplus_offset = ((size_t)PyFrame_Type.tp_basicsize) - Py_MEMBER_SIZE(PyFrameObject, f_localsplus)))
  #define __Pyx_PyFrame_GetLocalsplus(frame)\
    (assert(__pyx_pyframe_localsplus_offset), (PyObject **)(((char *)(frame)) + __pyx_pyframe_localsplus_offset))
#endif

/* PyObjectCall2Args.proto */
static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2);

/* PyObjectCallMethO.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
#endif

/* PyObjectCallOneArg.proto */
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);

/* PyObjectCallNoArg.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
#else
#define __Pyx_PyObject_CallNoArg(func) __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL)
#endif

/* RaiseTooManyValuesToUnpack.proto */
static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);

/* RaiseNeedMoreValuesToUnpack.proto */
static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);

/* IterFinish.proto */
static CYTHON_INLINE int __Pyx_IterFinish(void);

/* UnpackItemEndCheck.proto */
static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected);

/* ArgTypeTest.proto */
#define __Pyx_ArgTypeTest(obj, type, none_allowed, name, exact)\
    ((likely((Py_TYPE(obj) == type) | (none_allowed && (obj == Py_None)))) ? 1 :\
        __Pyx__ArgTypeTest(obj, type, name, exact))
static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact);

/* ExtTypeTest.proto */
static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);

/* PyObject_GenericGetAttrNoDict.proto */
#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name);
#else
#define __Pyx_PyObject_GenericGetAttrNoDict PyObject_GenericGetAttr
#endif

/* PyObject_GenericGetAttr.proto */
#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name);
#else
#define __Pyx_PyObject_GenericGetAttr PyObject_GenericGetAttr
#endif

/* SetupReduce.proto */
static int __Pyx_setup_reduce(PyObject* type_obj);

/* TypeImport.proto */
#ifndef __PYX_HAVE_RT_ImportType_proto
#define __PYX_HAVE_RT_ImportType_proto
enum __Pyx_ImportType_CheckSize {
   __Pyx_ImportType_CheckSize_Error = 0,
   __Pyx_ImportType_CheckSize_Warn = 1,
   __Pyx_ImportType_CheckSize_Ignore = 2
};
static PyTypeObject *__Pyx_ImportType(PyObject* module, const char *module_name, const char *class_name, size_t size, enum __Pyx_ImportType_CheckSize check_size);
#endif

/* GetVTable.proto */
static void* __Pyx_GetVtable(PyObject *dict);

/* Import.proto */
static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);

/* ImportFrom.proto */
static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);

/* CLineInTraceback.proto */
#ifdef CYTHON_CLINE_IN_TRACEBACK
#define __Pyx_CLineForTraceback(tstate, c_line)  (((CYTHON_CLINE_IN_TRACEBACK)) ? c_line : 0)
#else
static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line);
#endif

/* CodeObjectCache.proto */
typedef struct {
    PyCodeObject* code_object;
    int code_line;
} __Pyx_CodeObjectCacheEntry;
struct __Pyx_CodeObjectCache {
    int count;
    int max_count;
    __Pyx_CodeObjectCacheEntry* entries;
};
static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
static PyCodeObject *__pyx_find_code_object(int code_line);
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);

/* AddTraceback.proto */
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename);

/* None.proto */
#include <new>

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int32_t(int32_t value);

/* CppExceptionConversion.proto */
#ifndef __Pyx_CppExn2PyErr
#include <new>
#include <typeinfo>
#include <stdexcept>
#include <ios>
static void __Pyx_CppExn2PyErr() {
  try {
    if (PyErr_Occurred())
      ; // let the latest Python exn pass through and ignore the current one
    else
      throw;
  } catch (const std::bad_alloc& exn) {
    PyErr_SetString(PyExc_MemoryError, exn.what());
  } catch (const std::bad_cast& exn) {
    PyErr_SetString(PyExc_TypeError, exn.what());
  } catch (const std::bad_typeid& exn) {
    PyErr_SetString(PyExc_TypeError, exn.what());
  } catch (const std::domain_error& exn) {
    PyErr_SetString(PyExc_ValueError, exn.what());
  } catch (const std::invalid_argument& exn) {
    PyErr_SetString(PyExc_ValueError, exn.what());
  } catch (const std::ios_base::failure& exn) {
    PyErr_SetString(PyExc_IOError, exn.what());
  } catch (const std::out_of_range& exn) {
    PyErr_SetString(PyExc_IndexError, exn.what());
  } catch (const std::overflow_error& exn) {
    PyErr_SetString(PyExc_OverflowError, exn.what());
  } catch (const std::range_error& exn) {
    PyErr_SetString(PyExc_ArithmeticError, exn.what());
  } catch (const std::underflow_error& exn) {
    PyErr_SetString(PyExc_ArithmeticError, exn.what());
  } catch (const std::exception& exn) {
    PyErr_SetString(PyExc_RuntimeError, exn.what());
  }
  catch (...)
  {
    PyErr_SetString(PyExc_RuntimeError, "Unknown exception");
  }
}
#endif

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_char(unsigned char value);

/* None.proto */
static CYTHON_INLINE int __Pyx_ErrOccurredWithGIL(void); /* proto */

/* CIntFromPy.proto */
static CYTHON_INLINE int32_t __Pyx_PyInt_As_int32_t(PyObject *);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);

/* CIntFromPy.proto */
static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);

/* FastTypeChecks.proto */
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_TypeCheck(obj, type) __Pyx_IsSubtype(Py_TYPE(obj), (PyTypeObject *)type)
static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b);
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject *type);
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *type1, PyObject *type2);
#else
#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
#define __Pyx_PyErr_GivenExceptionMatches(err, type) PyErr_GivenExceptionMatches(err, type)
#define __Pyx_PyErr_GivenExceptionMatches2(err, type1, type2) (PyErr_GivenExceptionMatches(err, type1) || PyErr_GivenExceptionMatches(err, type2))
#endif
#define __Pyx_PyException_Check(obj) __Pyx_TypeCheck(obj, PyExc_Exception)

/* CheckBinaryVersion.proto */
static int __Pyx_check_binary_version(void);

/* FunctionImport.proto */
static int __Pyx_ImportFunction(PyObject *module, const char *funcname, void (**f)(void), const char *sig);

/* InitStrings.proto */
static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);


/* Module declarations from 'libc.stdint' */

/* Module declarations from 'libcpp' */

/* Module declarations from 'libcpp.memory' */

/* Module declarations from 'libc.string' */

/* Module declarations from 'libcpp.string' */

/* Module declarations from 'libcpp.utility' */

/* Module declarations from 'libcpp.vector' */

/* Module declarations from 'libcpp.unordered_map' */

/* Module declarations from 'libcpp.unordered_set' */

/* Module declarations from 'cpython.version' */

/* Module declarations from '__builtin__' */

/* Module declarations from 'cpython.type' */
static PyTypeObject *__pyx_ptype_7cpython_4type_type = 0;

/* Module declarations from 'libc.stdio' */

/* Module declarations from 'cpython.object' */

/* Module declarations from 'cpython.ref' */

/* Module declarations from 'cpython.exc' */

/* Module declarations from 'cpython.module' */

/* Module declarations from 'cpython.mem' */

/* Module declarations from 'cpython.tuple' */

/* Module declarations from 'cpython.list' */

/* Module declarations from 'cpython.sequence' */

/* Module declarations from 'cpython.mapping' */

/* Module declarations from 'cpython.iterator' */

/* Module declarations from 'cpython.number' */

/* Module declarations from 'cpython.int' */

/* Module declarations from '__builtin__' */

/* Module declarations from 'cpython.bool' */
static PyTypeObject *__pyx_ptype_7cpython_4bool_bool = 0;

/* Module declarations from 'cpython.long' */

/* Module declarations from 'cpython.float' */

/* Module declarations from '__builtin__' */

/* Module declarations from 'cpython.complex' */
static PyTypeObject *__pyx_ptype_7cpython_7complex_complex = 0;

/* Module declarations from 'cpython.string' */

/* Module declarations from 'cpython.unicode' */

/* Module declarations from 'cpython.dict' */

/* Module declarations from 'cpython.instance' */

/* Module declarations from 'cpython.function' */

/* Module declarations from 'cpython.method' */

/* Module declarations from 'cpython.weakref' */

/* Module declarations from 'cpython.getargs' */

/* Module declarations from 'cpython.pythread' */

/* Module declarations from 'cpython.pystate' */

/* Module declarations from 'cpython.cobject' */

/* Module declarations from 'cpython.oldbuffer' */

/* Module declarations from 'cpython.set' */

/* Module declarations from 'cpython.buffer' */

/* Module declarations from 'cpython.bytes' */

/* Module declarations from 'cpython.pycapsule' */

/* Module declarations from 'cpython' */

/* Module declarations from 'datetime' */

/* Module declarations from 'cpython.datetime' */
static PyTypeObject *__pyx_ptype_7cpython_8datetime_date = 0;
static PyTypeObject *__pyx_ptype_7cpython_8datetime_time = 0;
static PyTypeObject *__pyx_ptype_7cpython_8datetime_datetime = 0;
static PyTypeObject *__pyx_ptype_7cpython_8datetime_timedelta = 0;
static PyTypeObject *__pyx_ptype_7cpython_8datetime_tzinfo = 0;

/* Module declarations from 'pyarrow.includes.common' */

/* Module declarations from 'pyarrow.includes.libarrow' */

/* Module declarations from 'libcpp.cast' */

/* Module declarations from 'pyarrow.lib' */
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_Message = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_MemoryPool = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_DataType = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_ListType = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_LargeListType = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_MapType = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_FixedSizeListType = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_StructType = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_DictionaryMemo = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_DictionaryType = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_TimestampType = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_Time32Type = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_Time64Type = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_DurationType = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_FixedSizeBinaryType = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_Decimal128Type = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_BaseExtensionType = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_ExtensionType = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_PyExtensionType = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_Field = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_Schema = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_Scalar = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_NAType = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_ArrayValue = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_ScalarValue = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_Int8Value = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_Int64Value = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_ListValue = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_LargeListValue = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_MapValue = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_FixedSizeListValue = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_StructValue = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_UnionValue = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_StringValue = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_FixedSizeBinaryValue = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib__PandasConvertible = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_Array = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_Tensor = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_SparseCSRMatrix = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_SparseCOOTensor = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_NullArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_BooleanArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_NumericArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_IntegerArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_FloatingPointArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_Int8Array = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_UInt8Array = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_Int16Array = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_UInt16Array = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_Int32Array = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_UInt32Array = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_Int64Array = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_UInt64Array = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_HalfFloatArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_FloatArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_DoubleArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_FixedSizeBinaryArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_Decimal128Array = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_StructArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_ListArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_LargeListArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_MapArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_FixedSizeListArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_UnionArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_StringArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_BinaryArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_DictionaryArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_ExtensionArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_ChunkedArray = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_Table = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_RecordBatch = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_Buffer = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_ResizableBuffer = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_NativeFile = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_BufferedInputStream = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_BufferedOutputStream = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_CompressedInputStream = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_CompressedOutputStream = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib__CRecordBatchWriter = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib__CRecordBatchReader = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_3lib_CastOptions = 0;
static int (*__pyx_f_7pyarrow_3lib_check_status)(arrow::Status const &); /*proto*/
static  arrow::MemoryPool *(*__pyx_f_7pyarrow_3lib_maybe_unbox_memory_pool)(struct __pyx_obj_7pyarrow_3lib_MemoryPool *); /*proto*/
static PyObject *(*__pyx_f_7pyarrow_3lib_get_input_stream)(PyObject *, bool, std::shared_ptr< arrow::io::InputStream>  *); /*proto*/
static struct __pyx_obj_7pyarrow_3lib_DataType *(*__pyx_f_7pyarrow_3lib_ensure_type)(PyObject *, struct __pyx_opt_args_7pyarrow_3lib_ensure_type *__pyx_optional_args); /*proto*/
static PyObject *(*__pyx_f_7pyarrow_3lib_pyarrow_wrap_scalar)(std::shared_ptr< arrow::Scalar>  const &); /*proto*/
static PyObject *(*__pyx_f_7pyarrow_3lib_pyarrow_wrap_array)(std::shared_ptr< arrow::Array>  const &); /*proto*/
static PyObject *(*__pyx_f_7pyarrow_3lib_pyarrow_wrap_chunked_array)(std::shared_ptr< arrow::ChunkedArray>  const &); /*proto*/
static PyObject *(*__pyx_f_7pyarrow_3lib_pyarrow_wrap_batch)(std::shared_ptr< arrow::RecordBatch>  const &); /*proto*/
static PyObject *(*__pyx_f_7pyarrow_3lib_pyarrow_wrap_buffer)(std::shared_ptr< arrow::Buffer>  const &); /*proto*/
static PyObject *(*__pyx_f_7pyarrow_3lib_pyarrow_wrap_data_type)(std::shared_ptr< arrow::DataType>  const &); /*proto*/
static PyObject *(*__pyx_f_7pyarrow_3lib_pyarrow_wrap_field)(std::shared_ptr< arrow::Field>  const &); /*proto*/
static PyObject *(*__pyx_f_7pyarrow_3lib_pyarrow_wrap_resizable_buffer)(std::shared_ptr< arrow::ResizableBuffer>  const &); /*proto*/
static PyObject *(*__pyx_f_7pyarrow_3lib_pyarrow_wrap_schema)(std::shared_ptr< arrow::Schema>  const &); /*proto*/
static PyObject *(*__pyx_f_7pyarrow_3lib_pyarrow_wrap_table)(std::shared_ptr< arrow::Table>  const &); /*proto*/
static PyObject *(*__pyx_f_7pyarrow_3lib_pyarrow_wrap_tensor)(std::shared_ptr< arrow::Tensor>  const &); /*proto*/
static PyObject *(*__pyx_f_7pyarrow_3lib_pyarrow_wrap_sparse_coo_tensor)(std::shared_ptr< arrow::SparseCOOTensor>  const &); /*proto*/
static PyObject *(*__pyx_f_7pyarrow_3lib_pyarrow_wrap_sparse_csr_matrix)(std::shared_ptr< arrow::SparseCSRMatrix>  const &); /*proto*/
static std::shared_ptr< arrow::Scalar>  (*__pyx_f_7pyarrow_3lib_pyarrow_unwrap_scalar)(PyObject *); /*proto*/
static std::shared_ptr< arrow::Array>  (*__pyx_f_7pyarrow_3lib_pyarrow_unwrap_array)(PyObject *); /*proto*/
static std::shared_ptr< arrow::RecordBatch>  (*__pyx_f_7pyarrow_3lib_pyarrow_unwrap_batch)(PyObject *); /*proto*/
static std::shared_ptr< arrow::Buffer>  (*__pyx_f_7pyarrow_3lib_pyarrow_unwrap_buffer)(PyObject *); /*proto*/
static std::shared_ptr< arrow::DataType>  (*__pyx_f_7pyarrow_3lib_pyarrow_unwrap_data_type)(PyObject *); /*proto*/
static std::shared_ptr< arrow::Field>  (*__pyx_f_7pyarrow_3lib_pyarrow_unwrap_field)(PyObject *); /*proto*/
static std::shared_ptr< arrow::Schema>  (*__pyx_f_7pyarrow_3lib_pyarrow_unwrap_schema)(PyObject *); /*proto*/
static std::shared_ptr< arrow::Table>  (*__pyx_f_7pyarrow_3lib_pyarrow_unwrap_table)(PyObject *); /*proto*/
static std::shared_ptr< arrow::Tensor>  (*__pyx_f_7pyarrow_3lib_pyarrow_unwrap_tensor)(PyObject *); /*proto*/
static std::shared_ptr< arrow::SparseCOOTensor>  (*__pyx_f_7pyarrow_3lib_pyarrow_unwrap_sparse_coo_tensor)(PyObject *); /*proto*/
static std::shared_ptr< arrow::SparseCSRMatrix>  (*__pyx_f_7pyarrow_3lib_pyarrow_unwrap_sparse_csr_matrix)(PyObject *); /*proto*/

/* Module declarations from 'pyarrow._csv' */
static PyTypeObject *__pyx_ptype_7pyarrow_4_csv_ReadOptions = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_4_csv_ParseOptions = 0;
static PyTypeObject *__pyx_ptype_7pyarrow_4_csv_ConvertOptions = 0;
static unsigned char __pyx_f_7pyarrow_4_csv__single_char(PyObject *); /*proto*/
static PyObject *__pyx_f_7pyarrow_4_csv__get_reader(PyObject *, std::shared_ptr< arrow::io::InputStream>  *); /*proto*/
static PyObject *__pyx_f_7pyarrow_4_csv__get_read_options(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *,  arrow::csv::ReadOptions *); /*proto*/
static PyObject *__pyx_f_7pyarrow_4_csv__get_parse_options(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *,  arrow::csv::ParseOptions *); /*proto*/
static PyObject *__pyx_f_7pyarrow_4_csv__get_convert_options(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *,  arrow::csv::ConvertOptions *); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyObject_string_to_py_std__in_string(std::string const &); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyUnicode_string_to_py_std__in_string(std::string const &); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyStr_string_to_py_std__in_string(std::string const &); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyBytes_string_to_py_std__in_string(std::string const &); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyByteArray_string_to_py_std__in_string(std::string const &); /*proto*/
static std::string __pyx_convert_string_from_py_std__in_string(PyObject *); /*proto*/
static std::vector<std::string>  __pyx_convert_vector_from_py_std_3a__3a_string(PyObject *); /*proto*/
#define __Pyx_MODULE_NAME "pyarrow._csv"
extern int __pyx_module_is_main_pyarrow___csv;
int __pyx_module_is_main_pyarrow___csv = 0;

/* Implementation of 'pyarrow._csv' */
static PyObject *__pyx_builtin_ValueError;
static PyObject *__pyx_builtin_TypeError;
static PyObject *__pyx_builtin_chr;
static const char __pyx_k_chr[] = "chr";
static const char __pyx_k_main[] = "__main__";
static const char __pyx_k_name[] = "name";
static const char __pyx_k_test[] = "__test__";
static const char __pyx_k_type[] = "type";
static const char __pyx_k_items[] = "items";
static const char __pyx_k_slots[] = "__slots__";
static const char __pyx_k_table[] = "table";
static const char __pyx_k_import[] = "__import__";
static const char __pyx_k_name_2[] = "__name__";
static const char __pyx_k_reader[] = "reader";
static const char __pyx_k_reduce[] = "__reduce__";
static const char __pyx_k_stream[] = "stream";
static const char __pyx_k_Mapping[] = "Mapping";
static const char __pyx_k_tobytes[] = "tobytes";
static const char __pyx_k_getstate[] = "__getstate__";
static const char __pyx_k_read_csv[] = "read_csv";
static const char __pyx_k_setstate[] = "__setstate__";
static const char __pyx_k_TypeError[] = "TypeError";
static const char __pyx_k_delimiter[] = "delimiter";
static const char __pyx_k_frombytes[] = "frombytes";
static const char __pyx_k_reduce_ex[] = "__reduce_ex__";
static const char __pyx_k_skip_rows[] = "skip_rows";
static const char __pyx_k_ValueError[] = "ValueError";
static const char __pyx_k_block_size[] = "block_size";
static const char __pyx_k_check_utf8[] = "check_utf8";
static const char __pyx_k_input_file[] = "input_file";
static const char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
static const char __pyx_k_quote_char[] = "quote_char";
static const char __pyx_k_ReadOptions[] = "ReadOptions";
static const char __pyx_k_escape_char[] = "escape_char";
static const char __pyx_k_memory_pool[] = "memory_pool";
static const char __pyx_k_null_values[] = "null_values";
static const char __pyx_k_true_values[] = "true_values";
static const char __pyx_k_use_threads[] = "use_threads";
static const char __pyx_k_ParseOptions[] = "ParseOptions";
static const char __pyx_k_column_names[] = "column_names";
static const char __pyx_k_column_types[] = "column_types";
static const char __pyx_k_double_quote[] = "double_quote";
static const char __pyx_k_false_values[] = "false_values";
static const char __pyx_k_pyarrow__csv[] = "pyarrow._csv";
static const char __pyx_k_read_options[] = "read_options";
static const char __pyx_k_parse_options[] = "parse_options";
static const char __pyx_k_reduce_cython[] = "__reduce_cython__";
static const char __pyx_k_ConvertOptions[] = "ConvertOptions";
static const char __pyx_k_c_read_options[] = "c_read_options";
static const char __pyx_k_pyarrow_compat[] = "pyarrow.compat";
static const char __pyx_k_c_parse_options[] = "c_parse_options";
static const char __pyx_k_convert_options[] = "convert_options";
static const char __pyx_k_include_columns[] = "include_columns";
static const char __pyx_k_setstate_cython[] = "__setstate_cython__";
static const char __pyx_k_auto_dict_encode[] = "auto_dict_encode";
static const char __pyx_k_pyarrow__csv_pyx[] = "pyarrow/_csv.pyx";
static const char __pyx_k_c_convert_options[] = "c_convert_options";
static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
static const char __pyx_k_ignore_empty_lines[] = "ignore_empty_lines";
static const char __pyx_k_newlines_in_values[] = "newlines_in_values";
static const char __pyx_k_strings_can_be_null[] = "strings_can_be_null";
static const char __pyx_k_include_missing_columns[] = "include_missing_columns";
static const char __pyx_k_auto_dict_max_cardinality[] = "auto_dict_max_cardinality";
static const char __pyx_k_autogenerate_column_names[] = "autogenerate_column_names";
static const char __pyx_k_Expecting_an_ASCII_character[] = "Expecting an ASCII character";
static const char __pyx_k_self_options_cannot_be_converted[] = "self.options cannot be converted to a Python object for pickling";
static PyObject *__pyx_n_s_ConvertOptions;
static PyObject *__pyx_kp_u_Expecting_an_ASCII_character;
static PyObject *__pyx_n_s_Mapping;
static PyObject *__pyx_n_s_ParseOptions;
static PyObject *__pyx_n_s_ReadOptions;
static PyObject *__pyx_n_s_TypeError;
static PyObject *__pyx_n_s_ValueError;
static PyObject *__pyx_n_s_auto_dict_encode;
static PyObject *__pyx_n_s_auto_dict_max_cardinality;
static PyObject *__pyx_n_s_autogenerate_column_names;
static PyObject *__pyx_n_s_block_size;
static PyObject *__pyx_n_s_c_convert_options;
static PyObject *__pyx_n_s_c_parse_options;
static PyObject *__pyx_n_s_c_read_options;
static PyObject *__pyx_n_s_check_utf8;
static PyObject *__pyx_n_s_chr;
static PyObject *__pyx_n_s_cline_in_traceback;
static PyObject *__pyx_n_s_column_names;
static PyObject *__pyx_n_s_column_types;
static PyObject *__pyx_n_s_convert_options;
static PyObject *__pyx_n_s_delimiter;
static PyObject *__pyx_n_s_double_quote;
static PyObject *__pyx_n_s_escape_char;
static PyObject *__pyx_n_s_false_values;
static PyObject *__pyx_n_s_frombytes;
static PyObject *__pyx_n_s_getstate;
static PyObject *__pyx_n_s_ignore_empty_lines;
static PyObject *__pyx_n_s_import;
static PyObject *__pyx_n_s_include_columns;
static PyObject *__pyx_n_s_include_missing_columns;
static PyObject *__pyx_n_s_input_file;
static PyObject *__pyx_n_s_items;
static PyObject *__pyx_n_s_main;
static PyObject *__pyx_n_s_memory_pool;
static PyObject *__pyx_n_s_name;
static PyObject *__pyx_n_s_name_2;
static PyObject *__pyx_n_s_newlines_in_values;
static PyObject *__pyx_n_s_null_values;
static PyObject *__pyx_n_s_parse_options;
static PyObject *__pyx_n_s_pyarrow__csv;
static PyObject *__pyx_kp_s_pyarrow__csv_pyx;
static PyObject *__pyx_n_s_pyarrow_compat;
static PyObject *__pyx_n_s_pyx_vtable;
static PyObject *__pyx_n_s_quote_char;
static PyObject *__pyx_n_s_read_csv;
static PyObject *__pyx_n_s_read_options;
static PyObject *__pyx_n_s_reader;
static PyObject *__pyx_n_s_reduce;
static PyObject *__pyx_n_s_reduce_cython;
static PyObject *__pyx_n_s_reduce_ex;
static PyObject *__pyx_kp_s_self_options_cannot_be_converted;
static PyObject *__pyx_n_s_setstate;
static PyObject *__pyx_n_s_setstate_cython;
static PyObject *__pyx_n_s_skip_rows;
static PyObject *__pyx_n_s_slots;
static PyObject *__pyx_n_s_stream;
static PyObject *__pyx_n_s_strings_can_be_null;
static PyObject *__pyx_n_s_table;
static PyObject *__pyx_n_s_test;
static PyObject *__pyx_n_s_tobytes;
static PyObject *__pyx_n_s_true_values;
static PyObject *__pyx_n_s_type;
static PyObject *__pyx_n_s_use_threads;
static int __pyx_pf_7pyarrow_4_csv_11ReadOptions___init__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self, PyObject *__pyx_v_use_threads, PyObject *__pyx_v_block_size, PyObject *__pyx_v_skip_rows, PyObject *__pyx_v_column_names, PyObject *__pyx_v_autogenerate_column_names); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_11ReadOptions_11use_threads___get__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_11ReadOptions_11use_threads_2__set__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_11ReadOptions_10block_size___get__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_11ReadOptions_10block_size_2__set__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_11ReadOptions_9skip_rows___get__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_11ReadOptions_9skip_rows_2__set__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_11ReadOptions_12column_names___get__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_11ReadOptions_12column_names_2__set__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_11ReadOptions_25autogenerate_column_names___get__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_11ReadOptions_25autogenerate_column_names_2__set__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_11ReadOptions_2__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_11ReadOptions_4__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static int __pyx_pf_7pyarrow_4_csv_12ParseOptions___init__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self, PyObject *__pyx_v_delimiter, PyObject *__pyx_v_quote_char, PyObject *__pyx_v_double_quote, PyObject *__pyx_v_escape_char, PyObject *__pyx_v_newlines_in_values, PyObject *__pyx_v_ignore_empty_lines); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_12ParseOptions_9delimiter___get__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_12ParseOptions_9delimiter_2__set__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_12ParseOptions_10quote_char___get__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_12ParseOptions_10quote_char_2__set__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_12ParseOptions_12double_quote___get__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_12ParseOptions_12double_quote_2__set__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_12ParseOptions_11escape_char___get__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_12ParseOptions_11escape_char_2__set__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_12ParseOptions_18newlines_in_values___get__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_12ParseOptions_18newlines_in_values_2__set__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_12ParseOptions_18ignore_empty_lines___get__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_12ParseOptions_18ignore_empty_lines_2__set__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_12ParseOptions_2__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_12ParseOptions_4__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions___init__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_check_utf8, PyObject *__pyx_v_column_types, PyObject *__pyx_v_null_values, PyObject *__pyx_v_true_values, PyObject *__pyx_v_false_values, PyObject *__pyx_v_strings_can_be_null, PyObject *__pyx_v_include_columns, PyObject *__pyx_v_include_missing_columns, PyObject *__pyx_v_auto_dict_encode, PyObject *__pyx_v_auto_dict_max_cardinality); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_10check_utf8___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_10check_utf8_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_19strings_can_be_null___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_19strings_can_be_null_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_12column_types___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_12column_types_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_11null_values___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_11null_values_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_11true_values___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_11true_values_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_12false_values___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_12false_values_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_16auto_dict_encode___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_16auto_dict_encode_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_25auto_dict_max_cardinality___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_25auto_dict_max_cardinality_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_15include_columns___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_15include_columns_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_23include_missing_columns___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self); /* proto */
static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_23include_missing_columns_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_2__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_4__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static PyObject *__pyx_pf_7pyarrow_4_csv_read_csv(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_input_file, PyObject *__pyx_v_read_options, PyObject *__pyx_v_parse_options, PyObject *__pyx_v_convert_options, struct __pyx_obj_7pyarrow_3lib_MemoryPool *__pyx_v_memory_pool); /* proto */
static PyObject *__pyx_tp_new_7pyarrow_4_csv_ReadOptions(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_7pyarrow_4_csv_ParseOptions(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_7pyarrow_4_csv_ConvertOptions(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tuple_;
static PyObject *__pyx_tuple__2;
static PyObject *__pyx_tuple__3;
static PyObject *__pyx_tuple__4;
static PyObject *__pyx_tuple__5;
static PyObject *__pyx_tuple__6;
static PyObject *__pyx_tuple__7;
static PyObject *__pyx_tuple__8;
static PyObject *__pyx_codeobj__9;
/* Late includes */

/* "pyarrow/_csv.pyx":35
 * 
 * 
 * cdef unsigned char _single_char(s) except 0:             # <<<<<<<<<<<<<<
 *     val = ord(s)
 *     if val == 0 or val > 127:
 */

static unsigned char __pyx_f_7pyarrow_4_csv__single_char(PyObject *__pyx_v_s) {
  long __pyx_v_val;
  unsigned char __pyx_r;
  __Pyx_RefNannyDeclarations
  long __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("_single_char", 0);

  /* "pyarrow/_csv.pyx":36
 * 
 * cdef unsigned char _single_char(s) except 0:
 *     val = ord(s)             # <<<<<<<<<<<<<<
 *     if val == 0 or val > 127:
 *         raise ValueError("Expecting an ASCII character")
 */
  __pyx_t_1 = __Pyx_PyObject_Ord(__pyx_v_s); if (unlikely(__pyx_t_1 == ((long)(long)(Py_UCS4)-1))) __PYX_ERR(0, 36, __pyx_L1_error)
  __pyx_v_val = __pyx_t_1;

  /* "pyarrow/_csv.pyx":37
 * cdef unsigned char _single_char(s) except 0:
 *     val = ord(s)
 *     if val == 0 or val > 127:             # <<<<<<<<<<<<<<
 *         raise ValueError("Expecting an ASCII character")
 *     return <unsigned char> val
 */
  __pyx_t_3 = ((__pyx_v_val == 0) != 0);
  if (!__pyx_t_3) {
  } else {
    __pyx_t_2 = __pyx_t_3;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_3 = ((__pyx_v_val > 0x7F) != 0);
  __pyx_t_2 = __pyx_t_3;
  __pyx_L4_bool_binop_done:;
  if (unlikely(__pyx_t_2)) {

    /* "pyarrow/_csv.pyx":38
 *     val = ord(s)
 *     if val == 0 or val > 127:
 *         raise ValueError("Expecting an ASCII character")             # <<<<<<<<<<<<<<
 *     return <unsigned char> val
 * 
 */
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 38, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 38, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":37
 * cdef unsigned char _single_char(s) except 0:
 *     val = ord(s)
 *     if val == 0 or val > 127:             # <<<<<<<<<<<<<<
 *         raise ValueError("Expecting an ASCII character")
 *     return <unsigned char> val
 */
  }

  /* "pyarrow/_csv.pyx":39
 *     if val == 0 or val > 127:
 *         raise ValueError("Expecting an ASCII character")
 *     return <unsigned char> val             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = ((unsigned char)__pyx_v_val);
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":35
 * 
 * 
 * cdef unsigned char _single_char(s) except 0:             # <<<<<<<<<<<<<<
 *     val = ord(s)
 *     if val == 0 or val > 127:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pyarrow._csv._single_char", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":72
 *     __slots__ = ()
 * 
 *     def __init__(self, use_threads=None, block_size=None, skip_rows=None,             # <<<<<<<<<<<<<<
 *                  column_names=None, autogenerate_column_names=None):
 *         self.options = CCSVReadOptions.Defaults()
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_11ReadOptions_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_11ReadOptions_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_use_threads = 0;
  PyObject *__pyx_v_block_size = 0;
  PyObject *__pyx_v_skip_rows = 0;
  PyObject *__pyx_v_column_names = 0;
  PyObject *__pyx_v_autogenerate_column_names = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_use_threads,&__pyx_n_s_block_size,&__pyx_n_s_skip_rows,&__pyx_n_s_column_names,&__pyx_n_s_autogenerate_column_names,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[0] = ((PyObject *)Py_None);
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);

    /* "pyarrow/_csv.pyx":73
 * 
 *     def __init__(self, use_threads=None, block_size=None, skip_rows=None,
 *                  column_names=None, autogenerate_column_names=None):             # <<<<<<<<<<<<<<
 *         self.options = CCSVReadOptions.Defaults()
 *         if use_threads is not None:
 */
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_use_threads);
          if (value) { values[0] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_block_size);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_skip_rows);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_column_names);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_autogenerate_column_names);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 72, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_use_threads = values[0];
    __pyx_v_block_size = values[1];
    __pyx_v_skip_rows = values[2];
    __pyx_v_column_names = values[3];
    __pyx_v_autogenerate_column_names = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 0, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 72, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pyarrow._csv.ReadOptions.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pyarrow_4_csv_11ReadOptions___init__(((struct __pyx_obj_7pyarrow_4_csv_ReadOptions *)__pyx_v_self), __pyx_v_use_threads, __pyx_v_block_size, __pyx_v_skip_rows, __pyx_v_column_names, __pyx_v_autogenerate_column_names);

  /* "pyarrow/_csv.pyx":72
 *     __slots__ = ()
 * 
 *     def __init__(self, use_threads=None, block_size=None, skip_rows=None,             # <<<<<<<<<<<<<<
 *                  column_names=None, autogenerate_column_names=None):
 *         self.options = CCSVReadOptions.Defaults()
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_11ReadOptions___init__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self, PyObject *__pyx_v_use_threads, PyObject *__pyx_v_block_size, PyObject *__pyx_v_skip_rows, PyObject *__pyx_v_column_names, PyObject *__pyx_v_autogenerate_column_names) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "pyarrow/_csv.pyx":74
 *     def __init__(self, use_threads=None, block_size=None, skip_rows=None,
 *                  column_names=None, autogenerate_column_names=None):
 *         self.options = CCSVReadOptions.Defaults()             # <<<<<<<<<<<<<<
 *         if use_threads is not None:
 *             self.use_threads = use_threads
 */
  __pyx_v_self->options =  arrow::csv::ReadOptions::Defaults();

  /* "pyarrow/_csv.pyx":75
 *                  column_names=None, autogenerate_column_names=None):
 *         self.options = CCSVReadOptions.Defaults()
 *         if use_threads is not None:             # <<<<<<<<<<<<<<
 *             self.use_threads = use_threads
 *         if block_size is not None:
 */
  __pyx_t_1 = (__pyx_v_use_threads != Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyarrow/_csv.pyx":76
 *         self.options = CCSVReadOptions.Defaults()
 *         if use_threads is not None:
 *             self.use_threads = use_threads             # <<<<<<<<<<<<<<
 *         if block_size is not None:
 *             self.block_size = block_size
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_use_threads, __pyx_v_use_threads) < 0) __PYX_ERR(0, 76, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":75
 *                  column_names=None, autogenerate_column_names=None):
 *         self.options = CCSVReadOptions.Defaults()
 *         if use_threads is not None:             # <<<<<<<<<<<<<<
 *             self.use_threads = use_threads
 *         if block_size is not None:
 */
  }

  /* "pyarrow/_csv.pyx":77
 *         if use_threads is not None:
 *             self.use_threads = use_threads
 *         if block_size is not None:             # <<<<<<<<<<<<<<
 *             self.block_size = block_size
 *         if skip_rows is not None:
 */
  __pyx_t_2 = (__pyx_v_block_size != Py_None);
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "pyarrow/_csv.pyx":78
 *             self.use_threads = use_threads
 *         if block_size is not None:
 *             self.block_size = block_size             # <<<<<<<<<<<<<<
 *         if skip_rows is not None:
 *             self.skip_rows = skip_rows
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_block_size, __pyx_v_block_size) < 0) __PYX_ERR(0, 78, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":77
 *         if use_threads is not None:
 *             self.use_threads = use_threads
 *         if block_size is not None:             # <<<<<<<<<<<<<<
 *             self.block_size = block_size
 *         if skip_rows is not None:
 */
  }

  /* "pyarrow/_csv.pyx":79
 *         if block_size is not None:
 *             self.block_size = block_size
 *         if skip_rows is not None:             # <<<<<<<<<<<<<<
 *             self.skip_rows = skip_rows
 *         if column_names is not None:
 */
  __pyx_t_1 = (__pyx_v_skip_rows != Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyarrow/_csv.pyx":80
 *             self.block_size = block_size
 *         if skip_rows is not None:
 *             self.skip_rows = skip_rows             # <<<<<<<<<<<<<<
 *         if column_names is not None:
 *             self.column_names = column_names
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_skip_rows, __pyx_v_skip_rows) < 0) __PYX_ERR(0, 80, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":79
 *         if block_size is not None:
 *             self.block_size = block_size
 *         if skip_rows is not None:             # <<<<<<<<<<<<<<
 *             self.skip_rows = skip_rows
 *         if column_names is not None:
 */
  }

  /* "pyarrow/_csv.pyx":81
 *         if skip_rows is not None:
 *             self.skip_rows = skip_rows
 *         if column_names is not None:             # <<<<<<<<<<<<<<
 *             self.column_names = column_names
 *         if autogenerate_column_names is not None:
 */
  __pyx_t_2 = (__pyx_v_column_names != Py_None);
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "pyarrow/_csv.pyx":82
 *             self.skip_rows = skip_rows
 *         if column_names is not None:
 *             self.column_names = column_names             # <<<<<<<<<<<<<<
 *         if autogenerate_column_names is not None:
 *             self.autogenerate_column_names= autogenerate_column_names
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_column_names, __pyx_v_column_names) < 0) __PYX_ERR(0, 82, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":81
 *         if skip_rows is not None:
 *             self.skip_rows = skip_rows
 *         if column_names is not None:             # <<<<<<<<<<<<<<
 *             self.column_names = column_names
 *         if autogenerate_column_names is not None:
 */
  }

  /* "pyarrow/_csv.pyx":83
 *         if column_names is not None:
 *             self.column_names = column_names
 *         if autogenerate_column_names is not None:             # <<<<<<<<<<<<<<
 *             self.autogenerate_column_names= autogenerate_column_names
 * 
 */
  __pyx_t_1 = (__pyx_v_autogenerate_column_names != Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyarrow/_csv.pyx":84
 *             self.column_names = column_names
 *         if autogenerate_column_names is not None:
 *             self.autogenerate_column_names= autogenerate_column_names             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_autogenerate_column_names, __pyx_v_autogenerate_column_names) < 0) __PYX_ERR(0, 84, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":83
 *         if column_names is not None:
 *             self.column_names = column_names
 *         if autogenerate_column_names is not None:             # <<<<<<<<<<<<<<
 *             self.autogenerate_column_names= autogenerate_column_names
 * 
 */
  }

  /* "pyarrow/_csv.pyx":72
 *     __slots__ = ()
 * 
 *     def __init__(self, use_threads=None, block_size=None, skip_rows=None,             # <<<<<<<<<<<<<<
 *                  column_names=None, autogenerate_column_names=None):
 *         self.options = CCSVReadOptions.Defaults()
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyarrow._csv.ReadOptions.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":87
 * 
 *     @property
 *     def use_threads(self):             # <<<<<<<<<<<<<<
 *         """
 *         Whether to use multiple threads to accelerate reading.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_11ReadOptions_11use_threads_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_11ReadOptions_11use_threads_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_11ReadOptions_11use_threads___get__(((struct __pyx_obj_7pyarrow_4_csv_ReadOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_11ReadOptions_11use_threads___get__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":91
 *         Whether to use multiple threads to accelerate reading.
 *         """
 *         return self.options.use_threads             # <<<<<<<<<<<<<<
 * 
 *     @use_threads.setter
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->options.use_threads); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 91, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":87
 * 
 *     @property
 *     def use_threads(self):             # <<<<<<<<<<<<<<
 *         """
 *         Whether to use multiple threads to accelerate reading.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.ReadOptions.use_threads.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":94
 * 
 *     @use_threads.setter
 *     def use_threads(self, value):             # <<<<<<<<<<<<<<
 *         self.options.use_threads = value
 * 
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_11ReadOptions_11use_threads_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_11ReadOptions_11use_threads_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_11ReadOptions_11use_threads_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ReadOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_11ReadOptions_11use_threads_2__set__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  bool __pyx_t_1;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":95
 *     @use_threads.setter
 *     def use_threads(self, value):
 *         self.options.use_threads = value             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_value); if (unlikely((__pyx_t_1 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 95, __pyx_L1_error)
  __pyx_v_self->options.use_threads = __pyx_t_1;

  /* "pyarrow/_csv.pyx":94
 * 
 *     @use_threads.setter
 *     def use_threads(self, value):             # <<<<<<<<<<<<<<
 *         self.options.use_threads = value
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyarrow._csv.ReadOptions.use_threads.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":98
 * 
 *     @property
 *     def block_size(self):             # <<<<<<<<<<<<<<
 *         """
 *         How much bytes to process at a time from the input stream.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_11ReadOptions_10block_size_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_11ReadOptions_10block_size_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_11ReadOptions_10block_size___get__(((struct __pyx_obj_7pyarrow_4_csv_ReadOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_11ReadOptions_10block_size___get__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":104
 *         the size of individual chunks in the Table.
 *         """
 *         return self.options.block_size             # <<<<<<<<<<<<<<
 * 
 *     @block_size.setter
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int32_t(__pyx_v_self->options.block_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 104, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":98
 * 
 *     @property
 *     def block_size(self):             # <<<<<<<<<<<<<<
 *         """
 *         How much bytes to process at a time from the input stream.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.ReadOptions.block_size.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":107
 * 
 *     @block_size.setter
 *     def block_size(self, value):             # <<<<<<<<<<<<<<
 *         self.options.block_size = value
 * 
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_11ReadOptions_10block_size_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_11ReadOptions_10block_size_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_11ReadOptions_10block_size_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ReadOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_11ReadOptions_10block_size_2__set__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int32_t __pyx_t_1;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":108
 *     @block_size.setter
 *     def block_size(self, value):
 *         self.options.block_size = value             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
  __pyx_t_1 = __Pyx_PyInt_As_int32_t(__pyx_v_value); if (unlikely((__pyx_t_1 == ((int32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 108, __pyx_L1_error)
  __pyx_v_self->options.block_size = __pyx_t_1;

  /* "pyarrow/_csv.pyx":107
 * 
 *     @block_size.setter
 *     def block_size(self, value):             # <<<<<<<<<<<<<<
 *         self.options.block_size = value
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyarrow._csv.ReadOptions.block_size.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":111
 * 
 *     @property
 *     def skip_rows(self):             # <<<<<<<<<<<<<<
 *         """
 *         The number of rows to skip at the start of the CSV data, not
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_11ReadOptions_9skip_rows_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_11ReadOptions_9skip_rows_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_11ReadOptions_9skip_rows___get__(((struct __pyx_obj_7pyarrow_4_csv_ReadOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_11ReadOptions_9skip_rows___get__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":116
 *         including the row of column names (if any).
 *         """
 *         return self.options.skip_rows             # <<<<<<<<<<<<<<
 * 
 *     @skip_rows.setter
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int32_t(__pyx_v_self->options.skip_rows); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 116, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":111
 * 
 *     @property
 *     def skip_rows(self):             # <<<<<<<<<<<<<<
 *         """
 *         The number of rows to skip at the start of the CSV data, not
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.ReadOptions.skip_rows.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":119
 * 
 *     @skip_rows.setter
 *     def skip_rows(self, value):             # <<<<<<<<<<<<<<
 *         self.options.skip_rows = value
 * 
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_11ReadOptions_9skip_rows_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_11ReadOptions_9skip_rows_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_11ReadOptions_9skip_rows_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ReadOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_11ReadOptions_9skip_rows_2__set__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int32_t __pyx_t_1;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":120
 *     @skip_rows.setter
 *     def skip_rows(self, value):
 *         self.options.skip_rows = value             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
  __pyx_t_1 = __Pyx_PyInt_As_int32_t(__pyx_v_value); if (unlikely((__pyx_t_1 == ((int32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 120, __pyx_L1_error)
  __pyx_v_self->options.skip_rows = __pyx_t_1;

  /* "pyarrow/_csv.pyx":119
 * 
 *     @skip_rows.setter
 *     def skip_rows(self, value):             # <<<<<<<<<<<<<<
 *         self.options.skip_rows = value
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyarrow._csv.ReadOptions.skip_rows.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":123
 * 
 *     @property
 *     def column_names(self):             # <<<<<<<<<<<<<<
 *         """
 *         The column names of the target table.  If empty, fall back on
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_11ReadOptions_12column_names_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_11ReadOptions_12column_names_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_11ReadOptions_12column_names___get__(((struct __pyx_obj_7pyarrow_4_csv_ReadOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_11ReadOptions_12column_names___get__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self) {
  std::string __pyx_7genexpr__pyx_v_s;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::vector<std::string> ::iterator __pyx_t_2;
  std::vector<std::string>  *__pyx_t_3;
  std::string __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":128
 *         `autogenerate_column_names`.
 *         """
 *         return [frombytes(s) for s in self.options.column_names]             # <<<<<<<<<<<<<<
 * 
 *     @column_names.setter
 */
  __Pyx_XDECREF(__pyx_r);
  { /* enter inner scope */
    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 128, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = &__pyx_v_self->options.column_names;
    __pyx_t_2 = __pyx_t_3->begin();
    for (;;) {
      if (!(__pyx_t_2 != __pyx_t_3->end())) break;
      __pyx_t_4 = *__pyx_t_2;
      ++__pyx_t_2;
      __pyx_7genexpr__pyx_v_s = __pyx_t_4;
      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_frombytes); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 128, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_7 = __pyx_convert_PyBytes_string_to_py_std__in_string(__pyx_7genexpr__pyx_v_s); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 128, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_8 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
        __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_6);
        if (likely(__pyx_t_8)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
          __Pyx_INCREF(__pyx_t_8);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_6, function);
        }
      }
      __pyx_t_5 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_8, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_7);
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 128, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(0, 128, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
  } /* exit inner scope */
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":123
 * 
 *     @property
 *     def column_names(self):             # <<<<<<<<<<<<<<
 *         """
 *         The column names of the target table.  If empty, fall back on
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("pyarrow._csv.ReadOptions.column_names.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":131
 * 
 *     @column_names.setter
 *     def column_names(self, value):             # <<<<<<<<<<<<<<
 *         self.options.column_names.clear()
 *         for item in value:
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_11ReadOptions_12column_names_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_11ReadOptions_12column_names_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_11ReadOptions_12column_names_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ReadOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_11ReadOptions_12column_names_2__set__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  PyObject *__pyx_v_item = NULL;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *(*__pyx_t_3)(PyObject *);
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  std::string __pyx_t_7;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":132
 *     @column_names.setter
 *     def column_names(self, value):
 *         self.options.column_names.clear()             # <<<<<<<<<<<<<<
 *         for item in value:
 *             self.options.column_names.push_back(tobytes(item))
 */
  __pyx_v_self->options.column_names.clear();

  /* "pyarrow/_csv.pyx":133
 *     def column_names(self, value):
 *         self.options.column_names.clear()
 *         for item in value:             # <<<<<<<<<<<<<<
 *             self.options.column_names.push_back(tobytes(item))
 * 
 */
  if (likely(PyList_CheckExact(__pyx_v_value)) || PyTuple_CheckExact(__pyx_v_value)) {
    __pyx_t_1 = __pyx_v_value; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
    __pyx_t_3 = NULL;
  } else {
    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 133, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 133, __pyx_L1_error)
  }
  for (;;) {
    if (likely(!__pyx_t_3)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 133, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 133, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 133, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 133, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 133, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "pyarrow/_csv.pyx":134
 *         self.options.column_names.clear()
 *         for item in value:
 *             self.options.column_names.push_back(tobytes(item))             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_tobytes); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 134, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    __pyx_t_4 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_v_item) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_item);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 134, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_7 = __pyx_convert_string_from_py_std__in_string(__pyx_t_4); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 134, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    try {
      __pyx_v_self->options.column_names.push_back(__pyx_t_7);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 134, __pyx_L1_error)
    }

    /* "pyarrow/_csv.pyx":133
 *     def column_names(self, value):
 *         self.options.column_names.clear()
 *         for item in value:             # <<<<<<<<<<<<<<
 *             self.options.column_names.push_back(tobytes(item))
 * 
 */
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyarrow/_csv.pyx":131
 * 
 *     @column_names.setter
 *     def column_names(self, value):             # <<<<<<<<<<<<<<
 *         self.options.column_names.clear()
 *         for item in value:
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("pyarrow._csv.ReadOptions.column_names.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_item);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":137
 * 
 *     @property
 *     def autogenerate_column_names(self):             # <<<<<<<<<<<<<<
 *         """
 *         Whether to autogenerate column names if `column_names` is empty.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_11ReadOptions_25autogenerate_column_names_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_11ReadOptions_25autogenerate_column_names_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_11ReadOptions_25autogenerate_column_names___get__(((struct __pyx_obj_7pyarrow_4_csv_ReadOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_11ReadOptions_25autogenerate_column_names___get__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":144
 *         after `skip_rows`.
 *         """
 *         return self.options.autogenerate_column_names             # <<<<<<<<<<<<<<
 * 
 *     @autogenerate_column_names.setter
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->options.autogenerate_column_names); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 144, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":137
 * 
 *     @property
 *     def autogenerate_column_names(self):             # <<<<<<<<<<<<<<
 *         """
 *         Whether to autogenerate column names if `column_names` is empty.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.ReadOptions.autogenerate_column_names.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":147
 * 
 *     @autogenerate_column_names.setter
 *     def autogenerate_column_names(self, value):             # <<<<<<<<<<<<<<
 *         self.options.autogenerate_column_names = value
 * 
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_11ReadOptions_25autogenerate_column_names_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_11ReadOptions_25autogenerate_column_names_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_11ReadOptions_25autogenerate_column_names_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ReadOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_11ReadOptions_25autogenerate_column_names_2__set__(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  bool __pyx_t_1;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":148
 *     @autogenerate_column_names.setter
 *     def autogenerate_column_names(self, value):
 *         self.options.autogenerate_column_names = value             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_value); if (unlikely((__pyx_t_1 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 148, __pyx_L1_error)
  __pyx_v_self->options.autogenerate_column_names = __pyx_t_1;

  /* "pyarrow/_csv.pyx":147
 * 
 *     @autogenerate_column_names.setter
 *     def autogenerate_column_names(self, value):             # <<<<<<<<<<<<<<
 *         self.options.autogenerate_column_names = value
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyarrow._csv.ReadOptions.autogenerate_column_names.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_11ReadOptions_3__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_7pyarrow_4_csv_11ReadOptions_2__reduce_cython__[] = "ReadOptions.__reduce_cython__(self)";
static PyObject *__pyx_pw_7pyarrow_4_csv_11ReadOptions_3__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_11ReadOptions_2__reduce_cython__(((struct __pyx_obj_7pyarrow_4_csv_ReadOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_11ReadOptions_2__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.ReadOptions.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_11ReadOptions_5__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static char __pyx_doc_7pyarrow_4_csv_11ReadOptions_4__setstate_cython__[] = "ReadOptions.__setstate_cython__(self, __pyx_state)";
static PyObject *__pyx_pw_7pyarrow_4_csv_11ReadOptions_5__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_11ReadOptions_4__setstate_cython__(((struct __pyx_obj_7pyarrow_4_csv_ReadOptions *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_11ReadOptions_4__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.ReadOptions.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":182
 *     __slots__ = ()
 * 
 *     def __init__(self, delimiter=None, quote_char=None, double_quote=None,             # <<<<<<<<<<<<<<
 *                  escape_char=None, newlines_in_values=None,
 *                  ignore_empty_lines=None):
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_12ParseOptions_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_12ParseOptions_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_delimiter = 0;
  PyObject *__pyx_v_quote_char = 0;
  PyObject *__pyx_v_double_quote = 0;
  PyObject *__pyx_v_escape_char = 0;
  PyObject *__pyx_v_newlines_in_values = 0;
  PyObject *__pyx_v_ignore_empty_lines = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_delimiter,&__pyx_n_s_quote_char,&__pyx_n_s_double_quote,&__pyx_n_s_escape_char,&__pyx_n_s_newlines_in_values,&__pyx_n_s_ignore_empty_lines,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    values[0] = ((PyObject *)Py_None);
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);

    /* "pyarrow/_csv.pyx":183
 * 
 *     def __init__(self, delimiter=None, quote_char=None, double_quote=None,
 *                  escape_char=None, newlines_in_values=None,             # <<<<<<<<<<<<<<
 *                  ignore_empty_lines=None):
 *         self.options = CCSVParseOptions.Defaults()
 */
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)Py_None);

    /* "pyarrow/_csv.pyx":184
 *     def __init__(self, delimiter=None, quote_char=None, double_quote=None,
 *                  escape_char=None, newlines_in_values=None,
 *                  ignore_empty_lines=None):             # <<<<<<<<<<<<<<
 *         self.options = CCSVParseOptions.Defaults()
 *         if delimiter is not None:
 */
    values[5] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_delimiter);
          if (value) { values[0] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_quote_char);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_double_quote);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_escape_char);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_newlines_in_values);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ignore_empty_lines);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 182, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_delimiter = values[0];
    __pyx_v_quote_char = values[1];
    __pyx_v_double_quote = values[2];
    __pyx_v_escape_char = values[3];
    __pyx_v_newlines_in_values = values[4];
    __pyx_v_ignore_empty_lines = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 0, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 182, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pyarrow._csv.ParseOptions.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pyarrow_4_csv_12ParseOptions___init__(((struct __pyx_obj_7pyarrow_4_csv_ParseOptions *)__pyx_v_self), __pyx_v_delimiter, __pyx_v_quote_char, __pyx_v_double_quote, __pyx_v_escape_char, __pyx_v_newlines_in_values, __pyx_v_ignore_empty_lines);

  /* "pyarrow/_csv.pyx":182
 *     __slots__ = ()
 * 
 *     def __init__(self, delimiter=None, quote_char=None, double_quote=None,             # <<<<<<<<<<<<<<
 *                  escape_char=None, newlines_in_values=None,
 *                  ignore_empty_lines=None):
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_12ParseOptions___init__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self, PyObject *__pyx_v_delimiter, PyObject *__pyx_v_quote_char, PyObject *__pyx_v_double_quote, PyObject *__pyx_v_escape_char, PyObject *__pyx_v_newlines_in_values, PyObject *__pyx_v_ignore_empty_lines) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "pyarrow/_csv.pyx":185
 *                  escape_char=None, newlines_in_values=None,
 *                  ignore_empty_lines=None):
 *         self.options = CCSVParseOptions.Defaults()             # <<<<<<<<<<<<<<
 *         if delimiter is not None:
 *             self.delimiter = delimiter
 */
  __pyx_v_self->options =  arrow::csv::ParseOptions::Defaults();

  /* "pyarrow/_csv.pyx":186
 *                  ignore_empty_lines=None):
 *         self.options = CCSVParseOptions.Defaults()
 *         if delimiter is not None:             # <<<<<<<<<<<<<<
 *             self.delimiter = delimiter
 *         if quote_char is not None:
 */
  __pyx_t_1 = (__pyx_v_delimiter != Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyarrow/_csv.pyx":187
 *         self.options = CCSVParseOptions.Defaults()
 *         if delimiter is not None:
 *             self.delimiter = delimiter             # <<<<<<<<<<<<<<
 *         if quote_char is not None:
 *             self.quote_char = quote_char
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_delimiter, __pyx_v_delimiter) < 0) __PYX_ERR(0, 187, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":186
 *                  ignore_empty_lines=None):
 *         self.options = CCSVParseOptions.Defaults()
 *         if delimiter is not None:             # <<<<<<<<<<<<<<
 *             self.delimiter = delimiter
 *         if quote_char is not None:
 */
  }

  /* "pyarrow/_csv.pyx":188
 *         if delimiter is not None:
 *             self.delimiter = delimiter
 *         if quote_char is not None:             # <<<<<<<<<<<<<<
 *             self.quote_char = quote_char
 *         if double_quote is not None:
 */
  __pyx_t_2 = (__pyx_v_quote_char != Py_None);
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "pyarrow/_csv.pyx":189
 *             self.delimiter = delimiter
 *         if quote_char is not None:
 *             self.quote_char = quote_char             # <<<<<<<<<<<<<<
 *         if double_quote is not None:
 *             self.double_quote = double_quote
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_quote_char, __pyx_v_quote_char) < 0) __PYX_ERR(0, 189, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":188
 *         if delimiter is not None:
 *             self.delimiter = delimiter
 *         if quote_char is not None:             # <<<<<<<<<<<<<<
 *             self.quote_char = quote_char
 *         if double_quote is not None:
 */
  }

  /* "pyarrow/_csv.pyx":190
 *         if quote_char is not None:
 *             self.quote_char = quote_char
 *         if double_quote is not None:             # <<<<<<<<<<<<<<
 *             self.double_quote = double_quote
 *         if escape_char is not None:
 */
  __pyx_t_1 = (__pyx_v_double_quote != Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyarrow/_csv.pyx":191
 *             self.quote_char = quote_char
 *         if double_quote is not None:
 *             self.double_quote = double_quote             # <<<<<<<<<<<<<<
 *         if escape_char is not None:
 *             self.escape_char = escape_char
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_double_quote, __pyx_v_double_quote) < 0) __PYX_ERR(0, 191, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":190
 *         if quote_char is not None:
 *             self.quote_char = quote_char
 *         if double_quote is not None:             # <<<<<<<<<<<<<<
 *             self.double_quote = double_quote
 *         if escape_char is not None:
 */
  }

  /* "pyarrow/_csv.pyx":192
 *         if double_quote is not None:
 *             self.double_quote = double_quote
 *         if escape_char is not None:             # <<<<<<<<<<<<<<
 *             self.escape_char = escape_char
 *         if newlines_in_values is not None:
 */
  __pyx_t_2 = (__pyx_v_escape_char != Py_None);
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "pyarrow/_csv.pyx":193
 *             self.double_quote = double_quote
 *         if escape_char is not None:
 *             self.escape_char = escape_char             # <<<<<<<<<<<<<<
 *         if newlines_in_values is not None:
 *             self.newlines_in_values = newlines_in_values
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_escape_char, __pyx_v_escape_char) < 0) __PYX_ERR(0, 193, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":192
 *         if double_quote is not None:
 *             self.double_quote = double_quote
 *         if escape_char is not None:             # <<<<<<<<<<<<<<
 *             self.escape_char = escape_char
 *         if newlines_in_values is not None:
 */
  }

  /* "pyarrow/_csv.pyx":194
 *         if escape_char is not None:
 *             self.escape_char = escape_char
 *         if newlines_in_values is not None:             # <<<<<<<<<<<<<<
 *             self.newlines_in_values = newlines_in_values
 *         if ignore_empty_lines is not None:
 */
  __pyx_t_1 = (__pyx_v_newlines_in_values != Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyarrow/_csv.pyx":195
 *             self.escape_char = escape_char
 *         if newlines_in_values is not None:
 *             self.newlines_in_values = newlines_in_values             # <<<<<<<<<<<<<<
 *         if ignore_empty_lines is not None:
 *             self.ignore_empty_lines = ignore_empty_lines
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_newlines_in_values, __pyx_v_newlines_in_values) < 0) __PYX_ERR(0, 195, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":194
 *         if escape_char is not None:
 *             self.escape_char = escape_char
 *         if newlines_in_values is not None:             # <<<<<<<<<<<<<<
 *             self.newlines_in_values = newlines_in_values
 *         if ignore_empty_lines is not None:
 */
  }

  /* "pyarrow/_csv.pyx":196
 *         if newlines_in_values is not None:
 *             self.newlines_in_values = newlines_in_values
 *         if ignore_empty_lines is not None:             # <<<<<<<<<<<<<<
 *             self.ignore_empty_lines = ignore_empty_lines
 * 
 */
  __pyx_t_2 = (__pyx_v_ignore_empty_lines != Py_None);
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "pyarrow/_csv.pyx":197
 *             self.newlines_in_values = newlines_in_values
 *         if ignore_empty_lines is not None:
 *             self.ignore_empty_lines = ignore_empty_lines             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_ignore_empty_lines, __pyx_v_ignore_empty_lines) < 0) __PYX_ERR(0, 197, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":196
 *         if newlines_in_values is not None:
 *             self.newlines_in_values = newlines_in_values
 *         if ignore_empty_lines is not None:             # <<<<<<<<<<<<<<
 *             self.ignore_empty_lines = ignore_empty_lines
 * 
 */
  }

  /* "pyarrow/_csv.pyx":182
 *     __slots__ = ()
 * 
 *     def __init__(self, delimiter=None, quote_char=None, double_quote=None,             # <<<<<<<<<<<<<<
 *                  escape_char=None, newlines_in_values=None,
 *                  ignore_empty_lines=None):
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyarrow._csv.ParseOptions.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":200
 * 
 *     @property
 *     def delimiter(self):             # <<<<<<<<<<<<<<
 *         """
 *         The character delimiting individual cells in the CSV data.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_12ParseOptions_9delimiter_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_12ParseOptions_9delimiter_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_12ParseOptions_9delimiter___get__(((struct __pyx_obj_7pyarrow_4_csv_ParseOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_12ParseOptions_9delimiter___get__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":204
 *         The character delimiting individual cells in the CSV data.
 *         """
 *         return chr(self.options.delimiter)             # <<<<<<<<<<<<<<
 * 
 *     @delimiter.setter
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_unsigned_char(__pyx_v_self->options.delimiter); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_chr, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 204, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":200
 * 
 *     @property
 *     def delimiter(self):             # <<<<<<<<<<<<<<
 *         """
 *         The character delimiting individual cells in the CSV data.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("pyarrow._csv.ParseOptions.delimiter.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":207
 * 
 *     @delimiter.setter
 *     def delimiter(self, value):             # <<<<<<<<<<<<<<
 *         self.options.delimiter = _single_char(value)
 * 
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_12ParseOptions_9delimiter_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_12ParseOptions_9delimiter_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_12ParseOptions_9delimiter_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ParseOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_12ParseOptions_9delimiter_2__set__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  unsigned char __pyx_t_1;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":208
 *     @delimiter.setter
 *     def delimiter(self, value):
 *         self.options.delimiter = _single_char(value)             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
  __pyx_t_1 = __pyx_f_7pyarrow_4_csv__single_char(__pyx_v_value); if (unlikely(__pyx_t_1 == ((unsigned char)0))) __PYX_ERR(0, 208, __pyx_L1_error)
  __pyx_v_self->options.delimiter = __pyx_t_1;

  /* "pyarrow/_csv.pyx":207
 * 
 *     @delimiter.setter
 *     def delimiter(self, value):             # <<<<<<<<<<<<<<
 *         self.options.delimiter = _single_char(value)
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyarrow._csv.ParseOptions.delimiter.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":211
 * 
 *     @property
 *     def quote_char(self):             # <<<<<<<<<<<<<<
 *         """
 *         The character used optionally for quoting CSV values
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_12ParseOptions_10quote_char_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_12ParseOptions_10quote_char_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_12ParseOptions_10quote_char___get__(((struct __pyx_obj_7pyarrow_4_csv_ParseOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_12ParseOptions_10quote_char___get__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":216
 *         (False if quoting is not allowed).
 *         """
 *         if self.options.quoting:             # <<<<<<<<<<<<<<
 *             return chr(self.options.quote_char)
 *         else:
 */
  __pyx_t_1 = (__pyx_v_self->options.quoting != 0);
  if (__pyx_t_1) {

    /* "pyarrow/_csv.pyx":217
 *         """
 *         if self.options.quoting:
 *             return chr(self.options.quote_char)             # <<<<<<<<<<<<<<
 *         else:
 *             return False
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __Pyx_PyInt_From_unsigned_char(__pyx_v_self->options.quote_char); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 217, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_chr, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 217, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;

    /* "pyarrow/_csv.pyx":216
 *         (False if quoting is not allowed).
 *         """
 *         if self.options.quoting:             # <<<<<<<<<<<<<<
 *             return chr(self.options.quote_char)
 *         else:
 */
  }

  /* "pyarrow/_csv.pyx":219
 *             return chr(self.options.quote_char)
 *         else:
 *             return False             # <<<<<<<<<<<<<<
 * 
 *     @quote_char.setter
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;
  }

  /* "pyarrow/_csv.pyx":211
 * 
 *     @property
 *     def quote_char(self):             # <<<<<<<<<<<<<<
 *         """
 *         The character used optionally for quoting CSV values
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pyarrow._csv.ParseOptions.quote_char.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":222
 * 
 *     @quote_char.setter
 *     def quote_char(self, value):             # <<<<<<<<<<<<<<
 *         if value is False:
 *             self.options.quoting = False
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_12ParseOptions_10quote_char_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_12ParseOptions_10quote_char_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_12ParseOptions_10quote_char_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ParseOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_12ParseOptions_10quote_char_2__set__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  unsigned char __pyx_t_3;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":223
 *     @quote_char.setter
 *     def quote_char(self, value):
 *         if value is False:             # <<<<<<<<<<<<<<
 *             self.options.quoting = False
 *         else:
 */
  __pyx_t_1 = (__pyx_v_value == Py_False);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyarrow/_csv.pyx":224
 *     def quote_char(self, value):
 *         if value is False:
 *             self.options.quoting = False             # <<<<<<<<<<<<<<
 *         else:
 *             self.options.quote_char = _single_char(value)
 */
    __pyx_v_self->options.quoting = 0;

    /* "pyarrow/_csv.pyx":223
 *     @quote_char.setter
 *     def quote_char(self, value):
 *         if value is False:             # <<<<<<<<<<<<<<
 *             self.options.quoting = False
 *         else:
 */
    goto __pyx_L3;
  }

  /* "pyarrow/_csv.pyx":226
 *             self.options.quoting = False
 *         else:
 *             self.options.quote_char = _single_char(value)             # <<<<<<<<<<<<<<
 *             self.options.quoting = True
 * 
 */
  /*else*/ {
    __pyx_t_3 = __pyx_f_7pyarrow_4_csv__single_char(__pyx_v_value); if (unlikely(__pyx_t_3 == ((unsigned char)0))) __PYX_ERR(0, 226, __pyx_L1_error)
    __pyx_v_self->options.quote_char = __pyx_t_3;

    /* "pyarrow/_csv.pyx":227
 *         else:
 *             self.options.quote_char = _single_char(value)
 *             self.options.quoting = True             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
    __pyx_v_self->options.quoting = 1;
  }
  __pyx_L3:;

  /* "pyarrow/_csv.pyx":222
 * 
 *     @quote_char.setter
 *     def quote_char(self, value):             # <<<<<<<<<<<<<<
 *         if value is False:
 *             self.options.quoting = False
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyarrow._csv.ParseOptions.quote_char.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":230
 * 
 *     @property
 *     def double_quote(self):             # <<<<<<<<<<<<<<
 *         """
 *         Whether two quotes in a quoted CSV value denote a single quote
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_12ParseOptions_12double_quote_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_12ParseOptions_12double_quote_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_12ParseOptions_12double_quote___get__(((struct __pyx_obj_7pyarrow_4_csv_ParseOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_12ParseOptions_12double_quote___get__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":235
 *         in the data.
 *         """
 *         return self.options.double_quote             # <<<<<<<<<<<<<<
 * 
 *     @double_quote.setter
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->options.double_quote); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 235, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":230
 * 
 *     @property
 *     def double_quote(self):             # <<<<<<<<<<<<<<
 *         """
 *         Whether two quotes in a quoted CSV value denote a single quote
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.ParseOptions.double_quote.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":238
 * 
 *     @double_quote.setter
 *     def double_quote(self, value):             # <<<<<<<<<<<<<<
 *         self.options.double_quote = value
 * 
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_12ParseOptions_12double_quote_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_12ParseOptions_12double_quote_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_12ParseOptions_12double_quote_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ParseOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_12ParseOptions_12double_quote_2__set__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  bool __pyx_t_1;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":239
 *     @double_quote.setter
 *     def double_quote(self, value):
 *         self.options.double_quote = value             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_value); if (unlikely((__pyx_t_1 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 239, __pyx_L1_error)
  __pyx_v_self->options.double_quote = __pyx_t_1;

  /* "pyarrow/_csv.pyx":238
 * 
 *     @double_quote.setter
 *     def double_quote(self, value):             # <<<<<<<<<<<<<<
 *         self.options.double_quote = value
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyarrow._csv.ParseOptions.double_quote.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":242
 * 
 *     @property
 *     def escape_char(self):             # <<<<<<<<<<<<<<
 *         """
 *         The character used optionally for escaping special characters
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_12ParseOptions_11escape_char_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_12ParseOptions_11escape_char_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_12ParseOptions_11escape_char___get__(((struct __pyx_obj_7pyarrow_4_csv_ParseOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_12ParseOptions_11escape_char___get__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":247
 *         (False if escaping is not allowed).
 *         """
 *         if self.options.escaping:             # <<<<<<<<<<<<<<
 *             return chr(self.options.escape_char)
 *         else:
 */
  __pyx_t_1 = (__pyx_v_self->options.escaping != 0);
  if (__pyx_t_1) {

    /* "pyarrow/_csv.pyx":248
 *         """
 *         if self.options.escaping:
 *             return chr(self.options.escape_char)             # <<<<<<<<<<<<<<
 *         else:
 *             return False
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __Pyx_PyInt_From_unsigned_char(__pyx_v_self->options.escape_char); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 248, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_chr, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 248, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;

    /* "pyarrow/_csv.pyx":247
 *         (False if escaping is not allowed).
 *         """
 *         if self.options.escaping:             # <<<<<<<<<<<<<<
 *             return chr(self.options.escape_char)
 *         else:
 */
  }

  /* "pyarrow/_csv.pyx":250
 *             return chr(self.options.escape_char)
 *         else:
 *             return False             # <<<<<<<<<<<<<<
 * 
 *     @escape_char.setter
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;
  }

  /* "pyarrow/_csv.pyx":242
 * 
 *     @property
 *     def escape_char(self):             # <<<<<<<<<<<<<<
 *         """
 *         The character used optionally for escaping special characters
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pyarrow._csv.ParseOptions.escape_char.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":253
 * 
 *     @escape_char.setter
 *     def escape_char(self, value):             # <<<<<<<<<<<<<<
 *         if value is False:
 *             self.options.escaping = False
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_12ParseOptions_11escape_char_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_12ParseOptions_11escape_char_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_12ParseOptions_11escape_char_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ParseOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_12ParseOptions_11escape_char_2__set__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  unsigned char __pyx_t_3;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":254
 *     @escape_char.setter
 *     def escape_char(self, value):
 *         if value is False:             # <<<<<<<<<<<<<<
 *             self.options.escaping = False
 *         else:
 */
  __pyx_t_1 = (__pyx_v_value == Py_False);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyarrow/_csv.pyx":255
 *     def escape_char(self, value):
 *         if value is False:
 *             self.options.escaping = False             # <<<<<<<<<<<<<<
 *         else:
 *             self.options.escape_char = _single_char(value)
 */
    __pyx_v_self->options.escaping = 0;

    /* "pyarrow/_csv.pyx":254
 *     @escape_char.setter
 *     def escape_char(self, value):
 *         if value is False:             # <<<<<<<<<<<<<<
 *             self.options.escaping = False
 *         else:
 */
    goto __pyx_L3;
  }

  /* "pyarrow/_csv.pyx":257
 *             self.options.escaping = False
 *         else:
 *             self.options.escape_char = _single_char(value)             # <<<<<<<<<<<<<<
 *             self.options.escaping = True
 * 
 */
  /*else*/ {
    __pyx_t_3 = __pyx_f_7pyarrow_4_csv__single_char(__pyx_v_value); if (unlikely(__pyx_t_3 == ((unsigned char)0))) __PYX_ERR(0, 257, __pyx_L1_error)
    __pyx_v_self->options.escape_char = __pyx_t_3;

    /* "pyarrow/_csv.pyx":258
 *         else:
 *             self.options.escape_char = _single_char(value)
 *             self.options.escaping = True             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
    __pyx_v_self->options.escaping = 1;
  }
  __pyx_L3:;

  /* "pyarrow/_csv.pyx":253
 * 
 *     @escape_char.setter
 *     def escape_char(self, value):             # <<<<<<<<<<<<<<
 *         if value is False:
 *             self.options.escaping = False
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyarrow._csv.ParseOptions.escape_char.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":261
 * 
 *     @property
 *     def newlines_in_values(self):             # <<<<<<<<<<<<<<
 *         """
 *         Whether newline characters are allowed in CSV values.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_12ParseOptions_18newlines_in_values_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_12ParseOptions_18newlines_in_values_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_12ParseOptions_18newlines_in_values___get__(((struct __pyx_obj_7pyarrow_4_csv_ParseOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_12ParseOptions_18newlines_in_values___get__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":267
 *         CSV reading.
 *         """
 *         return self.options.newlines_in_values             # <<<<<<<<<<<<<<
 * 
 *     @newlines_in_values.setter
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->options.newlines_in_values); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 267, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":261
 * 
 *     @property
 *     def newlines_in_values(self):             # <<<<<<<<<<<<<<
 *         """
 *         Whether newline characters are allowed in CSV values.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.ParseOptions.newlines_in_values.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":270
 * 
 *     @newlines_in_values.setter
 *     def newlines_in_values(self, value):             # <<<<<<<<<<<<<<
 *         self.options.newlines_in_values = value
 * 
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_12ParseOptions_18newlines_in_values_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_12ParseOptions_18newlines_in_values_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_12ParseOptions_18newlines_in_values_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ParseOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_12ParseOptions_18newlines_in_values_2__set__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  bool __pyx_t_1;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":271
 *     @newlines_in_values.setter
 *     def newlines_in_values(self, value):
 *         self.options.newlines_in_values = value             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_value); if (unlikely((__pyx_t_1 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 271, __pyx_L1_error)
  __pyx_v_self->options.newlines_in_values = __pyx_t_1;

  /* "pyarrow/_csv.pyx":270
 * 
 *     @newlines_in_values.setter
 *     def newlines_in_values(self, value):             # <<<<<<<<<<<<<<
 *         self.options.newlines_in_values = value
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyarrow._csv.ParseOptions.newlines_in_values.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":274
 * 
 *     @property
 *     def ignore_empty_lines(self):             # <<<<<<<<<<<<<<
 *         """
 *         Whether empty lines are ignored in CSV input.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_12ParseOptions_18ignore_empty_lines_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_12ParseOptions_18ignore_empty_lines_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_12ParseOptions_18ignore_empty_lines___get__(((struct __pyx_obj_7pyarrow_4_csv_ParseOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_12ParseOptions_18ignore_empty_lines___get__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":280
 *         value (assuming a one-column CSV file).
 *         """
 *         return self.options.ignore_empty_lines             # <<<<<<<<<<<<<<
 * 
 *     @ignore_empty_lines.setter
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->options.ignore_empty_lines); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 280, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":274
 * 
 *     @property
 *     def ignore_empty_lines(self):             # <<<<<<<<<<<<<<
 *         """
 *         Whether empty lines are ignored in CSV input.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.ParseOptions.ignore_empty_lines.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":283
 * 
 *     @ignore_empty_lines.setter
 *     def ignore_empty_lines(self, value):             # <<<<<<<<<<<<<<
 *         self.options.ignore_empty_lines = value
 * 
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_12ParseOptions_18ignore_empty_lines_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_12ParseOptions_18ignore_empty_lines_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_12ParseOptions_18ignore_empty_lines_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ParseOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_12ParseOptions_18ignore_empty_lines_2__set__(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  bool __pyx_t_1;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":284
 *     @ignore_empty_lines.setter
 *     def ignore_empty_lines(self, value):
 *         self.options.ignore_empty_lines = value             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_value); if (unlikely((__pyx_t_1 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 284, __pyx_L1_error)
  __pyx_v_self->options.ignore_empty_lines = __pyx_t_1;

  /* "pyarrow/_csv.pyx":283
 * 
 *     @ignore_empty_lines.setter
 *     def ignore_empty_lines(self, value):             # <<<<<<<<<<<<<<
 *         self.options.ignore_empty_lines = value
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyarrow._csv.ParseOptions.ignore_empty_lines.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_12ParseOptions_3__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_7pyarrow_4_csv_12ParseOptions_2__reduce_cython__[] = "ParseOptions.__reduce_cython__(self)";
static PyObject *__pyx_pw_7pyarrow_4_csv_12ParseOptions_3__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_12ParseOptions_2__reduce_cython__(((struct __pyx_obj_7pyarrow_4_csv_ParseOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_12ParseOptions_2__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.ParseOptions.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_12ParseOptions_5__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static char __pyx_doc_7pyarrow_4_csv_12ParseOptions_4__setstate_cython__[] = "ParseOptions.__setstate_cython__(self, __pyx_state)";
static PyObject *__pyx_pw_7pyarrow_4_csv_12ParseOptions_5__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_12ParseOptions_4__setstate_cython__(((struct __pyx_obj_7pyarrow_4_csv_ParseOptions *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_12ParseOptions_4__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.ParseOptions.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":342
 *     __slots__ = ()
 * 
 *     def __init__(self, check_utf8=None, column_types=None, null_values=None,             # <<<<<<<<<<<<<<
 *                  true_values=None, false_values=None,
 *                  strings_can_be_null=None, include_columns=None,
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_check_utf8 = 0;
  PyObject *__pyx_v_column_types = 0;
  PyObject *__pyx_v_null_values = 0;
  PyObject *__pyx_v_true_values = 0;
  PyObject *__pyx_v_false_values = 0;
  PyObject *__pyx_v_strings_can_be_null = 0;
  PyObject *__pyx_v_include_columns = 0;
  PyObject *__pyx_v_include_missing_columns = 0;
  PyObject *__pyx_v_auto_dict_encode = 0;
  PyObject *__pyx_v_auto_dict_max_cardinality = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_check_utf8,&__pyx_n_s_column_types,&__pyx_n_s_null_values,&__pyx_n_s_true_values,&__pyx_n_s_false_values,&__pyx_n_s_strings_can_be_null,&__pyx_n_s_include_columns,&__pyx_n_s_include_missing_columns,&__pyx_n_s_auto_dict_encode,&__pyx_n_s_auto_dict_max_cardinality,0};
    PyObject* values[10] = {0,0,0,0,0,0,0,0,0,0};
    values[0] = ((PyObject *)Py_None);
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);

    /* "pyarrow/_csv.pyx":343
 * 
 *     def __init__(self, check_utf8=None, column_types=None, null_values=None,
 *                  true_values=None, false_values=None,             # <<<<<<<<<<<<<<
 *                  strings_can_be_null=None, include_columns=None,
 *                  include_missing_columns=None, auto_dict_encode=None,
 */
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)Py_None);

    /* "pyarrow/_csv.pyx":344
 *     def __init__(self, check_utf8=None, column_types=None, null_values=None,
 *                  true_values=None, false_values=None,
 *                  strings_can_be_null=None, include_columns=None,             # <<<<<<<<<<<<<<
 *                  include_missing_columns=None, auto_dict_encode=None,
 *                  auto_dict_max_cardinality=None):
 */
    values[5] = ((PyObject *)Py_None);
    values[6] = ((PyObject *)Py_None);

    /* "pyarrow/_csv.pyx":345
 *                  true_values=None, false_values=None,
 *                  strings_can_be_null=None, include_columns=None,
 *                  include_missing_columns=None, auto_dict_encode=None,             # <<<<<<<<<<<<<<
 *                  auto_dict_max_cardinality=None):
 *         self.options = CCSVConvertOptions.Defaults()
 */
    values[7] = ((PyObject *)Py_None);
    values[8] = ((PyObject *)Py_None);

    /* "pyarrow/_csv.pyx":346
 *                  strings_can_be_null=None, include_columns=None,
 *                  include_missing_columns=None, auto_dict_encode=None,
 *                  auto_dict_max_cardinality=None):             # <<<<<<<<<<<<<<
 *         self.options = CCSVConvertOptions.Defaults()
 *         if check_utf8 is not None:
 */
    values[9] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case 10: values[9] = PyTuple_GET_ITEM(__pyx_args, 9);
        CYTHON_FALLTHROUGH;
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        CYTHON_FALLTHROUGH;
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_check_utf8);
          if (value) { values[0] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_column_types);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_null_values);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_true_values);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_false_values);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_strings_can_be_null);
          if (value) { values[5] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  6:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_include_columns);
          if (value) { values[6] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  7:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_include_missing_columns);
          if (value) { values[7] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  8:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_auto_dict_encode);
          if (value) { values[8] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  9:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_auto_dict_max_cardinality);
          if (value) { values[9] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 342, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case 10: values[9] = PyTuple_GET_ITEM(__pyx_args, 9);
        CYTHON_FALLTHROUGH;
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        CYTHON_FALLTHROUGH;
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_check_utf8 = values[0];
    __pyx_v_column_types = values[1];
    __pyx_v_null_values = values[2];
    __pyx_v_true_values = values[3];
    __pyx_v_false_values = values[4];
    __pyx_v_strings_can_be_null = values[5];
    __pyx_v_include_columns = values[6];
    __pyx_v_include_missing_columns = values[7];
    __pyx_v_auto_dict_encode = values[8];
    __pyx_v_auto_dict_max_cardinality = values[9];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 0, 10, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 342, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions___init__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self), __pyx_v_check_utf8, __pyx_v_column_types, __pyx_v_null_values, __pyx_v_true_values, __pyx_v_false_values, __pyx_v_strings_can_be_null, __pyx_v_include_columns, __pyx_v_include_missing_columns, __pyx_v_auto_dict_encode, __pyx_v_auto_dict_max_cardinality);

  /* "pyarrow/_csv.pyx":342
 *     __slots__ = ()
 * 
 *     def __init__(self, check_utf8=None, column_types=None, null_values=None,             # <<<<<<<<<<<<<<
 *                  true_values=None, false_values=None,
 *                  strings_can_be_null=None, include_columns=None,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions___init__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_check_utf8, PyObject *__pyx_v_column_types, PyObject *__pyx_v_null_values, PyObject *__pyx_v_true_values, PyObject *__pyx_v_false_values, PyObject *__pyx_v_strings_can_be_null, PyObject *__pyx_v_include_columns, PyObject *__pyx_v_include_missing_columns, PyObject *__pyx_v_auto_dict_encode, PyObject *__pyx_v_auto_dict_max_cardinality) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "pyarrow/_csv.pyx":347
 *                  include_missing_columns=None, auto_dict_encode=None,
 *                  auto_dict_max_cardinality=None):
 *         self.options = CCSVConvertOptions.Defaults()             # <<<<<<<<<<<<<<
 *         if check_utf8 is not None:
 *             self.check_utf8 = check_utf8
 */
  __pyx_v_self->options =  arrow::csv::ConvertOptions::Defaults();

  /* "pyarrow/_csv.pyx":348
 *                  auto_dict_max_cardinality=None):
 *         self.options = CCSVConvertOptions.Defaults()
 *         if check_utf8 is not None:             # <<<<<<<<<<<<<<
 *             self.check_utf8 = check_utf8
 *         if column_types is not None:
 */
  __pyx_t_1 = (__pyx_v_check_utf8 != Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyarrow/_csv.pyx":349
 *         self.options = CCSVConvertOptions.Defaults()
 *         if check_utf8 is not None:
 *             self.check_utf8 = check_utf8             # <<<<<<<<<<<<<<
 *         if column_types is not None:
 *             self.column_types = column_types
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_utf8, __pyx_v_check_utf8) < 0) __PYX_ERR(0, 349, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":348
 *                  auto_dict_max_cardinality=None):
 *         self.options = CCSVConvertOptions.Defaults()
 *         if check_utf8 is not None:             # <<<<<<<<<<<<<<
 *             self.check_utf8 = check_utf8
 *         if column_types is not None:
 */
  }

  /* "pyarrow/_csv.pyx":350
 *         if check_utf8 is not None:
 *             self.check_utf8 = check_utf8
 *         if column_types is not None:             # <<<<<<<<<<<<<<
 *             self.column_types = column_types
 *         if null_values is not None:
 */
  __pyx_t_2 = (__pyx_v_column_types != Py_None);
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "pyarrow/_csv.pyx":351
 *             self.check_utf8 = check_utf8
 *         if column_types is not None:
 *             self.column_types = column_types             # <<<<<<<<<<<<<<
 *         if null_values is not None:
 *             self.null_values = null_values
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_column_types, __pyx_v_column_types) < 0) __PYX_ERR(0, 351, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":350
 *         if check_utf8 is not None:
 *             self.check_utf8 = check_utf8
 *         if column_types is not None:             # <<<<<<<<<<<<<<
 *             self.column_types = column_types
 *         if null_values is not None:
 */
  }

  /* "pyarrow/_csv.pyx":352
 *         if column_types is not None:
 *             self.column_types = column_types
 *         if null_values is not None:             # <<<<<<<<<<<<<<
 *             self.null_values = null_values
 *         if true_values is not None:
 */
  __pyx_t_1 = (__pyx_v_null_values != Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyarrow/_csv.pyx":353
 *             self.column_types = column_types
 *         if null_values is not None:
 *             self.null_values = null_values             # <<<<<<<<<<<<<<
 *         if true_values is not None:
 *             self.true_values = true_values
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_null_values, __pyx_v_null_values) < 0) __PYX_ERR(0, 353, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":352
 *         if column_types is not None:
 *             self.column_types = column_types
 *         if null_values is not None:             # <<<<<<<<<<<<<<
 *             self.null_values = null_values
 *         if true_values is not None:
 */
  }

  /* "pyarrow/_csv.pyx":354
 *         if null_values is not None:
 *             self.null_values = null_values
 *         if true_values is not None:             # <<<<<<<<<<<<<<
 *             self.true_values = true_values
 *         if false_values is not None:
 */
  __pyx_t_2 = (__pyx_v_true_values != Py_None);
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "pyarrow/_csv.pyx":355
 *             self.null_values = null_values
 *         if true_values is not None:
 *             self.true_values = true_values             # <<<<<<<<<<<<<<
 *         if false_values is not None:
 *             self.false_values = false_values
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_true_values, __pyx_v_true_values) < 0) __PYX_ERR(0, 355, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":354
 *         if null_values is not None:
 *             self.null_values = null_values
 *         if true_values is not None:             # <<<<<<<<<<<<<<
 *             self.true_values = true_values
 *         if false_values is not None:
 */
  }

  /* "pyarrow/_csv.pyx":356
 *         if true_values is not None:
 *             self.true_values = true_values
 *         if false_values is not None:             # <<<<<<<<<<<<<<
 *             self.false_values = false_values
 *         if strings_can_be_null is not None:
 */
  __pyx_t_1 = (__pyx_v_false_values != Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyarrow/_csv.pyx":357
 *             self.true_values = true_values
 *         if false_values is not None:
 *             self.false_values = false_values             # <<<<<<<<<<<<<<
 *         if strings_can_be_null is not None:
 *             self.strings_can_be_null = strings_can_be_null
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_false_values, __pyx_v_false_values) < 0) __PYX_ERR(0, 357, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":356
 *         if true_values is not None:
 *             self.true_values = true_values
 *         if false_values is not None:             # <<<<<<<<<<<<<<
 *             self.false_values = false_values
 *         if strings_can_be_null is not None:
 */
  }

  /* "pyarrow/_csv.pyx":358
 *         if false_values is not None:
 *             self.false_values = false_values
 *         if strings_can_be_null is not None:             # <<<<<<<<<<<<<<
 *             self.strings_can_be_null = strings_can_be_null
 *         if include_columns is not None:
 */
  __pyx_t_2 = (__pyx_v_strings_can_be_null != Py_None);
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "pyarrow/_csv.pyx":359
 *             self.false_values = false_values
 *         if strings_can_be_null is not None:
 *             self.strings_can_be_null = strings_can_be_null             # <<<<<<<<<<<<<<
 *         if include_columns is not None:
 *             self.include_columns = include_columns
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_strings_can_be_null, __pyx_v_strings_can_be_null) < 0) __PYX_ERR(0, 359, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":358
 *         if false_values is not None:
 *             self.false_values = false_values
 *         if strings_can_be_null is not None:             # <<<<<<<<<<<<<<
 *             self.strings_can_be_null = strings_can_be_null
 *         if include_columns is not None:
 */
  }

  /* "pyarrow/_csv.pyx":360
 *         if strings_can_be_null is not None:
 *             self.strings_can_be_null = strings_can_be_null
 *         if include_columns is not None:             # <<<<<<<<<<<<<<
 *             self.include_columns = include_columns
 *         if include_missing_columns is not None:
 */
  __pyx_t_1 = (__pyx_v_include_columns != Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyarrow/_csv.pyx":361
 *             self.strings_can_be_null = strings_can_be_null
 *         if include_columns is not None:
 *             self.include_columns = include_columns             # <<<<<<<<<<<<<<
 *         if include_missing_columns is not None:
 *             self.include_missing_columns = include_missing_columns
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_include_columns, __pyx_v_include_columns) < 0) __PYX_ERR(0, 361, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":360
 *         if strings_can_be_null is not None:
 *             self.strings_can_be_null = strings_can_be_null
 *         if include_columns is not None:             # <<<<<<<<<<<<<<
 *             self.include_columns = include_columns
 *         if include_missing_columns is not None:
 */
  }

  /* "pyarrow/_csv.pyx":362
 *         if include_columns is not None:
 *             self.include_columns = include_columns
 *         if include_missing_columns is not None:             # <<<<<<<<<<<<<<
 *             self.include_missing_columns = include_missing_columns
 *         if auto_dict_encode is not None:
 */
  __pyx_t_2 = (__pyx_v_include_missing_columns != Py_None);
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "pyarrow/_csv.pyx":363
 *             self.include_columns = include_columns
 *         if include_missing_columns is not None:
 *             self.include_missing_columns = include_missing_columns             # <<<<<<<<<<<<<<
 *         if auto_dict_encode is not None:
 *             self.auto_dict_encode = auto_dict_encode
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_include_missing_columns, __pyx_v_include_missing_columns) < 0) __PYX_ERR(0, 363, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":362
 *         if include_columns is not None:
 *             self.include_columns = include_columns
 *         if include_missing_columns is not None:             # <<<<<<<<<<<<<<
 *             self.include_missing_columns = include_missing_columns
 *         if auto_dict_encode is not None:
 */
  }

  /* "pyarrow/_csv.pyx":364
 *         if include_missing_columns is not None:
 *             self.include_missing_columns = include_missing_columns
 *         if auto_dict_encode is not None:             # <<<<<<<<<<<<<<
 *             self.auto_dict_encode = auto_dict_encode
 *         if auto_dict_max_cardinality is not None:
 */
  __pyx_t_1 = (__pyx_v_auto_dict_encode != Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyarrow/_csv.pyx":365
 *             self.include_missing_columns = include_missing_columns
 *         if auto_dict_encode is not None:
 *             self.auto_dict_encode = auto_dict_encode             # <<<<<<<<<<<<<<
 *         if auto_dict_max_cardinality is not None:
 *             self.auto_dict_max_cardinality = auto_dict_max_cardinality
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_auto_dict_encode, __pyx_v_auto_dict_encode) < 0) __PYX_ERR(0, 365, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":364
 *         if include_missing_columns is not None:
 *             self.include_missing_columns = include_missing_columns
 *         if auto_dict_encode is not None:             # <<<<<<<<<<<<<<
 *             self.auto_dict_encode = auto_dict_encode
 *         if auto_dict_max_cardinality is not None:
 */
  }

  /* "pyarrow/_csv.pyx":366
 *         if auto_dict_encode is not None:
 *             self.auto_dict_encode = auto_dict_encode
 *         if auto_dict_max_cardinality is not None:             # <<<<<<<<<<<<<<
 *             self.auto_dict_max_cardinality = auto_dict_max_cardinality
 * 
 */
  __pyx_t_2 = (__pyx_v_auto_dict_max_cardinality != Py_None);
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "pyarrow/_csv.pyx":367
 *             self.auto_dict_encode = auto_dict_encode
 *         if auto_dict_max_cardinality is not None:
 *             self.auto_dict_max_cardinality = auto_dict_max_cardinality             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_auto_dict_max_cardinality, __pyx_v_auto_dict_max_cardinality) < 0) __PYX_ERR(0, 367, __pyx_L1_error)

    /* "pyarrow/_csv.pyx":366
 *         if auto_dict_encode is not None:
 *             self.auto_dict_encode = auto_dict_encode
 *         if auto_dict_max_cardinality is not None:             # <<<<<<<<<<<<<<
 *             self.auto_dict_max_cardinality = auto_dict_max_cardinality
 * 
 */
  }

  /* "pyarrow/_csv.pyx":342
 *     __slots__ = ()
 * 
 *     def __init__(self, check_utf8=None, column_types=None, null_values=None,             # <<<<<<<<<<<<<<
 *                  true_values=None, false_values=None,
 *                  strings_can_be_null=None, include_columns=None,
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":370
 * 
 *     @property
 *     def check_utf8(self):             # <<<<<<<<<<<<<<
 *         """
 *         Whether to check UTF8 validity of string columns.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_10check_utf8_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_10check_utf8_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_10check_utf8___get__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_10check_utf8___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":374
 *         Whether to check UTF8 validity of string columns.
 *         """
 *         return self.options.check_utf8             # <<<<<<<<<<<<<<
 * 
 *     @check_utf8.setter
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->options.check_utf8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 374, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":370
 * 
 *     @property
 *     def check_utf8(self):             # <<<<<<<<<<<<<<
 *         """
 *         Whether to check UTF8 validity of string columns.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.check_utf8.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":377
 * 
 *     @check_utf8.setter
 *     def check_utf8(self, value):             # <<<<<<<<<<<<<<
 *         self.options.check_utf8 = value
 * 
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_10check_utf8_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_10check_utf8_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_10check_utf8_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_10check_utf8_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  bool __pyx_t_1;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":378
 *     @check_utf8.setter
 *     def check_utf8(self, value):
 *         self.options.check_utf8 = value             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_value); if (unlikely((__pyx_t_1 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 378, __pyx_L1_error)
  __pyx_v_self->options.check_utf8 = __pyx_t_1;

  /* "pyarrow/_csv.pyx":377
 * 
 *     @check_utf8.setter
 *     def check_utf8(self, value):             # <<<<<<<<<<<<<<
 *         self.options.check_utf8 = value
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.check_utf8.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":381
 * 
 *     @property
 *     def strings_can_be_null(self):             # <<<<<<<<<<<<<<
 *         """
 *         Whether string / binary columns can have null values.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_19strings_can_be_null_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_19strings_can_be_null_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_19strings_can_be_null___get__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_19strings_can_be_null___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":385
 *         Whether string / binary columns can have null values.
 *         """
 *         return self.options.strings_can_be_null             # <<<<<<<<<<<<<<
 * 
 *     @strings_can_be_null.setter
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->options.strings_can_be_null); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 385, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":381
 * 
 *     @property
 *     def strings_can_be_null(self):             # <<<<<<<<<<<<<<
 *         """
 *         Whether string / binary columns can have null values.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.strings_can_be_null.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":388
 * 
 *     @strings_can_be_null.setter
 *     def strings_can_be_null(self, value):             # <<<<<<<<<<<<<<
 *         self.options.strings_can_be_null = value
 * 
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_19strings_can_be_null_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_19strings_can_be_null_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_19strings_can_be_null_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_19strings_can_be_null_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  bool __pyx_t_1;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":389
 *     @strings_can_be_null.setter
 *     def strings_can_be_null(self, value):
 *         self.options.strings_can_be_null = value             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_value); if (unlikely((__pyx_t_1 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 389, __pyx_L1_error)
  __pyx_v_self->options.strings_can_be_null = __pyx_t_1;

  /* "pyarrow/_csv.pyx":388
 * 
 *     @strings_can_be_null.setter
 *     def strings_can_be_null(self, value):             # <<<<<<<<<<<<<<
 *         self.options.strings_can_be_null = value
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.strings_can_be_null.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":392
 * 
 *     @property
 *     def column_types(self):             # <<<<<<<<<<<<<<
 *         """
 *         Map column names to column types
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_12column_types_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_12column_types_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_12column_types___get__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_12column_types___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self) {
  PyObject *__pyx_v_d = NULL;
  std::pair<std::string,std::shared_ptr< arrow::DataType> >  __pyx_8genexpr1__pyx_v_item;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::unordered_map<std::string,std::shared_ptr< arrow::DataType> > ::iterator __pyx_t_2;
  std::unordered_map<std::string,std::shared_ptr< arrow::DataType> >  *__pyx_t_3;
  std::pair<std::string,std::shared_ptr< arrow::DataType> >  __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":397
 *         (disabling type inference on those columns).
 *         """
 *         d = {frombytes(item.first): pyarrow_wrap_data_type(item.second)             # <<<<<<<<<<<<<<
 *              for item in self.options.column_types}
 *         return d
 */
  { /* enter inner scope */
    __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 397, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);

    /* "pyarrow/_csv.pyx":398
 *         """
 *         d = {frombytes(item.first): pyarrow_wrap_data_type(item.second)
 *              for item in self.options.column_types}             # <<<<<<<<<<<<<<
 *         return d
 * 
 */
    __pyx_t_3 = &__pyx_v_self->options.column_types;
    __pyx_t_2 = __pyx_t_3->begin();
    for (;;) {
      if (!(__pyx_t_2 != __pyx_t_3->end())) break;
      __pyx_t_4 = *__pyx_t_2;
      ++__pyx_t_2;
      __pyx_8genexpr1__pyx_v_item = __pyx_t_4;

      /* "pyarrow/_csv.pyx":397
 *         (disabling type inference on those columns).
 *         """
 *         d = {frombytes(item.first): pyarrow_wrap_data_type(item.second)             # <<<<<<<<<<<<<<
 *              for item in self.options.column_types}
 *         return d
 */
      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_frombytes); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 397, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_7 = __pyx_convert_PyBytes_string_to_py_std__in_string(__pyx_8genexpr1__pyx_v_item.first); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 397, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_8 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
        __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_6);
        if (likely(__pyx_t_8)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
          __Pyx_INCREF(__pyx_t_8);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_6, function);
        }
      }
      __pyx_t_5 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_8, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_7);
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 397, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_6 = __pyx_f_7pyarrow_3lib_pyarrow_wrap_data_type(__pyx_8genexpr1__pyx_v_item.second); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 397, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      if (unlikely(PyDict_SetItem(__pyx_t_1, (PyObject*)__pyx_t_5, (PyObject*)__pyx_t_6))) __PYX_ERR(0, 397, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

      /* "pyarrow/_csv.pyx":398
 *         """
 *         d = {frombytes(item.first): pyarrow_wrap_data_type(item.second)
 *              for item in self.options.column_types}             # <<<<<<<<<<<<<<
 *         return d
 * 
 */
    }
  } /* exit inner scope */
  __pyx_v_d = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pyarrow/_csv.pyx":399
 *         d = {frombytes(item.first): pyarrow_wrap_data_type(item.second)
 *              for item in self.options.column_types}
 *         return d             # <<<<<<<<<<<<<<
 * 
 *     @column_types.setter
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_d);
  __pyx_r = __pyx_v_d;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":392
 * 
 *     @property
 *     def column_types(self):             # <<<<<<<<<<<<<<
 *         """
 *         Map column names to column types
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.column_types.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_d);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":402
 * 
 *     @column_types.setter
 *     def column_types(self, value):             # <<<<<<<<<<<<<<
 *         cdef:
 *             shared_ptr[CDataType] typ
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_12column_types_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_12column_types_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_12column_types_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_12column_types_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  std::shared_ptr< arrow::DataType>  __pyx_v_typ;
  PyObject *__pyx_v_item = NULL;
  PyObject *__pyx_v_k = NULL;
  PyObject *__pyx_v_v = NULL;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  Py_ssize_t __pyx_t_6;
  PyObject *(*__pyx_t_7)(PyObject *);
  PyObject *__pyx_t_8 = NULL;
  PyObject *(*__pyx_t_9)(PyObject *);
  std::string __pyx_t_10;
  __Pyx_RefNannySetupContext("__set__", 0);
  __Pyx_INCREF(__pyx_v_value);

  /* "pyarrow/_csv.pyx":406
 *             shared_ptr[CDataType] typ
 * 
 *         if isinstance(value, Mapping):             # <<<<<<<<<<<<<<
 *             value = value.items()
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_Mapping); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 406, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyObject_IsInstance(__pyx_v_value, __pyx_t_1); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 406, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {

    /* "pyarrow/_csv.pyx":407
 * 
 *         if isinstance(value, Mapping):
 *             value = value.items()             # <<<<<<<<<<<<<<
 * 
 *         self.options.column_types.clear()
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_value, __pyx_n_s_items); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 407, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 407, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF_SET(__pyx_v_value, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "pyarrow/_csv.pyx":406
 *             shared_ptr[CDataType] typ
 * 
 *         if isinstance(value, Mapping):             # <<<<<<<<<<<<<<
 *             value = value.items()
 * 
 */
  }

  /* "pyarrow/_csv.pyx":409
 *             value = value.items()
 * 
 *         self.options.column_types.clear()             # <<<<<<<<<<<<<<
 *         for item in value:
 *             if isinstance(item, Field):
 */
  __pyx_v_self->options.column_types.clear();

  /* "pyarrow/_csv.pyx":410
 * 
 *         self.options.column_types.clear()
 *         for item in value:             # <<<<<<<<<<<<<<
 *             if isinstance(item, Field):
 *                 k = item.name
 */
  if (likely(PyList_CheckExact(__pyx_v_value)) || PyTuple_CheckExact(__pyx_v_value)) {
    __pyx_t_1 = __pyx_v_value; __Pyx_INCREF(__pyx_t_1); __pyx_t_6 = 0;
    __pyx_t_7 = NULL;
  } else {
    __pyx_t_6 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 410, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_7 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 410, __pyx_L1_error)
  }
  for (;;) {
    if (likely(!__pyx_t_7)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_6); __Pyx_INCREF(__pyx_t_4); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 410, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 410, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_6 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_6); __Pyx_INCREF(__pyx_t_4); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 410, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 410, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_7(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 410, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "pyarrow/_csv.pyx":411
 *         self.options.column_types.clear()
 *         for item in value:
 *             if isinstance(item, Field):             # <<<<<<<<<<<<<<
 *                 k = item.name
 *                 v = item.type
 */
    __pyx_t_3 = __Pyx_TypeCheck(__pyx_v_item, __pyx_ptype_7pyarrow_3lib_Field); 
    __pyx_t_2 = (__pyx_t_3 != 0);
    if (__pyx_t_2) {

      /* "pyarrow/_csv.pyx":412
 *         for item in value:
 *             if isinstance(item, Field):
 *                 k = item.name             # <<<<<<<<<<<<<<
 *                 v = item.type
 *             else:
 */
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_item, __pyx_n_s_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 412, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_XDECREF_SET(__pyx_v_k, __pyx_t_4);
      __pyx_t_4 = 0;

      /* "pyarrow/_csv.pyx":413
 *             if isinstance(item, Field):
 *                 k = item.name
 *                 v = item.type             # <<<<<<<<<<<<<<
 *             else:
 *                 k, v = item
 */
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_item, __pyx_n_s_type); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 413, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_XDECREF_SET(__pyx_v_v, __pyx_t_4);
      __pyx_t_4 = 0;

      /* "pyarrow/_csv.pyx":411
 *         self.options.column_types.clear()
 *         for item in value:
 *             if isinstance(item, Field):             # <<<<<<<<<<<<<<
 *                 k = item.name
 *                 v = item.type
 */
      goto __pyx_L6;
    }

    /* "pyarrow/_csv.pyx":415
 *                 v = item.type
 *             else:
 *                 k, v = item             # <<<<<<<<<<<<<<
 *             typ = pyarrow_unwrap_data_type(ensure_type(v))
 *             assert typ != NULL
 */
    /*else*/ {
      if ((likely(PyTuple_CheckExact(__pyx_v_item))) || (PyList_CheckExact(__pyx_v_item))) {
        PyObject* sequence = __pyx_v_item;
        Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
        if (unlikely(size != 2)) {
          if (size > 2) __Pyx_RaiseTooManyValuesError(2);
          else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
          __PYX_ERR(0, 415, __pyx_L1_error)
        }
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        if (likely(PyTuple_CheckExact(sequence))) {
          __pyx_t_4 = PyTuple_GET_ITEM(sequence, 0); 
          __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
        } else {
          __pyx_t_4 = PyList_GET_ITEM(sequence, 0); 
          __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
        }
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        #else
        __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 415, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 415, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        #endif
      } else {
        Py_ssize_t index = -1;
        __pyx_t_8 = PyObject_GetIter(__pyx_v_item); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 415, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        __pyx_t_9 = Py_TYPE(__pyx_t_8)->tp_iternext;
        index = 0; __pyx_t_4 = __pyx_t_9(__pyx_t_8); if (unlikely(!__pyx_t_4)) goto __pyx_L7_unpacking_failed;
        __Pyx_GOTREF(__pyx_t_4);
        index = 1; __pyx_t_5 = __pyx_t_9(__pyx_t_8); if (unlikely(!__pyx_t_5)) goto __pyx_L7_unpacking_failed;
        __Pyx_GOTREF(__pyx_t_5);
        if (__Pyx_IternextUnpackEndCheck(__pyx_t_9(__pyx_t_8), 2) < 0) __PYX_ERR(0, 415, __pyx_L1_error)
        __pyx_t_9 = NULL;
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        goto __pyx_L8_unpacking_done;
        __pyx_L7_unpacking_failed:;
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        __pyx_t_9 = NULL;
        if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
        __PYX_ERR(0, 415, __pyx_L1_error)
        __pyx_L8_unpacking_done:;
      }
      __Pyx_XDECREF_SET(__pyx_v_k, __pyx_t_4);
      __pyx_t_4 = 0;
      __Pyx_XDECREF_SET(__pyx_v_v, __pyx_t_5);
      __pyx_t_5 = 0;
    }
    __pyx_L6:;

    /* "pyarrow/_csv.pyx":416
 *             else:
 *                 k, v = item
 *             typ = pyarrow_unwrap_data_type(ensure_type(v))             # <<<<<<<<<<<<<<
 *             assert typ != NULL
 *             self.options.column_types[tobytes(k)] = typ
 */
    __pyx_t_5 = ((PyObject *)__pyx_f_7pyarrow_3lib_ensure_type(__pyx_v_v, NULL)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 416, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_v_typ = __pyx_f_7pyarrow_3lib_pyarrow_unwrap_data_type(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

    /* "pyarrow/_csv.pyx":417
 *                 k, v = item
 *             typ = pyarrow_unwrap_data_type(ensure_type(v))
 *             assert typ != NULL             # <<<<<<<<<<<<<<
 *             self.options.column_types[tobytes(k)] = typ
 * 
 */
    #ifndef CYTHON_WITHOUT_ASSERTIONS
    if (unlikely(!Py_OptimizeFlag)) {
      if (unlikely(!((__pyx_v_typ != NULL) != 0))) {
        PyErr_SetNone(PyExc_AssertionError);
        __PYX_ERR(0, 417, __pyx_L1_error)
      }
    }
    #endif

    /* "pyarrow/_csv.pyx":418
 *             typ = pyarrow_unwrap_data_type(ensure_type(v))
 *             assert typ != NULL
 *             self.options.column_types[tobytes(k)] = typ             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_tobytes); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 418, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_8 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_8)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_8);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_5 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_8, __pyx_v_k) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_k);
    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 418, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_10 = __pyx_convert_string_from_py_std__in_string(__pyx_t_5); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 418, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    (__pyx_v_self->options.column_types[__pyx_t_10]) = __pyx_v_typ;

    /* "pyarrow/_csv.pyx":410
 * 
 *         self.options.column_types.clear()
 *         for item in value:             # <<<<<<<<<<<<<<
 *             if isinstance(item, Field):
 *                 k = item.name
 */
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyarrow/_csv.pyx":402
 * 
 *     @column_types.setter
 *     def column_types(self, value):             # <<<<<<<<<<<<<<
 *         cdef:
 *             shared_ptr[CDataType] typ
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.column_types.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_item);
  __Pyx_XDECREF(__pyx_v_k);
  __Pyx_XDECREF(__pyx_v_v);
  __Pyx_XDECREF(__pyx_v_value);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":421
 * 
 *     @property
 *     def null_values(self):             # <<<<<<<<<<<<<<
 *         """
 *         A sequence of strings that denote nulls in the data.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_11null_values_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_11null_values_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_11null_values___get__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_11null_values___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self) {
  std::string __pyx_8genexpr2__pyx_v_x;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::vector<std::string> ::iterator __pyx_t_2;
  std::vector<std::string>  *__pyx_t_3;
  std::string __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":425
 *         A sequence of strings that denote nulls in the data.
 *         """
 *         return [frombytes(x) for x in self.options.null_values]             # <<<<<<<<<<<<<<
 * 
 *     @null_values.setter
 */
  __Pyx_XDECREF(__pyx_r);
  { /* enter inner scope */
    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 425, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = &__pyx_v_self->options.null_values;
    __pyx_t_2 = __pyx_t_3->begin();
    for (;;) {
      if (!(__pyx_t_2 != __pyx_t_3->end())) break;
      __pyx_t_4 = *__pyx_t_2;
      ++__pyx_t_2;
      __pyx_8genexpr2__pyx_v_x = __pyx_t_4;
      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_frombytes); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 425, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_7 = __pyx_convert_PyBytes_string_to_py_std__in_string(__pyx_8genexpr2__pyx_v_x); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 425, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_8 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
        __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_6);
        if (likely(__pyx_t_8)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
          __Pyx_INCREF(__pyx_t_8);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_6, function);
        }
      }
      __pyx_t_5 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_8, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_7);
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 425, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(0, 425, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
  } /* exit inner scope */
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":421
 * 
 *     @property
 *     def null_values(self):             # <<<<<<<<<<<<<<
 *         """
 *         A sequence of strings that denote nulls in the data.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.null_values.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":428
 * 
 *     @null_values.setter
 *     def null_values(self, value):             # <<<<<<<<<<<<<<
 *         self.options.null_values = [tobytes(x) for x in value]
 * 
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_11null_values_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_11null_values_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_11null_values_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_11null_values_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  PyObject *__pyx_8genexpr3__pyx_v_x = NULL;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  Py_ssize_t __pyx_t_3;
  PyObject *(*__pyx_t_4)(PyObject *);
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  std::vector<std::string>  __pyx_t_8;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":429
 *     @null_values.setter
 *     def null_values(self, value):
 *         self.options.null_values = [tobytes(x) for x in value]             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
  { /* enter inner scope */
    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 429, __pyx_L5_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (likely(PyList_CheckExact(__pyx_v_value)) || PyTuple_CheckExact(__pyx_v_value)) {
      __pyx_t_2 = __pyx_v_value; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
      __pyx_t_4 = NULL;
    } else {
      __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 429, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 429, __pyx_L5_error)
    }
    for (;;) {
      if (likely(!__pyx_t_4)) {
        if (likely(PyList_CheckExact(__pyx_t_2))) {
          if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 429, __pyx_L5_error)
          #else
          __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 429, __pyx_L5_error)
          __Pyx_GOTREF(__pyx_t_5);
          #endif
        } else {
          if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 429, __pyx_L5_error)
          #else
          __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 429, __pyx_L5_error)
          __Pyx_GOTREF(__pyx_t_5);
          #endif
        }
      } else {
        __pyx_t_5 = __pyx_t_4(__pyx_t_2);
        if (unlikely(!__pyx_t_5)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else __PYX_ERR(0, 429, __pyx_L5_error)
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_5);
      }
      __Pyx_XDECREF_SET(__pyx_8genexpr3__pyx_v_x, __pyx_t_5);
      __pyx_t_5 = 0;
      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_tobytes); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 429, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_7 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
        if (likely(__pyx_t_7)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
          __Pyx_INCREF(__pyx_t_7);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_6, function);
        }
      }
      __pyx_t_5 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_7, __pyx_8genexpr3__pyx_v_x) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_8genexpr3__pyx_v_x);
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 429, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(0, 429, __pyx_L5_error)
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_8genexpr3__pyx_v_x); __pyx_8genexpr3__pyx_v_x = 0;
    goto __pyx_L8_exit_scope;
    __pyx_L5_error:;
    __Pyx_XDECREF(__pyx_8genexpr3__pyx_v_x); __pyx_8genexpr3__pyx_v_x = 0;
    goto __pyx_L1_error;
    __pyx_L8_exit_scope:;
  } /* exit inner scope */
  __pyx_t_8 = __pyx_convert_vector_from_py_std_3a__3a_string(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 429, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_self->options.null_values = __pyx_t_8;

  /* "pyarrow/_csv.pyx":428
 * 
 *     @null_values.setter
 *     def null_values(self, value):             # <<<<<<<<<<<<<<
 *         self.options.null_values = [tobytes(x) for x in value]
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.null_values.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_8genexpr3__pyx_v_x);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":432
 * 
 *     @property
 *     def true_values(self):             # <<<<<<<<<<<<<<
 *         """
 *         A sequence of strings that denote true booleans in the data.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_11true_values_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_11true_values_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_11true_values___get__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_11true_values___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self) {
  std::string __pyx_8genexpr4__pyx_v_x;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::vector<std::string> ::iterator __pyx_t_2;
  std::vector<std::string>  *__pyx_t_3;
  std::string __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":436
 *         A sequence of strings that denote true booleans in the data.
 *         """
 *         return [frombytes(x) for x in self.options.true_values]             # <<<<<<<<<<<<<<
 * 
 *     @true_values.setter
 */
  __Pyx_XDECREF(__pyx_r);
  { /* enter inner scope */
    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 436, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = &__pyx_v_self->options.true_values;
    __pyx_t_2 = __pyx_t_3->begin();
    for (;;) {
      if (!(__pyx_t_2 != __pyx_t_3->end())) break;
      __pyx_t_4 = *__pyx_t_2;
      ++__pyx_t_2;
      __pyx_8genexpr4__pyx_v_x = __pyx_t_4;
      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_frombytes); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 436, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_7 = __pyx_convert_PyBytes_string_to_py_std__in_string(__pyx_8genexpr4__pyx_v_x); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 436, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_8 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
        __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_6);
        if (likely(__pyx_t_8)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
          __Pyx_INCREF(__pyx_t_8);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_6, function);
        }
      }
      __pyx_t_5 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_8, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_7);
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 436, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(0, 436, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
  } /* exit inner scope */
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":432
 * 
 *     @property
 *     def true_values(self):             # <<<<<<<<<<<<<<
 *         """
 *         A sequence of strings that denote true booleans in the data.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.true_values.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":439
 * 
 *     @true_values.setter
 *     def true_values(self, value):             # <<<<<<<<<<<<<<
 *         self.options.true_values = [tobytes(x) for x in value]
 * 
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_11true_values_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_11true_values_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_11true_values_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_11true_values_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  PyObject *__pyx_8genexpr5__pyx_v_x = NULL;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  Py_ssize_t __pyx_t_3;
  PyObject *(*__pyx_t_4)(PyObject *);
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  std::vector<std::string>  __pyx_t_8;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":440
 *     @true_values.setter
 *     def true_values(self, value):
 *         self.options.true_values = [tobytes(x) for x in value]             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
  { /* enter inner scope */
    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 440, __pyx_L5_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (likely(PyList_CheckExact(__pyx_v_value)) || PyTuple_CheckExact(__pyx_v_value)) {
      __pyx_t_2 = __pyx_v_value; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
      __pyx_t_4 = NULL;
    } else {
      __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 440, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 440, __pyx_L5_error)
    }
    for (;;) {
      if (likely(!__pyx_t_4)) {
        if (likely(PyList_CheckExact(__pyx_t_2))) {
          if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 440, __pyx_L5_error)
          #else
          __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 440, __pyx_L5_error)
          __Pyx_GOTREF(__pyx_t_5);
          #endif
        } else {
          if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 440, __pyx_L5_error)
          #else
          __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 440, __pyx_L5_error)
          __Pyx_GOTREF(__pyx_t_5);
          #endif
        }
      } else {
        __pyx_t_5 = __pyx_t_4(__pyx_t_2);
        if (unlikely(!__pyx_t_5)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else __PYX_ERR(0, 440, __pyx_L5_error)
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_5);
      }
      __Pyx_XDECREF_SET(__pyx_8genexpr5__pyx_v_x, __pyx_t_5);
      __pyx_t_5 = 0;
      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_tobytes); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 440, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_7 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
        if (likely(__pyx_t_7)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
          __Pyx_INCREF(__pyx_t_7);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_6, function);
        }
      }
      __pyx_t_5 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_7, __pyx_8genexpr5__pyx_v_x) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_8genexpr5__pyx_v_x);
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 440, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(0, 440, __pyx_L5_error)
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_8genexpr5__pyx_v_x); __pyx_8genexpr5__pyx_v_x = 0;
    goto __pyx_L8_exit_scope;
    __pyx_L5_error:;
    __Pyx_XDECREF(__pyx_8genexpr5__pyx_v_x); __pyx_8genexpr5__pyx_v_x = 0;
    goto __pyx_L1_error;
    __pyx_L8_exit_scope:;
  } /* exit inner scope */
  __pyx_t_8 = __pyx_convert_vector_from_py_std_3a__3a_string(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 440, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_self->options.true_values = __pyx_t_8;

  /* "pyarrow/_csv.pyx":439
 * 
 *     @true_values.setter
 *     def true_values(self, value):             # <<<<<<<<<<<<<<
 *         self.options.true_values = [tobytes(x) for x in value]
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.true_values.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_8genexpr5__pyx_v_x);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":443
 * 
 *     @property
 *     def false_values(self):             # <<<<<<<<<<<<<<
 *         """
 *         A sequence of strings that denote false booleans in the data.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_12false_values_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_12false_values_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_12false_values___get__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_12false_values___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self) {
  std::string __pyx_8genexpr6__pyx_v_x;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::vector<std::string> ::iterator __pyx_t_2;
  std::vector<std::string>  *__pyx_t_3;
  std::string __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":447
 *         A sequence of strings that denote false booleans in the data.
 *         """
 *         return [frombytes(x) for x in self.options.false_values]             # <<<<<<<<<<<<<<
 * 
 *     @false_values.setter
 */
  __Pyx_XDECREF(__pyx_r);
  { /* enter inner scope */
    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 447, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = &__pyx_v_self->options.false_values;
    __pyx_t_2 = __pyx_t_3->begin();
    for (;;) {
      if (!(__pyx_t_2 != __pyx_t_3->end())) break;
      __pyx_t_4 = *__pyx_t_2;
      ++__pyx_t_2;
      __pyx_8genexpr6__pyx_v_x = __pyx_t_4;
      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_frombytes); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 447, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_7 = __pyx_convert_PyBytes_string_to_py_std__in_string(__pyx_8genexpr6__pyx_v_x); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 447, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_8 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
        __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_6);
        if (likely(__pyx_t_8)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
          __Pyx_INCREF(__pyx_t_8);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_6, function);
        }
      }
      __pyx_t_5 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_8, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_7);
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 447, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(0, 447, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
  } /* exit inner scope */
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":443
 * 
 *     @property
 *     def false_values(self):             # <<<<<<<<<<<<<<
 *         """
 *         A sequence of strings that denote false booleans in the data.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.false_values.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":450
 * 
 *     @false_values.setter
 *     def false_values(self, value):             # <<<<<<<<<<<<<<
 *         self.options.false_values = [tobytes(x) for x in value]
 * 
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_12false_values_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_12false_values_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_12false_values_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_12false_values_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  PyObject *__pyx_8genexpr7__pyx_v_x = NULL;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  Py_ssize_t __pyx_t_3;
  PyObject *(*__pyx_t_4)(PyObject *);
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  std::vector<std::string>  __pyx_t_8;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":451
 *     @false_values.setter
 *     def false_values(self, value):
 *         self.options.false_values = [tobytes(x) for x in value]             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
  { /* enter inner scope */
    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 451, __pyx_L5_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (likely(PyList_CheckExact(__pyx_v_value)) || PyTuple_CheckExact(__pyx_v_value)) {
      __pyx_t_2 = __pyx_v_value; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
      __pyx_t_4 = NULL;
    } else {
      __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 451, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 451, __pyx_L5_error)
    }
    for (;;) {
      if (likely(!__pyx_t_4)) {
        if (likely(PyList_CheckExact(__pyx_t_2))) {
          if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 451, __pyx_L5_error)
          #else
          __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 451, __pyx_L5_error)
          __Pyx_GOTREF(__pyx_t_5);
          #endif
        } else {
          if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 451, __pyx_L5_error)
          #else
          __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 451, __pyx_L5_error)
          __Pyx_GOTREF(__pyx_t_5);
          #endif
        }
      } else {
        __pyx_t_5 = __pyx_t_4(__pyx_t_2);
        if (unlikely(!__pyx_t_5)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else __PYX_ERR(0, 451, __pyx_L5_error)
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_5);
      }
      __Pyx_XDECREF_SET(__pyx_8genexpr7__pyx_v_x, __pyx_t_5);
      __pyx_t_5 = 0;
      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_tobytes); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 451, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_7 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
        if (likely(__pyx_t_7)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
          __Pyx_INCREF(__pyx_t_7);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_6, function);
        }
      }
      __pyx_t_5 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_7, __pyx_8genexpr7__pyx_v_x) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_8genexpr7__pyx_v_x);
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 451, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(0, 451, __pyx_L5_error)
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_8genexpr7__pyx_v_x); __pyx_8genexpr7__pyx_v_x = 0;
    goto __pyx_L8_exit_scope;
    __pyx_L5_error:;
    __Pyx_XDECREF(__pyx_8genexpr7__pyx_v_x); __pyx_8genexpr7__pyx_v_x = 0;
    goto __pyx_L1_error;
    __pyx_L8_exit_scope:;
  } /* exit inner scope */
  __pyx_t_8 = __pyx_convert_vector_from_py_std_3a__3a_string(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 451, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_self->options.false_values = __pyx_t_8;

  /* "pyarrow/_csv.pyx":450
 * 
 *     @false_values.setter
 *     def false_values(self, value):             # <<<<<<<<<<<<<<
 *         self.options.false_values = [tobytes(x) for x in value]
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.false_values.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_8genexpr7__pyx_v_x);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":454
 * 
 *     @property
 *     def auto_dict_encode(self):             # <<<<<<<<<<<<<<
 *         """
 *         Whether to try to automatically dict-encode string / binary data.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_16auto_dict_encode_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_16auto_dict_encode_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_16auto_dict_encode___get__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_16auto_dict_encode___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":458
 *         Whether to try to automatically dict-encode string / binary data.
 *         """
 *         return self.options.auto_dict_encode             # <<<<<<<<<<<<<<
 * 
 *     @auto_dict_encode.setter
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->options.auto_dict_encode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 458, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":454
 * 
 *     @property
 *     def auto_dict_encode(self):             # <<<<<<<<<<<<<<
 *         """
 *         Whether to try to automatically dict-encode string / binary data.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.auto_dict_encode.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":461
 * 
 *     @auto_dict_encode.setter
 *     def auto_dict_encode(self, value):             # <<<<<<<<<<<<<<
 *         self.options.auto_dict_encode = value
 * 
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_16auto_dict_encode_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_16auto_dict_encode_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_16auto_dict_encode_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_16auto_dict_encode_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  bool __pyx_t_1;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":462
 *     @auto_dict_encode.setter
 *     def auto_dict_encode(self, value):
 *         self.options.auto_dict_encode = value             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_value); if (unlikely((__pyx_t_1 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 462, __pyx_L1_error)
  __pyx_v_self->options.auto_dict_encode = __pyx_t_1;

  /* "pyarrow/_csv.pyx":461
 * 
 *     @auto_dict_encode.setter
 *     def auto_dict_encode(self, value):             # <<<<<<<<<<<<<<
 *         self.options.auto_dict_encode = value
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.auto_dict_encode.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":465
 * 
 *     @property
 *     def auto_dict_max_cardinality(self):             # <<<<<<<<<<<<<<
 *         """
 *         The maximum dictionary cardinality for `auto_dict_encode`.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_25auto_dict_max_cardinality_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_25auto_dict_max_cardinality_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_25auto_dict_max_cardinality___get__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_25auto_dict_max_cardinality___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":471
 *         This value is per chunk.
 *         """
 *         return self.options.auto_dict_max_cardinality             # <<<<<<<<<<<<<<
 * 
 *     @auto_dict_max_cardinality.setter
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int32_t(__pyx_v_self->options.auto_dict_max_cardinality); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 471, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":465
 * 
 *     @property
 *     def auto_dict_max_cardinality(self):             # <<<<<<<<<<<<<<
 *         """
 *         The maximum dictionary cardinality for `auto_dict_encode`.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.auto_dict_max_cardinality.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":474
 * 
 *     @auto_dict_max_cardinality.setter
 *     def auto_dict_max_cardinality(self, value):             # <<<<<<<<<<<<<<
 *         self.options.auto_dict_max_cardinality = value
 * 
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_25auto_dict_max_cardinality_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_25auto_dict_max_cardinality_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_25auto_dict_max_cardinality_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_25auto_dict_max_cardinality_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int32_t __pyx_t_1;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":475
 *     @auto_dict_max_cardinality.setter
 *     def auto_dict_max_cardinality(self, value):
 *         self.options.auto_dict_max_cardinality = value             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
  __pyx_t_1 = __Pyx_PyInt_As_int32_t(__pyx_v_value); if (unlikely((__pyx_t_1 == ((int32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 475, __pyx_L1_error)
  __pyx_v_self->options.auto_dict_max_cardinality = __pyx_t_1;

  /* "pyarrow/_csv.pyx":474
 * 
 *     @auto_dict_max_cardinality.setter
 *     def auto_dict_max_cardinality(self, value):             # <<<<<<<<<<<<<<
 *         self.options.auto_dict_max_cardinality = value
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.auto_dict_max_cardinality.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":478
 * 
 *     @property
 *     def include_columns(self):             # <<<<<<<<<<<<<<
 *         """
 *         The names of columns to include in the Table.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_15include_columns_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_15include_columns_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_15include_columns___get__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_15include_columns___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self) {
  std::string __pyx_8genexpr8__pyx_v_s;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::vector<std::string> ::iterator __pyx_t_2;
  std::vector<std::string>  *__pyx_t_3;
  std::string __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":485
 *         If not empty, only these columns will be included, in this order.
 *         """
 *         return [frombytes(s) for s in self.options.include_columns]             # <<<<<<<<<<<<<<
 * 
 *     @include_columns.setter
 */
  __Pyx_XDECREF(__pyx_r);
  { /* enter inner scope */
    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 485, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = &__pyx_v_self->options.include_columns;
    __pyx_t_2 = __pyx_t_3->begin();
    for (;;) {
      if (!(__pyx_t_2 != __pyx_t_3->end())) break;
      __pyx_t_4 = *__pyx_t_2;
      ++__pyx_t_2;
      __pyx_8genexpr8__pyx_v_s = __pyx_t_4;
      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_frombytes); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 485, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_7 = __pyx_convert_PyBytes_string_to_py_std__in_string(__pyx_8genexpr8__pyx_v_s); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 485, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_8 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
        __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_6);
        if (likely(__pyx_t_8)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
          __Pyx_INCREF(__pyx_t_8);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_6, function);
        }
      }
      __pyx_t_5 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_8, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_7);
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 485, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(0, 485, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
  } /* exit inner scope */
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":478
 * 
 *     @property
 *     def include_columns(self):             # <<<<<<<<<<<<<<
 *         """
 *         The names of columns to include in the Table.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.include_columns.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":488
 * 
 *     @include_columns.setter
 *     def include_columns(self, value):             # <<<<<<<<<<<<<<
 *         self.options.include_columns.clear()
 *         for item in value:
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_15include_columns_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_15include_columns_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_15include_columns_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_15include_columns_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  PyObject *__pyx_v_item = NULL;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *(*__pyx_t_3)(PyObject *);
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  std::string __pyx_t_7;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":489
 *     @include_columns.setter
 *     def include_columns(self, value):
 *         self.options.include_columns.clear()             # <<<<<<<<<<<<<<
 *         for item in value:
 *             self.options.include_columns.push_back(tobytes(item))
 */
  __pyx_v_self->options.include_columns.clear();

  /* "pyarrow/_csv.pyx":490
 *     def include_columns(self, value):
 *         self.options.include_columns.clear()
 *         for item in value:             # <<<<<<<<<<<<<<
 *             self.options.include_columns.push_back(tobytes(item))
 * 
 */
  if (likely(PyList_CheckExact(__pyx_v_value)) || PyTuple_CheckExact(__pyx_v_value)) {
    __pyx_t_1 = __pyx_v_value; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
    __pyx_t_3 = NULL;
  } else {
    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 490, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 490, __pyx_L1_error)
  }
  for (;;) {
    if (likely(!__pyx_t_3)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 490, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 490, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 490, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 490, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 490, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "pyarrow/_csv.pyx":491
 *         self.options.include_columns.clear()
 *         for item in value:
 *             self.options.include_columns.push_back(tobytes(item))             # <<<<<<<<<<<<<<
 * 
 *     @property
 */
    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_tobytes); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 491, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    __pyx_t_4 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_v_item) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_item);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 491, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_7 = __pyx_convert_string_from_py_std__in_string(__pyx_t_4); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 491, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    try {
      __pyx_v_self->options.include_columns.push_back(__pyx_t_7);
    } catch(...) {
      __Pyx_CppExn2PyErr();
      __PYX_ERR(0, 491, __pyx_L1_error)
    }

    /* "pyarrow/_csv.pyx":490
 *     def include_columns(self, value):
 *         self.options.include_columns.clear()
 *         for item in value:             # <<<<<<<<<<<<<<
 *             self.options.include_columns.push_back(tobytes(item))
 * 
 */
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyarrow/_csv.pyx":488
 * 
 *     @include_columns.setter
 *     def include_columns(self, value):             # <<<<<<<<<<<<<<
 *         self.options.include_columns.clear()
 *         for item in value:
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.include_columns.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_item);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":494
 * 
 *     @property
 *     def include_missing_columns(self):             # <<<<<<<<<<<<<<
 *         """
 *         If false, columns in `include_columns` but not in the CSV file will
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_23include_missing_columns_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_23include_missing_columns_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_23include_missing_columns___get__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_23include_missing_columns___get__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "pyarrow/_csv.pyx":503
 *         This option is ignored if `include_columns` is empty.
 *         """
 *         return self.options.include_missing_columns             # <<<<<<<<<<<<<<
 * 
 *     @include_missing_columns.setter
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->options.include_missing_columns); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 503, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":494
 * 
 *     @property
 *     def include_missing_columns(self):             # <<<<<<<<<<<<<<
 *         """
 *         If false, columns in `include_columns` but not in the CSV file will
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.include_missing_columns.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":506
 * 
 *     @include_missing_columns.setter
 *     def include_missing_columns(self, value):             # <<<<<<<<<<<<<<
 *         self.options.include_missing_columns = value
 * 
 */

/* Python wrapper */
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_23include_missing_columns_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value); /*proto*/
static int __pyx_pw_7pyarrow_4_csv_14ConvertOptions_23include_missing_columns_3__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_23include_missing_columns_2__set__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self), ((PyObject *)__pyx_v_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pyarrow_4_csv_14ConvertOptions_23include_missing_columns_2__set__(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, PyObject *__pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  bool __pyx_t_1;
  __Pyx_RefNannySetupContext("__set__", 0);

  /* "pyarrow/_csv.pyx":507
 *     @include_missing_columns.setter
 *     def include_missing_columns(self, value):
 *         self.options.include_missing_columns = value             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_value); if (unlikely((__pyx_t_1 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 507, __pyx_L1_error)
  __pyx_v_self->options.include_missing_columns = __pyx_t_1;

  /* "pyarrow/_csv.pyx":506
 * 
 *     @include_missing_columns.setter
 *     def include_missing_columns(self, value):             # <<<<<<<<<<<<<<
 *         self.options.include_missing_columns = value
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.include_missing_columns.__set__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_3__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_7pyarrow_4_csv_14ConvertOptions_2__reduce_cython__[] = "ConvertOptions.__reduce_cython__(self)";
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_3__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_2__reduce_cython__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_2__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_5__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static char __pyx_doc_7pyarrow_4_csv_14ConvertOptions_4__setstate_cython__[] = "ConvertOptions.__setstate_cython__(self, __pyx_state)";
static PyObject *__pyx_pw_7pyarrow_4_csv_14ConvertOptions_5__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pyarrow_4_csv_14ConvertOptions_4__setstate_cython__(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_14ConvertOptions_4__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.ConvertOptions.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":510
 * 
 * 
 * cdef _get_reader(input_file, shared_ptr[CInputStream]* out):             # <<<<<<<<<<<<<<
 *     use_memory_map = False
 *     get_input_stream(input_file, use_memory_map, out)
 */

static PyObject *__pyx_f_7pyarrow_4_csv__get_reader(PyObject *__pyx_v_input_file, std::shared_ptr< arrow::io::InputStream>  *__pyx_v_out) {
  int __pyx_v_use_memory_map;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("_get_reader", 0);

  /* "pyarrow/_csv.pyx":511
 * 
 * cdef _get_reader(input_file, shared_ptr[CInputStream]* out):
 *     use_memory_map = False             # <<<<<<<<<<<<<<
 *     get_input_stream(input_file, use_memory_map, out)
 * 
 */
  __pyx_v_use_memory_map = 0;

  /* "pyarrow/_csv.pyx":512
 * cdef _get_reader(input_file, shared_ptr[CInputStream]* out):
 *     use_memory_map = False
 *     get_input_stream(input_file, use_memory_map, out)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_1 = __pyx_f_7pyarrow_3lib_get_input_stream(__pyx_v_input_file, __pyx_v_use_memory_map, __pyx_v_out); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 512, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyarrow/_csv.pyx":510
 * 
 * 
 * cdef _get_reader(input_file, shared_ptr[CInputStream]* out):             # <<<<<<<<<<<<<<
 *     use_memory_map = False
 *     get_input_stream(input_file, use_memory_map, out)
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv._get_reader", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":515
 * 
 * 
 * cdef _get_read_options(ReadOptions read_options, CCSVReadOptions* out):             # <<<<<<<<<<<<<<
 *     if read_options is None:
 *         out[0] = CCSVReadOptions.Defaults()
 */

static PyObject *__pyx_f_7pyarrow_4_csv__get_read_options(struct __pyx_obj_7pyarrow_4_csv_ReadOptions *__pyx_v_read_options,  arrow::csv::ReadOptions *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
   arrow::csv::ReadOptions __pyx_t_3;
  __Pyx_RefNannySetupContext("_get_read_options", 0);

  /* "pyarrow/_csv.pyx":516
 * 
 * cdef _get_read_options(ReadOptions read_options, CCSVReadOptions* out):
 *     if read_options is None:             # <<<<<<<<<<<<<<
 *         out[0] = CCSVReadOptions.Defaults()
 *     else:
 */
  __pyx_t_1 = (((PyObject *)__pyx_v_read_options) == Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyarrow/_csv.pyx":517
 * cdef _get_read_options(ReadOptions read_options, CCSVReadOptions* out):
 *     if read_options is None:
 *         out[0] = CCSVReadOptions.Defaults()             # <<<<<<<<<<<<<<
 *     else:
 *         out[0] = read_options.options
 */
    (__pyx_v_out[0]) =  arrow::csv::ReadOptions::Defaults();

    /* "pyarrow/_csv.pyx":516
 * 
 * cdef _get_read_options(ReadOptions read_options, CCSVReadOptions* out):
 *     if read_options is None:             # <<<<<<<<<<<<<<
 *         out[0] = CCSVReadOptions.Defaults()
 *     else:
 */
    goto __pyx_L3;
  }

  /* "pyarrow/_csv.pyx":519
 *         out[0] = CCSVReadOptions.Defaults()
 *     else:
 *         out[0] = read_options.options             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*else*/ {
    __pyx_t_3 = __pyx_v_read_options->options;
    (__pyx_v_out[0]) = __pyx_t_3;
  }
  __pyx_L3:;

  /* "pyarrow/_csv.pyx":515
 * 
 * 
 * cdef _get_read_options(ReadOptions read_options, CCSVReadOptions* out):             # <<<<<<<<<<<<<<
 *     if read_options is None:
 *         out[0] = CCSVReadOptions.Defaults()
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":522
 * 
 * 
 * cdef _get_parse_options(ParseOptions parse_options, CCSVParseOptions* out):             # <<<<<<<<<<<<<<
 *     if parse_options is None:
 *         out[0] = CCSVParseOptions.Defaults()
 */

static PyObject *__pyx_f_7pyarrow_4_csv__get_parse_options(struct __pyx_obj_7pyarrow_4_csv_ParseOptions *__pyx_v_parse_options,  arrow::csv::ParseOptions *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
   arrow::csv::ParseOptions __pyx_t_3;
  __Pyx_RefNannySetupContext("_get_parse_options", 0);

  /* "pyarrow/_csv.pyx":523
 * 
 * cdef _get_parse_options(ParseOptions parse_options, CCSVParseOptions* out):
 *     if parse_options is None:             # <<<<<<<<<<<<<<
 *         out[0] = CCSVParseOptions.Defaults()
 *     else:
 */
  __pyx_t_1 = (((PyObject *)__pyx_v_parse_options) == Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyarrow/_csv.pyx":524
 * cdef _get_parse_options(ParseOptions parse_options, CCSVParseOptions* out):
 *     if parse_options is None:
 *         out[0] = CCSVParseOptions.Defaults()             # <<<<<<<<<<<<<<
 *     else:
 *         out[0] = parse_options.options
 */
    (__pyx_v_out[0]) =  arrow::csv::ParseOptions::Defaults();

    /* "pyarrow/_csv.pyx":523
 * 
 * cdef _get_parse_options(ParseOptions parse_options, CCSVParseOptions* out):
 *     if parse_options is None:             # <<<<<<<<<<<<<<
 *         out[0] = CCSVParseOptions.Defaults()
 *     else:
 */
    goto __pyx_L3;
  }

  /* "pyarrow/_csv.pyx":526
 *         out[0] = CCSVParseOptions.Defaults()
 *     else:
 *         out[0] = parse_options.options             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*else*/ {
    __pyx_t_3 = __pyx_v_parse_options->options;
    (__pyx_v_out[0]) = __pyx_t_3;
  }
  __pyx_L3:;

  /* "pyarrow/_csv.pyx":522
 * 
 * 
 * cdef _get_parse_options(ParseOptions parse_options, CCSVParseOptions* out):             # <<<<<<<<<<<<<<
 *     if parse_options is None:
 *         out[0] = CCSVParseOptions.Defaults()
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":529
 * 
 * 
 * cdef _get_convert_options(ConvertOptions convert_options,             # <<<<<<<<<<<<<<
 *                           CCSVConvertOptions* out):
 *     if convert_options is None:
 */

static PyObject *__pyx_f_7pyarrow_4_csv__get_convert_options(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *__pyx_v_convert_options,  arrow::csv::ConvertOptions *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
   arrow::csv::ConvertOptions __pyx_t_3;
  __Pyx_RefNannySetupContext("_get_convert_options", 0);

  /* "pyarrow/_csv.pyx":531
 * cdef _get_convert_options(ConvertOptions convert_options,
 *                           CCSVConvertOptions* out):
 *     if convert_options is None:             # <<<<<<<<<<<<<<
 *         out[0] = CCSVConvertOptions.Defaults()
 *     else:
 */
  __pyx_t_1 = (((PyObject *)__pyx_v_convert_options) == Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pyarrow/_csv.pyx":532
 *                           CCSVConvertOptions* out):
 *     if convert_options is None:
 *         out[0] = CCSVConvertOptions.Defaults()             # <<<<<<<<<<<<<<
 *     else:
 *         out[0] = convert_options.options
 */
    (__pyx_v_out[0]) =  arrow::csv::ConvertOptions::Defaults();

    /* "pyarrow/_csv.pyx":531
 * cdef _get_convert_options(ConvertOptions convert_options,
 *                           CCSVConvertOptions* out):
 *     if convert_options is None:             # <<<<<<<<<<<<<<
 *         out[0] = CCSVConvertOptions.Defaults()
 *     else:
 */
    goto __pyx_L3;
  }

  /* "pyarrow/_csv.pyx":534
 *         out[0] = CCSVConvertOptions.Defaults()
 *     else:
 *         out[0] = convert_options.options             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*else*/ {
    __pyx_t_3 = __pyx_v_convert_options->options;
    (__pyx_v_out[0]) = __pyx_t_3;
  }
  __pyx_L3:;

  /* "pyarrow/_csv.pyx":529
 * 
 * 
 * cdef _get_convert_options(ConvertOptions convert_options,             # <<<<<<<<<<<<<<
 *                           CCSVConvertOptions* out):
 *     if convert_options is None:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/_csv.pyx":537
 * 
 * 
 * def read_csv(input_file, read_options=None, parse_options=None,             # <<<<<<<<<<<<<<
 *              convert_options=None, MemoryPool memory_pool=None):
 *     """
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pyarrow_4_csv_1read_csv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_7pyarrow_4_csv_read_csv[] = "read_csv(input_file, read_options=None, parse_options=None, convert_options=None, MemoryPool memory_pool=None)\n\n    Read a Table from a stream of CSV data.\n\n    Parameters\n    ----------\n    input_file: string, path or file-like object\n        The location of CSV data.  If a string or path, and if it ends\n        with a recognized compressed file extension (e.g. \".gz\" or \".bz2\"),\n        the data is automatically decompressed when reading.\n    read_options: pyarrow.csv.ReadOptions, optional\n        Options for the CSV reader (see pyarrow.csv.ReadOptions constructor\n        for defaults)\n    parse_options: pyarrow.csv.ParseOptions, optional\n        Options for the CSV parser\n        (see pyarrow.csv.ParseOptions constructor for defaults)\n    convert_options: pyarrow.csv.ConvertOptions, optional\n        Options for converting CSV data\n        (see pyarrow.csv.ConvertOptions constructor for defaults)\n    memory_pool: MemoryPool, optional\n        Pool to allocate Table memory from\n\n    Returns\n    -------\n    :class:`pyarrow.Table`\n        Contents of the CSV file as a in-memory table.\n    ";
static PyMethodDef __pyx_mdef_7pyarrow_4_csv_1read_csv = {"read_csv", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_7pyarrow_4_csv_1read_csv, METH_VARARGS|METH_KEYWORDS, __pyx_doc_7pyarrow_4_csv_read_csv};
static PyObject *__pyx_pw_7pyarrow_4_csv_1read_csv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_input_file = 0;
  PyObject *__pyx_v_read_options = 0;
  PyObject *__pyx_v_parse_options = 0;
  PyObject *__pyx_v_convert_options = 0;
  struct __pyx_obj_7pyarrow_3lib_MemoryPool *__pyx_v_memory_pool = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("read_csv (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_input_file,&__pyx_n_s_read_options,&__pyx_n_s_parse_options,&__pyx_n_s_convert_options,&__pyx_n_s_memory_pool,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);

    /* "pyarrow/_csv.pyx":538
 * 
 * def read_csv(input_file, read_options=None, parse_options=None,
 *              convert_options=None, MemoryPool memory_pool=None):             # <<<<<<<<<<<<<<
 *     """
 *     Read a Table from a stream of CSV data.
 */
    values[3] = ((PyObject *)Py_None);
    values[4] = (PyObject *)((struct __pyx_obj_7pyarrow_3lib_MemoryPool *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_input_file)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_read_options);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_parse_options);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_convert_options);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_memory_pool);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "read_csv") < 0)) __PYX_ERR(0, 537, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_input_file = values[0];
    __pyx_v_read_options = values[1];
    __pyx_v_parse_options = values[2];
    __pyx_v_convert_options = values[3];
    __pyx_v_memory_pool = ((struct __pyx_obj_7pyarrow_3lib_MemoryPool *)values[4]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("read_csv", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 537, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pyarrow._csv.read_csv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_memory_pool), __pyx_ptype_7pyarrow_3lib_MemoryPool, 1, "memory_pool", 0))) __PYX_ERR(0, 538, __pyx_L1_error)
  __pyx_r = __pyx_pf_7pyarrow_4_csv_read_csv(__pyx_self, __pyx_v_input_file, __pyx_v_read_options, __pyx_v_parse_options, __pyx_v_convert_options, __pyx_v_memory_pool);

  /* "pyarrow/_csv.pyx":537
 * 
 * 
 * def read_csv(input_file, read_options=None, parse_options=None,             # <<<<<<<<<<<<<<
 *              convert_options=None, MemoryPool memory_pool=None):
 *     """
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pyarrow_4_csv_read_csv(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_input_file, PyObject *__pyx_v_read_options, PyObject *__pyx_v_parse_options, PyObject *__pyx_v_convert_options, struct __pyx_obj_7pyarrow_3lib_MemoryPool *__pyx_v_memory_pool) {
  std::shared_ptr< arrow::io::InputStream>  __pyx_v_stream;
   arrow::csv::ReadOptions __pyx_v_c_read_options;
   arrow::csv::ParseOptions __pyx_v_c_parse_options;
   arrow::csv::ConvertOptions __pyx_v_c_convert_options;
  std::shared_ptr< arrow::csv::TableReader>  __pyx_v_reader;
  std::shared_ptr< arrow::Table>  __pyx_v_table;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  std::shared_ptr< arrow::csv::TableReader>  __pyx_t_2;
  std::shared_ptr< arrow::Table>  __pyx_t_3;
  __Pyx_RefNannySetupContext("read_csv", 0);

  /* "pyarrow/_csv.pyx":573
 *         shared_ptr[CTable] table
 * 
 *     _get_reader(input_file, &stream)             # <<<<<<<<<<<<<<
 *     _get_read_options(read_options, &c_read_options)
 *     _get_parse_options(parse_options, &c_parse_options)
 */
  __pyx_t_1 = __pyx_f_7pyarrow_4_csv__get_reader(__pyx_v_input_file, (&__pyx_v_stream)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 573, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyarrow/_csv.pyx":574
 * 
 *     _get_reader(input_file, &stream)
 *     _get_read_options(read_options, &c_read_options)             # <<<<<<<<<<<<<<
 *     _get_parse_options(parse_options, &c_parse_options)
 *     _get_convert_options(convert_options, &c_convert_options)
 */
  if (!(likely(((__pyx_v_read_options) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_read_options, __pyx_ptype_7pyarrow_4_csv_ReadOptions))))) __PYX_ERR(0, 574, __pyx_L1_error)
  __pyx_t_1 = __pyx_f_7pyarrow_4_csv__get_read_options(((struct __pyx_obj_7pyarrow_4_csv_ReadOptions *)__pyx_v_read_options), (&__pyx_v_c_read_options)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 574, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyarrow/_csv.pyx":575
 *     _get_reader(input_file, &stream)
 *     _get_read_options(read_options, &c_read_options)
 *     _get_parse_options(parse_options, &c_parse_options)             # <<<<<<<<<<<<<<
 *     _get_convert_options(convert_options, &c_convert_options)
 * 
 */
  if (!(likely(((__pyx_v_parse_options) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_parse_options, __pyx_ptype_7pyarrow_4_csv_ParseOptions))))) __PYX_ERR(0, 575, __pyx_L1_error)
  __pyx_t_1 = __pyx_f_7pyarrow_4_csv__get_parse_options(((struct __pyx_obj_7pyarrow_4_csv_ParseOptions *)__pyx_v_parse_options), (&__pyx_v_c_parse_options)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 575, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyarrow/_csv.pyx":576
 *     _get_read_options(read_options, &c_read_options)
 *     _get_parse_options(parse_options, &c_parse_options)
 *     _get_convert_options(convert_options, &c_convert_options)             # <<<<<<<<<<<<<<
 * 
 *     reader = GetResultValue(CCSVReader.Make(
 */
  if (!(likely(((__pyx_v_convert_options) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_convert_options, __pyx_ptype_7pyarrow_4_csv_ConvertOptions))))) __PYX_ERR(0, 576, __pyx_L1_error)
  __pyx_t_1 = __pyx_f_7pyarrow_4_csv__get_convert_options(((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)__pyx_v_convert_options), (&__pyx_v_c_convert_options)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 576, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pyarrow/_csv.pyx":578
 *     _get_convert_options(convert_options, &c_convert_options)
 * 
 *     reader = GetResultValue(CCSVReader.Make(             # <<<<<<<<<<<<<<
 *         maybe_unbox_memory_pool(memory_pool), stream,
 *         c_read_options, c_parse_options, c_convert_options))
 */
  __pyx_t_2 = arrow::py::GetResultValue<std::shared_ptr< arrow::csv::TableReader> >( arrow::csv::TableReader::Make(__pyx_f_7pyarrow_3lib_maybe_unbox_memory_pool(__pyx_v_memory_pool), __pyx_v_stream, __pyx_v_c_read_options, __pyx_v_c_parse_options, __pyx_v_c_convert_options)); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 578, __pyx_L1_error)
  __pyx_v_reader = __pyx_t_2;

  /* "pyarrow/_csv.pyx":582
 *         c_read_options, c_parse_options, c_convert_options))
 * 
 *     with nogil:             # <<<<<<<<<<<<<<
 *         table = GetResultValue(reader.get().Read())
 * 
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      __Pyx_FastGIL_Remember();
      #endif
      /*try:*/ {

        /* "pyarrow/_csv.pyx":583
 * 
 *     with nogil:
 *         table = GetResultValue(reader.get().Read())             # <<<<<<<<<<<<<<
 * 
 *     return pyarrow_wrap_table(table)
 */
        __pyx_t_3 = arrow::py::GetResultValue<std::shared_ptr< arrow::Table> >(__pyx_v_reader.get()->Read()); if (unlikely(__Pyx_ErrOccurredWithGIL())) __PYX_ERR(0, 583, __pyx_L4_error)
        __pyx_v_table = __pyx_t_3;
      }

      /* "pyarrow/_csv.pyx":582
 *         c_read_options, c_parse_options, c_convert_options))
 * 
 *     with nogil:             # <<<<<<<<<<<<<<
 *         table = GetResultValue(reader.get().Read())
 * 
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          __Pyx_FastGIL_Forget();
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L4_error: {
          #ifdef WITH_THREAD
          __Pyx_FastGIL_Forget();
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L1_error;
        }
        __pyx_L5:;
      }
  }

  /* "pyarrow/_csv.pyx":585
 *         table = GetResultValue(reader.get().Read())
 * 
 *     return pyarrow_wrap_table(table)             # <<<<<<<<<<<<<<
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_7pyarrow_3lib_pyarrow_wrap_table(__pyx_v_table); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 585, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pyarrow/_csv.pyx":537
 * 
 * 
 * def read_csv(input_file, read_options=None, parse_options=None,             # <<<<<<<<<<<<<<
 *              convert_options=None, MemoryPool memory_pool=None):
 *     """
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pyarrow._csv.read_csv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":104
 * # Datetime C API initialization function.
 * # You have to call it before any usage of DateTime CAPI functions.
 * cdef inline void import_datetime():             # <<<<<<<<<<<<<<
 *     PyDateTime_IMPORT
 * 
 */

static CYTHON_INLINE void __pyx_f_7cpython_8datetime_import_datetime(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("import_datetime", 0);

  /* "cpython/datetime.pxd":105
 * # You have to call it before any usage of DateTime CAPI functions.
 * cdef inline void import_datetime():
 *     PyDateTime_IMPORT             # <<<<<<<<<<<<<<
 * 
 * # Create date object using DateTime CAPI factory function.
 */
  (void)(PyDateTime_IMPORT);

  /* "cpython/datetime.pxd":104
 * # Datetime C API initialization function.
 * # You have to call it before any usage of DateTime CAPI functions.
 * cdef inline void import_datetime():             # <<<<<<<<<<<<<<
 *     PyDateTime_IMPORT
 * 
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "cpython/datetime.pxd":109
 * # Create date object using DateTime CAPI factory function.
 * # Note, there are no range checks for any of the arguments.
 * cdef inline object date_new(int year, int month, int day):             # <<<<<<<<<<<<<<
 *     return PyDateTimeAPI.Date_FromDate(year, month, day, PyDateTimeAPI.DateType)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_date_new(int __pyx_v_year, int __pyx_v_month, int __pyx_v_day) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("date_new", 0);

  /* "cpython/datetime.pxd":110
 * # Note, there are no range checks for any of the arguments.
 * cdef inline object date_new(int year, int month, int day):
 *     return PyDateTimeAPI.Date_FromDate(year, month, day, PyDateTimeAPI.DateType)             # <<<<<<<<<<<<<<
 * 
 * # Create time object using DateTime CAPI factory function
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyDateTimeAPI->Date_FromDate(__pyx_v_year, __pyx_v_month, __pyx_v_day, PyDateTimeAPI->DateType); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 110, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "cpython/datetime.pxd":109
 * # Create date object using DateTime CAPI factory function.
 * # Note, there are no range checks for any of the arguments.
 * cdef inline object date_new(int year, int month, int day):             # <<<<<<<<<<<<<<
 *     return PyDateTimeAPI.Date_FromDate(year, month, day, PyDateTimeAPI.DateType)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("cpython.datetime.date_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":114
 * # Create time object using DateTime CAPI factory function
 * # Note, there are no range checks for any of the arguments.
 * cdef inline object time_new(int hour, int minute, int second, int microsecond, object tz):             # <<<<<<<<<<<<<<
 *     return PyDateTimeAPI.Time_FromTime(hour, minute, second, microsecond, tz, PyDateTimeAPI.TimeType)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_time_new(int __pyx_v_hour, int __pyx_v_minute, int __pyx_v_second, int __pyx_v_microsecond, PyObject *__pyx_v_tz) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("time_new", 0);

  /* "cpython/datetime.pxd":115
 * # Note, there are no range checks for any of the arguments.
 * cdef inline object time_new(int hour, int minute, int second, int microsecond, object tz):
 *     return PyDateTimeAPI.Time_FromTime(hour, minute, second, microsecond, tz, PyDateTimeAPI.TimeType)             # <<<<<<<<<<<<<<
 * 
 * # Create datetime object using DateTime CAPI factory function.
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyDateTimeAPI->Time_FromTime(__pyx_v_hour, __pyx_v_minute, __pyx_v_second, __pyx_v_microsecond, __pyx_v_tz, PyDateTimeAPI->TimeType); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 115, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "cpython/datetime.pxd":114
 * # Create time object using DateTime CAPI factory function
 * # Note, there are no range checks for any of the arguments.
 * cdef inline object time_new(int hour, int minute, int second, int microsecond, object tz):             # <<<<<<<<<<<<<<
 *     return PyDateTimeAPI.Time_FromTime(hour, minute, second, microsecond, tz, PyDateTimeAPI.TimeType)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("cpython.datetime.time_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":119
 * # Create datetime object using DateTime CAPI factory function.
 * # Note, there are no range checks for any of the arguments.
 * cdef inline object datetime_new(int year, int month, int day, int hour, int minute, int second, int microsecond, object tz):             # <<<<<<<<<<<<<<
 *     return PyDateTimeAPI.DateTime_FromDateAndTime(year, month, day, hour, minute, second, microsecond, tz, PyDateTimeAPI.DateTimeType)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_datetime_new(int __pyx_v_year, int __pyx_v_month, int __pyx_v_day, int __pyx_v_hour, int __pyx_v_minute, int __pyx_v_second, int __pyx_v_microsecond, PyObject *__pyx_v_tz) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("datetime_new", 0);

  /* "cpython/datetime.pxd":120
 * # Note, there are no range checks for any of the arguments.
 * cdef inline object datetime_new(int year, int month, int day, int hour, int minute, int second, int microsecond, object tz):
 *     return PyDateTimeAPI.DateTime_FromDateAndTime(year, month, day, hour, minute, second, microsecond, tz, PyDateTimeAPI.DateTimeType)             # <<<<<<<<<<<<<<
 * 
 * # Create timedelta object using DateTime CAPI factory function.
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyDateTimeAPI->DateTime_FromDateAndTime(__pyx_v_year, __pyx_v_month, __pyx_v_day, __pyx_v_hour, __pyx_v_minute, __pyx_v_second, __pyx_v_microsecond, __pyx_v_tz, PyDateTimeAPI->DateTimeType); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 120, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "cpython/datetime.pxd":119
 * # Create datetime object using DateTime CAPI factory function.
 * # Note, there are no range checks for any of the arguments.
 * cdef inline object datetime_new(int year, int month, int day, int hour, int minute, int second, int microsecond, object tz):             # <<<<<<<<<<<<<<
 *     return PyDateTimeAPI.DateTime_FromDateAndTime(year, month, day, hour, minute, second, microsecond, tz, PyDateTimeAPI.DateTimeType)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("cpython.datetime.datetime_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":124
 * # Create timedelta object using DateTime CAPI factory function.
 * # Note, there are no range checks for any of the arguments.
 * cdef inline object timedelta_new(int days, int seconds, int useconds):             # <<<<<<<<<<<<<<
 *     return PyDateTimeAPI.Delta_FromDelta(days, seconds, useconds, 1, PyDateTimeAPI.DeltaType)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_timedelta_new(int __pyx_v_days, int __pyx_v_seconds, int __pyx_v_useconds) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("timedelta_new", 0);

  /* "cpython/datetime.pxd":125
 * # Note, there are no range checks for any of the arguments.
 * cdef inline object timedelta_new(int days, int seconds, int useconds):
 *     return PyDateTimeAPI.Delta_FromDelta(days, seconds, useconds, 1, PyDateTimeAPI.DeltaType)             # <<<<<<<<<<<<<<
 * 
 * # More recognizable getters for date/time/datetime/timedelta.
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyDateTimeAPI->Delta_FromDelta(__pyx_v_days, __pyx_v_seconds, __pyx_v_useconds, 1, PyDateTimeAPI->DeltaType); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 125, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "cpython/datetime.pxd":124
 * # Create timedelta object using DateTime CAPI factory function.
 * # Note, there are no range checks for any of the arguments.
 * cdef inline object timedelta_new(int days, int seconds, int useconds):             # <<<<<<<<<<<<<<
 *     return PyDateTimeAPI.Delta_FromDelta(days, seconds, useconds, 1, PyDateTimeAPI.DeltaType)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("cpython.datetime.timedelta_new", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":133
 * 
 * # Get tzinfo of time
 * cdef inline object time_tzinfo(object o):             # <<<<<<<<<<<<<<
 *     if (<PyDateTime_Time*>o).hastzinfo:
 *         return <object>(<PyDateTime_Time*>o).tzinfo
 */

static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_time_tzinfo(PyObject *__pyx_v_o) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("time_tzinfo", 0);

  /* "cpython/datetime.pxd":134
 * # Get tzinfo of time
 * cdef inline object time_tzinfo(object o):
 *     if (<PyDateTime_Time*>o).hastzinfo:             # <<<<<<<<<<<<<<
 *         return <object>(<PyDateTime_Time*>o).tzinfo
 *     else:
 */
  __pyx_t_1 = (((PyDateTime_Time *)__pyx_v_o)->hastzinfo != 0);
  if (__pyx_t_1) {

    /* "cpython/datetime.pxd":135
 * cdef inline object time_tzinfo(object o):
 *     if (<PyDateTime_Time*>o).hastzinfo:
 *         return <object>(<PyDateTime_Time*>o).tzinfo             # <<<<<<<<<<<<<<
 *     else:
 *         return None
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(((PyObject *)((PyDateTime_Time *)__pyx_v_o)->tzinfo));
    __pyx_r = ((PyObject *)((PyDateTime_Time *)__pyx_v_o)->tzinfo);
    goto __pyx_L0;

    /* "cpython/datetime.pxd":134
 * # Get tzinfo of time
 * cdef inline object time_tzinfo(object o):
 *     if (<PyDateTime_Time*>o).hastzinfo:             # <<<<<<<<<<<<<<
 *         return <object>(<PyDateTime_Time*>o).tzinfo
 *     else:
 */
  }

  /* "cpython/datetime.pxd":137
 *         return <object>(<PyDateTime_Time*>o).tzinfo
 *     else:
 *         return None             # <<<<<<<<<<<<<<
 * 
 * # Get tzinfo of datetime
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __pyx_r = Py_None; __Pyx_INCREF(Py_None);
    goto __pyx_L0;
  }

  /* "cpython/datetime.pxd":133
 * 
 * # Get tzinfo of time
 * cdef inline object time_tzinfo(object o):             # <<<<<<<<<<<<<<
 *     if (<PyDateTime_Time*>o).hastzinfo:
 *         return <object>(<PyDateTime_Time*>o).tzinfo
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":140
 * 
 * # Get tzinfo of datetime
 * cdef inline object datetime_tzinfo(object o):             # <<<<<<<<<<<<<<
 *     if (<PyDateTime_DateTime*>o).hastzinfo:
 *         return <object>(<PyDateTime_DateTime*>o).tzinfo
 */

static CYTHON_INLINE PyObject *__pyx_f_7cpython_8datetime_datetime_tzinfo(PyObject *__pyx_v_o) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("datetime_tzinfo", 0);

  /* "cpython/datetime.pxd":141
 * # Get tzinfo of datetime
 * cdef inline object datetime_tzinfo(object o):
 *     if (<PyDateTime_DateTime*>o).hastzinfo:             # <<<<<<<<<<<<<<
 *         return <object>(<PyDateTime_DateTime*>o).tzinfo
 *     else:
 */
  __pyx_t_1 = (((PyDateTime_DateTime *)__pyx_v_o)->hastzinfo != 0);
  if (__pyx_t_1) {

    /* "cpython/datetime.pxd":142
 * cdef inline object datetime_tzinfo(object o):
 *     if (<PyDateTime_DateTime*>o).hastzinfo:
 *         return <object>(<PyDateTime_DateTime*>o).tzinfo             # <<<<<<<<<<<<<<
 *     else:
 *         return None
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(((PyObject *)((PyDateTime_DateTime *)__pyx_v_o)->tzinfo));
    __pyx_r = ((PyObject *)((PyDateTime_DateTime *)__pyx_v_o)->tzinfo);
    goto __pyx_L0;

    /* "cpython/datetime.pxd":141
 * # Get tzinfo of datetime
 * cdef inline object datetime_tzinfo(object o):
 *     if (<PyDateTime_DateTime*>o).hastzinfo:             # <<<<<<<<<<<<<<
 *         return <object>(<PyDateTime_DateTime*>o).tzinfo
 *     else:
 */
  }

  /* "cpython/datetime.pxd":144
 *         return <object>(<PyDateTime_DateTime*>o).tzinfo
 *     else:
 *         return None             # <<<<<<<<<<<<<<
 * 
 * # Get year of date
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __pyx_r = Py_None; __Pyx_INCREF(Py_None);
    goto __pyx_L0;
  }

  /* "cpython/datetime.pxd":140
 * 
 * # Get tzinfo of datetime
 * cdef inline object datetime_tzinfo(object o):             # <<<<<<<<<<<<<<
 *     if (<PyDateTime_DateTime*>o).hastzinfo:
 *         return <object>(<PyDateTime_DateTime*>o).tzinfo
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":147
 * 
 * # Get year of date
 * cdef inline int date_year(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_GET_YEAR(o)
 * 
 */

static CYTHON_INLINE int __pyx_f_7cpython_8datetime_date_year(PyObject *__pyx_v_o) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("date_year", 0);

  /* "cpython/datetime.pxd":148
 * # Get year of date
 * cdef inline int date_year(object o):
 *     return PyDateTime_GET_YEAR(o)             # <<<<<<<<<<<<<<
 * 
 * # Get month of date
 */
  __pyx_r = PyDateTime_GET_YEAR(__pyx_v_o);
  goto __pyx_L0;

  /* "cpython/datetime.pxd":147
 * 
 * # Get year of date
 * cdef inline int date_year(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_GET_YEAR(o)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":151
 * 
 * # Get month of date
 * cdef inline int date_month(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_GET_MONTH(o)
 * 
 */

static CYTHON_INLINE int __pyx_f_7cpython_8datetime_date_month(PyObject *__pyx_v_o) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("date_month", 0);

  /* "cpython/datetime.pxd":152
 * # Get month of date
 * cdef inline int date_month(object o):
 *     return PyDateTime_GET_MONTH(o)             # <<<<<<<<<<<<<<
 * 
 * # Get day of date
 */
  __pyx_r = PyDateTime_GET_MONTH(__pyx_v_o);
  goto __pyx_L0;

  /* "cpython/datetime.pxd":151
 * 
 * # Get month of date
 * cdef inline int date_month(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_GET_MONTH(o)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":155
 * 
 * # Get day of date
 * cdef inline int date_day(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_GET_DAY(o)
 * 
 */

static CYTHON_INLINE int __pyx_f_7cpython_8datetime_date_day(PyObject *__pyx_v_o) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("date_day", 0);

  /* "cpython/datetime.pxd":156
 * # Get day of date
 * cdef inline int date_day(object o):
 *     return PyDateTime_GET_DAY(o)             # <<<<<<<<<<<<<<
 * 
 * # Get year of datetime
 */
  __pyx_r = PyDateTime_GET_DAY(__pyx_v_o);
  goto __pyx_L0;

  /* "cpython/datetime.pxd":155
 * 
 * # Get day of date
 * cdef inline int date_day(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_GET_DAY(o)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":159
 * 
 * # Get year of datetime
 * cdef inline int datetime_year(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_GET_YEAR(o)
 * 
 */

static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_year(PyObject *__pyx_v_o) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("datetime_year", 0);

  /* "cpython/datetime.pxd":160
 * # Get year of datetime
 * cdef inline int datetime_year(object o):
 *     return PyDateTime_GET_YEAR(o)             # <<<<<<<<<<<<<<
 * 
 * # Get month of datetime
 */
  __pyx_r = PyDateTime_GET_YEAR(__pyx_v_o);
  goto __pyx_L0;

  /* "cpython/datetime.pxd":159
 * 
 * # Get year of datetime
 * cdef inline int datetime_year(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_GET_YEAR(o)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":163
 * 
 * # Get month of datetime
 * cdef inline int datetime_month(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_GET_MONTH(o)
 * 
 */

static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_month(PyObject *__pyx_v_o) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("datetime_month", 0);

  /* "cpython/datetime.pxd":164
 * # Get month of datetime
 * cdef inline int datetime_month(object o):
 *     return PyDateTime_GET_MONTH(o)             # <<<<<<<<<<<<<<
 * 
 * # Get day of datetime
 */
  __pyx_r = PyDateTime_GET_MONTH(__pyx_v_o);
  goto __pyx_L0;

  /* "cpython/datetime.pxd":163
 * 
 * # Get month of datetime
 * cdef inline int datetime_month(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_GET_MONTH(o)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":167
 * 
 * # Get day of datetime
 * cdef inline int datetime_day(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_GET_DAY(o)
 * 
 */

static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_day(PyObject *__pyx_v_o) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("datetime_day", 0);

  /* "cpython/datetime.pxd":168
 * # Get day of datetime
 * cdef inline int datetime_day(object o):
 *     return PyDateTime_GET_DAY(o)             # <<<<<<<<<<<<<<
 * 
 * # Get hour of time
 */
  __pyx_r = PyDateTime_GET_DAY(__pyx_v_o);
  goto __pyx_L0;

  /* "cpython/datetime.pxd":167
 * 
 * # Get day of datetime
 * cdef inline int datetime_day(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_GET_DAY(o)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":171
 * 
 * # Get hour of time
 * cdef inline int time_hour(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_TIME_GET_HOUR(o)
 * 
 */

static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_hour(PyObject *__pyx_v_o) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("time_hour", 0);

  /* "cpython/datetime.pxd":172
 * # Get hour of time
 * cdef inline int time_hour(object o):
 *     return PyDateTime_TIME_GET_HOUR(o)             # <<<<<<<<<<<<<<
 * 
 * # Get minute of time
 */
  __pyx_r = PyDateTime_TIME_GET_HOUR(__pyx_v_o);
  goto __pyx_L0;

  /* "cpython/datetime.pxd":171
 * 
 * # Get hour of time
 * cdef inline int time_hour(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_TIME_GET_HOUR(o)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":175
 * 
 * # Get minute of time
 * cdef inline int time_minute(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_TIME_GET_MINUTE(o)
 * 
 */

static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_minute(PyObject *__pyx_v_o) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("time_minute", 0);

  /* "cpython/datetime.pxd":176
 * # Get minute of time
 * cdef inline int time_minute(object o):
 *     return PyDateTime_TIME_GET_MINUTE(o)             # <<<<<<<<<<<<<<
 * 
 * # Get second of time
 */
  __pyx_r = PyDateTime_TIME_GET_MINUTE(__pyx_v_o);
  goto __pyx_L0;

  /* "cpython/datetime.pxd":175
 * 
 * # Get minute of time
 * cdef inline int time_minute(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_TIME_GET_MINUTE(o)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":179
 * 
 * # Get second of time
 * cdef inline int time_second(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_TIME_GET_SECOND(o)
 * 
 */

static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_second(PyObject *__pyx_v_o) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("time_second", 0);

  /* "cpython/datetime.pxd":180
 * # Get second of time
 * cdef inline int time_second(object o):
 *     return PyDateTime_TIME_GET_SECOND(o)             # <<<<<<<<<<<<<<
 * 
 * # Get microsecond of time
 */
  __pyx_r = PyDateTime_TIME_GET_SECOND(__pyx_v_o);
  goto __pyx_L0;

  /* "cpython/datetime.pxd":179
 * 
 * # Get second of time
 * cdef inline int time_second(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_TIME_GET_SECOND(o)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":183
 * 
 * # Get microsecond of time
 * cdef inline int time_microsecond(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_TIME_GET_MICROSECOND(o)
 * 
 */

static CYTHON_INLINE int __pyx_f_7cpython_8datetime_time_microsecond(PyObject *__pyx_v_o) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("time_microsecond", 0);

  /* "cpython/datetime.pxd":184
 * # Get microsecond of time
 * cdef inline int time_microsecond(object o):
 *     return PyDateTime_TIME_GET_MICROSECOND(o)             # <<<<<<<<<<<<<<
 * 
 * # Get hour of datetime
 */
  __pyx_r = PyDateTime_TIME_GET_MICROSECOND(__pyx_v_o);
  goto __pyx_L0;

  /* "cpython/datetime.pxd":183
 * 
 * # Get microsecond of time
 * cdef inline int time_microsecond(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_TIME_GET_MICROSECOND(o)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":187
 * 
 * # Get hour of datetime
 * cdef inline int datetime_hour(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_DATE_GET_HOUR(o)
 * 
 */

static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_hour(PyObject *__pyx_v_o) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("datetime_hour", 0);

  /* "cpython/datetime.pxd":188
 * # Get hour of datetime
 * cdef inline int datetime_hour(object o):
 *     return PyDateTime_DATE_GET_HOUR(o)             # <<<<<<<<<<<<<<
 * 
 * # Get minute of datetime
 */
  __pyx_r = PyDateTime_DATE_GET_HOUR(__pyx_v_o);
  goto __pyx_L0;

  /* "cpython/datetime.pxd":187
 * 
 * # Get hour of datetime
 * cdef inline int datetime_hour(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_DATE_GET_HOUR(o)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":191
 * 
 * # Get minute of datetime
 * cdef inline int datetime_minute(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_DATE_GET_MINUTE(o)
 * 
 */

static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_minute(PyObject *__pyx_v_o) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("datetime_minute", 0);

  /* "cpython/datetime.pxd":192
 * # Get minute of datetime
 * cdef inline int datetime_minute(object o):
 *     return PyDateTime_DATE_GET_MINUTE(o)             # <<<<<<<<<<<<<<
 * 
 * # Get second of datetime
 */
  __pyx_r = PyDateTime_DATE_GET_MINUTE(__pyx_v_o);
  goto __pyx_L0;

  /* "cpython/datetime.pxd":191
 * 
 * # Get minute of datetime
 * cdef inline int datetime_minute(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_DATE_GET_MINUTE(o)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":195
 * 
 * # Get second of datetime
 * cdef inline int datetime_second(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_DATE_GET_SECOND(o)
 * 
 */

static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_second(PyObject *__pyx_v_o) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("datetime_second", 0);

  /* "cpython/datetime.pxd":196
 * # Get second of datetime
 * cdef inline int datetime_second(object o):
 *     return PyDateTime_DATE_GET_SECOND(o)             # <<<<<<<<<<<<<<
 * 
 * # Get microsecond of datetime
 */
  __pyx_r = PyDateTime_DATE_GET_SECOND(__pyx_v_o);
  goto __pyx_L0;

  /* "cpython/datetime.pxd":195
 * 
 * # Get second of datetime
 * cdef inline int datetime_second(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_DATE_GET_SECOND(o)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":199
 * 
 * # Get microsecond of datetime
 * cdef inline int datetime_microsecond(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_DATE_GET_MICROSECOND(o)
 * 
 */

static CYTHON_INLINE int __pyx_f_7cpython_8datetime_datetime_microsecond(PyObject *__pyx_v_o) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("datetime_microsecond", 0);

  /* "cpython/datetime.pxd":200
 * # Get microsecond of datetime
 * cdef inline int datetime_microsecond(object o):
 *     return PyDateTime_DATE_GET_MICROSECOND(o)             # <<<<<<<<<<<<<<
 * 
 * # Get days of timedelta
 */
  __pyx_r = PyDateTime_DATE_GET_MICROSECOND(__pyx_v_o);
  goto __pyx_L0;

  /* "cpython/datetime.pxd":199
 * 
 * # Get microsecond of datetime
 * cdef inline int datetime_microsecond(object o):             # <<<<<<<<<<<<<<
 *     return PyDateTime_DATE_GET_MICROSECOND(o)
 * 
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":203
 * 
 * # Get days of timedelta
 * cdef inline int timedelta_days(object o):             # <<<<<<<<<<<<<<
 *     return (<PyDateTime_Delta*>o).days
 * 
 */

static CYTHON_INLINE int __pyx_f_7cpython_8datetime_timedelta_days(PyObject *__pyx_v_o) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("timedelta_days", 0);

  /* "cpython/datetime.pxd":204
 * # Get days of timedelta
 * cdef inline int timedelta_days(object o):
 *     return (<PyDateTime_Delta*>o).days             # <<<<<<<<<<<<<<
 * 
 * # Get seconds of timedelta
 */
  __pyx_r = ((PyDateTime_Delta *)__pyx_v_o)->days;
  goto __pyx_L0;

  /* "cpython/datetime.pxd":203
 * 
 * # Get days of timedelta
 * cdef inline int timedelta_days(object o):             # <<<<<<<<<<<<<<
 *     return (<PyDateTime_Delta*>o).days
 * 
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":207
 * 
 * # Get seconds of timedelta
 * cdef inline int timedelta_seconds(object o):             # <<<<<<<<<<<<<<
 *     return (<PyDateTime_Delta*>o).seconds
 * 
 */

static CYTHON_INLINE int __pyx_f_7cpython_8datetime_timedelta_seconds(PyObject *__pyx_v_o) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("timedelta_seconds", 0);

  /* "cpython/datetime.pxd":208
 * # Get seconds of timedelta
 * cdef inline int timedelta_seconds(object o):
 *     return (<PyDateTime_Delta*>o).seconds             # <<<<<<<<<<<<<<
 * 
 * # Get microseconds of timedelta
 */
  __pyx_r = ((PyDateTime_Delta *)__pyx_v_o)->seconds;
  goto __pyx_L0;

  /* "cpython/datetime.pxd":207
 * 
 * # Get seconds of timedelta
 * cdef inline int timedelta_seconds(object o):             # <<<<<<<<<<<<<<
 *     return (<PyDateTime_Delta*>o).seconds
 * 
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "cpython/datetime.pxd":211
 * 
 * # Get microseconds of timedelta
 * cdef inline int timedelta_microseconds(object o):             # <<<<<<<<<<<<<<
 *     return (<PyDateTime_Delta*>o).microseconds
 */

static CYTHON_INLINE int __pyx_f_7cpython_8datetime_timedelta_microseconds(PyObject *__pyx_v_o) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("timedelta_microseconds", 0);

  /* "cpython/datetime.pxd":212
 * # Get microseconds of timedelta
 * cdef inline int timedelta_microseconds(object o):
 *     return (<PyDateTime_Delta*>o).microseconds             # <<<<<<<<<<<<<<
 */
  __pyx_r = ((PyDateTime_Delta *)__pyx_v_o)->microseconds;
  goto __pyx_L0;

  /* "cpython/datetime.pxd":211
 * 
 * # Get microseconds of timedelta
 * cdef inline int timedelta_microseconds(object o):             # <<<<<<<<<<<<<<
 *     return (<PyDateTime_Delta*>o).microseconds
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pyarrow/includes/common.pxd":106
 *     T GetResultValue[T](CResult[T]) except *
 * 
 * cdef inline object PyObject_to_object(PyObject* o):             # <<<<<<<<<<<<<<
 *     # Cast to "object" increments reference count
 *     cdef object result = <object> o
 */

static CYTHON_INLINE PyObject *__pyx_f_7pyarrow_8includes_6common_PyObject_to_object(PyObject *__pyx_v_o) {
  PyObject *__pyx_v_result = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("PyObject_to_object", 0);

  /* "pyarrow/includes/common.pxd":108
 * cdef inline object PyObject_to_object(PyObject* o):
 *     # Cast to "object" increments reference count
 *     cdef object result = <object> o             # <<<<<<<<<<<<<<
 *     cpython.Py_DECREF(result)
 *     return result
 */
  __pyx_t_1 = ((PyObject *)__pyx_v_o);
  __Pyx_INCREF(__pyx_t_1);
  __pyx_v_result = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "pyarrow/includes/common.pxd":109
 *     # Cast to "object" increments reference count
 *     cdef object result = <object> o
 *     cpython.Py_DECREF(result)             # <<<<<<<<<<<<<<
 *     return result
 */
  Py_DECREF(__pyx_v_result);

  /* "pyarrow/includes/common.pxd":110
 *     cdef object result = <object> o
 *     cpython.Py_DECREF(result)
 *     return result             # <<<<<<<<<<<<<<
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_result);
  __pyx_r = __pyx_v_result;
  goto __pyx_L0;

  /* "pyarrow/includes/common.pxd":106
 *     T GetResultValue[T](CResult[T]) except *
 * 
 * cdef inline object PyObject_to_object(PyObject* o):             # <<<<<<<<<<<<<<
 *     # Cast to "object" increments reference count
 *     cdef object result = <object> o
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_result);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":31
 * 
 * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyObject_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyObject_string_to_py_std__in_string", 0);

  /* "string.to_py":32
 * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * cdef extern from *:
 *     cdef object __Pyx_PyUnicode_FromStringAndSize(const char*, size_t)
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 32, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":31
 * 
 * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyObject_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":37
 * 
 * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyUnicode_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyUnicode_string_to_py_std__in_string", 0);

  /* "string.to_py":38
 * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * cdef extern from *:
 *     cdef object __Pyx_PyStr_FromStringAndSize(const char*, size_t)
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyUnicode_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 38, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":37
 * 
 * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyUnicode_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":43
 * 
 * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyStr_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyStr_string_to_py_std__in_string", 0);

  /* "string.to_py":44
 * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * cdef extern from *:
 *     cdef object __Pyx_PyBytes_FromStringAndSize(const char*, size_t)
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyStr_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 44, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":43
 * 
 * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyStr_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":49
 * 
 * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyBytes_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyBytes_string_to_py_std__in_string", 0);

  /* "string.to_py":50
 * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * cdef extern from *:
 *     cdef object __Pyx_PyByteArray_FromStringAndSize(const char*, size_t)
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 50, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":49
 * 
 * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyBytes_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":55
 * 
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
 * 
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyByteArray_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyByteArray_string_to_py_std__in_string", 0);

  /* "string.to_py":56
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyByteArray_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 56, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":55
 * 
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyByteArray_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.from_py":13
 * 
 * @cname("__pyx_convert_string_from_py_std__in_string")
 * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:             # <<<<<<<<<<<<<<
 *     cdef Py_ssize_t length = 0
 *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
 */

static std::string __pyx_convert_string_from_py_std__in_string(PyObject *__pyx_v_o) {
  Py_ssize_t __pyx_v_length;
  char const *__pyx_v_data;
  std::string __pyx_r;
  __Pyx_RefNannyDeclarations
  char const *__pyx_t_1;
  __Pyx_RefNannySetupContext("__pyx_convert_string_from_py_std__in_string", 0);

  /* "string.from_py":14
 * @cname("__pyx_convert_string_from_py_std__in_string")
 * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:
 *     cdef Py_ssize_t length = 0             # <<<<<<<<<<<<<<
 *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
 *     return string(data, length)
 */
  __pyx_v_length = 0;

  /* "string.from_py":15
 * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:
 *     cdef Py_ssize_t length = 0
 *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)             # <<<<<<<<<<<<<<
 *     return string(data, length)
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_AsStringAndSize(__pyx_v_o, (&__pyx_v_length)); if (unlikely(__pyx_t_1 == ((char const *)NULL))) __PYX_ERR(1, 15, __pyx_L1_error)
  __pyx_v_data = __pyx_t_1;

  /* "string.from_py":16
 *     cdef Py_ssize_t length = 0
 *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
 *     return string(data, length)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = std::string(__pyx_v_data, __pyx_v_length);
  goto __pyx_L0;

  /* "string.from_py":13
 * 
 * @cname("__pyx_convert_string_from_py_std__in_string")
 * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:             # <<<<<<<<<<<<<<
 *     cdef Py_ssize_t length = 0
 *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("string.from_py.__pyx_convert_string_from_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_pretend_to_initialize(&__pyx_r);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "vector.from_py":45
 * 
 * @cname("__pyx_convert_vector_from_py_std_3a__3a_string")
 * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:             # <<<<<<<<<<<<<<
 *     cdef vector[X] v
 *     for item in o:
 */

static std::vector<std::string>  __pyx_convert_vector_from_py_std_3a__3a_string(PyObject *__pyx_v_o) {
  std::vector<std::string>  __pyx_v_v;
  PyObject *__pyx_v_item = NULL;
  std::vector<std::string>  __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *(*__pyx_t_3)(PyObject *);
  PyObject *__pyx_t_4 = NULL;
  std::string __pyx_t_5;
  __Pyx_RefNannySetupContext("__pyx_convert_vector_from_py_std_3a__3a_string", 0);

  /* "vector.from_py":47
 * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:
 *     cdef vector[X] v
 *     for item in o:             # <<<<<<<<<<<<<<
 *         v.push_back(<X>item)
 *     return v
 */
  if (likely(PyList_CheckExact(__pyx_v_o)) || PyTuple_CheckExact(__pyx_v_o)) {
    __pyx_t_1 = __pyx_v_o; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
    __pyx_t_3 = NULL;
  } else {
    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 47, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 47, __pyx_L1_error)
  }
  for (;;) {
    if (likely(!__pyx_t_3)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(1, 47, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "vector.from_py":48
 *     cdef vector[X] v
 *     for item in o:
 *         v.push_back(<X>item)             # <<<<<<<<<<<<<<
 *     return v
 * 
 */
    __pyx_t_5 = __pyx_convert_string_from_py_std__in_string(__pyx_v_item); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 48, __pyx_L1_error)
    __pyx_v_v.push_back(((std::string)__pyx_t_5));

    /* "vector.from_py":47
 * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:
 *     cdef vector[X] v
 *     for item in o:             # <<<<<<<<<<<<<<
 *         v.push_back(<X>item)
 *     return v
 */
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "vector.from_py":49
 *     for item in o:
 *         v.push_back(<X>item)
 *     return v             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = __pyx_v_v;
  goto __pyx_L0;

  /* "vector.from_py":45
 * 
 * @cname("__pyx_convert_vector_from_py_std_3a__3a_string")
 * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:             # <<<<<<<<<<<<<<
 *     cdef vector[X] v
 *     for item in o:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("vector.from_py.__pyx_convert_vector_from_py_std_3a__3a_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_pretend_to_initialize(&__pyx_r);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_item);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_tp_new_7pyarrow_4_csv_ReadOptions(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_7pyarrow_4_csv_ReadOptions *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_7pyarrow_4_csv_ReadOptions *)o);
  new((void*)&(p->options))  arrow::csv::ReadOptions();
  return o;
}

static void __pyx_tp_dealloc_7pyarrow_4_csv_ReadOptions(PyObject *o) {
  struct __pyx_obj_7pyarrow_4_csv_ReadOptions *p = (struct __pyx_obj_7pyarrow_4_csv_ReadOptions *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->options);
  (*Py_TYPE(o)->tp_free)(o);
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_11ReadOptions_use_threads(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_11ReadOptions_11use_threads_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_11ReadOptions_use_threads(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_11ReadOptions_11use_threads_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_11ReadOptions_block_size(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_11ReadOptions_10block_size_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_11ReadOptions_block_size(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_11ReadOptions_10block_size_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_11ReadOptions_skip_rows(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_11ReadOptions_9skip_rows_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_11ReadOptions_skip_rows(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_11ReadOptions_9skip_rows_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_11ReadOptions_column_names(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_11ReadOptions_12column_names_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_11ReadOptions_column_names(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_11ReadOptions_12column_names_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_11ReadOptions_autogenerate_column_names(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_11ReadOptions_25autogenerate_column_names_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_11ReadOptions_autogenerate_column_names(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_11ReadOptions_25autogenerate_column_names_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyMethodDef __pyx_methods_7pyarrow_4_csv_ReadOptions[] = {
  {"__reduce_cython__", (PyCFunction)__pyx_pw_7pyarrow_4_csv_11ReadOptions_3__reduce_cython__, METH_NOARGS, __pyx_doc_7pyarrow_4_csv_11ReadOptions_2__reduce_cython__},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_7pyarrow_4_csv_11ReadOptions_5__setstate_cython__, METH_O, __pyx_doc_7pyarrow_4_csv_11ReadOptions_4__setstate_cython__},
  {0, 0, 0, 0}
};

static struct PyGetSetDef __pyx_getsets_7pyarrow_4_csv_ReadOptions[] = {
  {(char *)"use_threads", __pyx_getprop_7pyarrow_4_csv_11ReadOptions_use_threads, __pyx_setprop_7pyarrow_4_csv_11ReadOptions_use_threads, (char *)"\n        Whether to use multiple threads to accelerate reading.\n        ", 0},
  {(char *)"block_size", __pyx_getprop_7pyarrow_4_csv_11ReadOptions_block_size, __pyx_setprop_7pyarrow_4_csv_11ReadOptions_block_size, (char *)"\n        How much bytes to process at a time from the input stream.\n        This will determine multi-threading granularity as well as\n        the size of individual chunks in the Table.\n        ", 0},
  {(char *)"skip_rows", __pyx_getprop_7pyarrow_4_csv_11ReadOptions_skip_rows, __pyx_setprop_7pyarrow_4_csv_11ReadOptions_skip_rows, (char *)"\n        The number of rows to skip at the start of the CSV data, not\n        including the row of column names (if any).\n        ", 0},
  {(char *)"column_names", __pyx_getprop_7pyarrow_4_csv_11ReadOptions_column_names, __pyx_setprop_7pyarrow_4_csv_11ReadOptions_column_names, (char *)"\n        The column names of the target table.  If empty, fall back on\n        `autogenerate_column_names`.\n        ", 0},
  {(char *)"autogenerate_column_names", __pyx_getprop_7pyarrow_4_csv_11ReadOptions_autogenerate_column_names, __pyx_setprop_7pyarrow_4_csv_11ReadOptions_autogenerate_column_names, (char *)"\n        Whether to autogenerate column names if `column_names` is empty.\n        If true, column names will be of the form \"f0\", \"f1\"...\n        If false, column names will be read from the first CSV row\n        after `skip_rows`.\n        ", 0},
  {0, 0, 0, 0, 0}
};

static PyTypeObject __pyx_type_7pyarrow_4_csv_ReadOptions = {
  PyVarObject_HEAD_INIT(0, 0)
  "pyarrow._csv.ReadOptions", /*tp_name*/
  sizeof(struct __pyx_obj_7pyarrow_4_csv_ReadOptions), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_7pyarrow_4_csv_ReadOptions, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "ReadOptions(use_threads=None, block_size=None, skip_rows=None, column_names=None, autogenerate_column_names=None)\n\n    Options for reading CSV files.\n\n    Parameters\n    ----------\n    use_threads : bool, optional (default True)\n        Whether to use multiple threads to accelerate reading\n    block_size : int, optional\n        How much bytes to process at a time from the input stream.\n        This will determine multi-threading granularity as well as\n        the size of individual chunks in the Table.\n    skip_rows: int, optional (default 0)\n        The number of rows to skip at the start of the CSV data, not\n        including the row of column names (if any).\n    column_names: list, optional\n        The column names of the target table.  If empty, fall back on\n        `autogenerate_column_names`.\n    autogenerate_column_names: bool, optional (default False)\n        Whether to autogenerate column names if `column_names` is empty.\n        If true, column names will be of the form \"f0\", \"f1\"...\n        If false, column names will be read from the first CSV row\n        after `skip_rows`.\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_7pyarrow_4_csv_ReadOptions, /*tp_methods*/
  0, /*tp_members*/
  __pyx_getsets_7pyarrow_4_csv_ReadOptions, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_7pyarrow_4_csv_11ReadOptions_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_7pyarrow_4_csv_ReadOptions, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
};

static PyObject *__pyx_tp_new_7pyarrow_4_csv_ParseOptions(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_7pyarrow_4_csv_ParseOptions *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_7pyarrow_4_csv_ParseOptions *)o);
  new((void*)&(p->options))  arrow::csv::ParseOptions();
  return o;
}

static void __pyx_tp_dealloc_7pyarrow_4_csv_ParseOptions(PyObject *o) {
  struct __pyx_obj_7pyarrow_4_csv_ParseOptions *p = (struct __pyx_obj_7pyarrow_4_csv_ParseOptions *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->options);
  (*Py_TYPE(o)->tp_free)(o);
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_12ParseOptions_delimiter(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_12ParseOptions_9delimiter_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_12ParseOptions_delimiter(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_12ParseOptions_9delimiter_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_12ParseOptions_quote_char(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_12ParseOptions_10quote_char_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_12ParseOptions_quote_char(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_12ParseOptions_10quote_char_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_12ParseOptions_double_quote(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_12ParseOptions_12double_quote_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_12ParseOptions_double_quote(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_12ParseOptions_12double_quote_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_12ParseOptions_escape_char(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_12ParseOptions_11escape_char_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_12ParseOptions_escape_char(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_12ParseOptions_11escape_char_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_12ParseOptions_newlines_in_values(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_12ParseOptions_18newlines_in_values_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_12ParseOptions_newlines_in_values(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_12ParseOptions_18newlines_in_values_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_12ParseOptions_ignore_empty_lines(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_12ParseOptions_18ignore_empty_lines_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_12ParseOptions_ignore_empty_lines(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_12ParseOptions_18ignore_empty_lines_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyMethodDef __pyx_methods_7pyarrow_4_csv_ParseOptions[] = {
  {"__reduce_cython__", (PyCFunction)__pyx_pw_7pyarrow_4_csv_12ParseOptions_3__reduce_cython__, METH_NOARGS, __pyx_doc_7pyarrow_4_csv_12ParseOptions_2__reduce_cython__},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_7pyarrow_4_csv_12ParseOptions_5__setstate_cython__, METH_O, __pyx_doc_7pyarrow_4_csv_12ParseOptions_4__setstate_cython__},
  {0, 0, 0, 0}
};

static struct PyGetSetDef __pyx_getsets_7pyarrow_4_csv_ParseOptions[] = {
  {(char *)"delimiter", __pyx_getprop_7pyarrow_4_csv_12ParseOptions_delimiter, __pyx_setprop_7pyarrow_4_csv_12ParseOptions_delimiter, (char *)"\n        The character delimiting individual cells in the CSV data.\n        ", 0},
  {(char *)"quote_char", __pyx_getprop_7pyarrow_4_csv_12ParseOptions_quote_char, __pyx_setprop_7pyarrow_4_csv_12ParseOptions_quote_char, (char *)"\n        The character used optionally for quoting CSV values\n        (False if quoting is not allowed).\n        ", 0},
  {(char *)"double_quote", __pyx_getprop_7pyarrow_4_csv_12ParseOptions_double_quote, __pyx_setprop_7pyarrow_4_csv_12ParseOptions_double_quote, (char *)"\n        Whether two quotes in a quoted CSV value denote a single quote\n        in the data.\n        ", 0},
  {(char *)"escape_char", __pyx_getprop_7pyarrow_4_csv_12ParseOptions_escape_char, __pyx_setprop_7pyarrow_4_csv_12ParseOptions_escape_char, (char *)"\n        The character used optionally for escaping special characters\n        (False if escaping is not allowed).\n        ", 0},
  {(char *)"newlines_in_values", __pyx_getprop_7pyarrow_4_csv_12ParseOptions_newlines_in_values, __pyx_setprop_7pyarrow_4_csv_12ParseOptions_newlines_in_values, (char *)"\n        Whether newline characters are allowed in CSV values.\n        Setting this to True reduces the performance of multi-threaded\n        CSV reading.\n        ", 0},
  {(char *)"ignore_empty_lines", __pyx_getprop_7pyarrow_4_csv_12ParseOptions_ignore_empty_lines, __pyx_setprop_7pyarrow_4_csv_12ParseOptions_ignore_empty_lines, (char *)"\n        Whether empty lines are ignored in CSV input.\n        If False, an empty line is interpreted as containing a single empty\n        value (assuming a one-column CSV file).\n        ", 0},
  {0, 0, 0, 0, 0}
};

static PyTypeObject __pyx_type_7pyarrow_4_csv_ParseOptions = {
  PyVarObject_HEAD_INIT(0, 0)
  "pyarrow._csv.ParseOptions", /*tp_name*/
  sizeof(struct __pyx_obj_7pyarrow_4_csv_ParseOptions), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_7pyarrow_4_csv_ParseOptions, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "ParseOptions(delimiter=None, quote_char=None, double_quote=None, escape_char=None, newlines_in_values=None, ignore_empty_lines=None)\n\n    Options for parsing CSV files.\n\n    Parameters\n    ----------\n    delimiter: 1-character string, optional (default ',')\n        The character delimiting individual cells in the CSV data.\n    quote_char: 1-character string or False, optional (default '\"')\n        The character used optionally for quoting CSV values\n        (False if quoting is not allowed).\n    double_quote: bool, optional (default True)\n        Whether two quotes in a quoted CSV value denote a single quote\n        in the data.\n    escape_char: 1-character string or False, optional (default False)\n        The character used optionally for escaping special characters\n        (False if escaping is not allowed).\n    newlines_in_values: bool, optional (default False)\n        Whether newline characters are allowed in CSV values.\n        Setting this to True reduces the performance of multi-threaded\n        CSV reading.\n    ignore_empty_lines: bool, optional (default True)\n        Whether empty lines are ignored in CSV input.\n        If False, an empty line is interpreted as containing a single empty\n        value (assuming a one-column CSV file).\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_7pyarrow_4_csv_ParseOptions, /*tp_methods*/
  0, /*tp_members*/
  __pyx_getsets_7pyarrow_4_csv_ParseOptions, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_7pyarrow_4_csv_12ParseOptions_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_7pyarrow_4_csv_ParseOptions, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
};

static PyObject *__pyx_tp_new_7pyarrow_4_csv_ConvertOptions(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)o);
  new((void*)&(p->options))  arrow::csv::ConvertOptions();
  return o;
}

static void __pyx_tp_dealloc_7pyarrow_4_csv_ConvertOptions(PyObject *o) {
  struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *p = (struct __pyx_obj_7pyarrow_4_csv_ConvertOptions *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->options);
  (*Py_TYPE(o)->tp_free)(o);
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_14ConvertOptions_check_utf8(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_10check_utf8_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_check_utf8(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_10check_utf8_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_14ConvertOptions_strings_can_be_null(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_19strings_can_be_null_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_strings_can_be_null(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_19strings_can_be_null_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_14ConvertOptions_column_types(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_12column_types_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_column_types(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_12column_types_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_14ConvertOptions_null_values(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_11null_values_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_null_values(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_11null_values_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_14ConvertOptions_true_values(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_11true_values_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_true_values(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_11true_values_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_14ConvertOptions_false_values(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_12false_values_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_false_values(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_12false_values_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_14ConvertOptions_auto_dict_encode(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_16auto_dict_encode_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_auto_dict_encode(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_16auto_dict_encode_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_14ConvertOptions_auto_dict_max_cardinality(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_25auto_dict_max_cardinality_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_auto_dict_max_cardinality(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_25auto_dict_max_cardinality_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_14ConvertOptions_include_columns(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_15include_columns_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_include_columns(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_15include_columns_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_7pyarrow_4_csv_14ConvertOptions_include_missing_columns(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_23include_missing_columns_1__get__(o);
}

static int __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_include_missing_columns(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_7pyarrow_4_csv_14ConvertOptions_23include_missing_columns_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyMethodDef __pyx_methods_7pyarrow_4_csv_ConvertOptions[] = {
  {"__reduce_cython__", (PyCFunction)__pyx_pw_7pyarrow_4_csv_14ConvertOptions_3__reduce_cython__, METH_NOARGS, __pyx_doc_7pyarrow_4_csv_14ConvertOptions_2__reduce_cython__},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_7pyarrow_4_csv_14ConvertOptions_5__setstate_cython__, METH_O, __pyx_doc_7pyarrow_4_csv_14ConvertOptions_4__setstate_cython__},
  {0, 0, 0, 0}
};

static struct PyGetSetDef __pyx_getsets_7pyarrow_4_csv_ConvertOptions[] = {
  {(char *)"check_utf8", __pyx_getprop_7pyarrow_4_csv_14ConvertOptions_check_utf8, __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_check_utf8, (char *)"\n        Whether to check UTF8 validity of string columns.\n        ", 0},
  {(char *)"strings_can_be_null", __pyx_getprop_7pyarrow_4_csv_14ConvertOptions_strings_can_be_null, __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_strings_can_be_null, (char *)"\n        Whether string / binary columns can have null values.\n        ", 0},
  {(char *)"column_types", __pyx_getprop_7pyarrow_4_csv_14ConvertOptions_column_types, __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_column_types, (char *)"\n        Map column names to column types\n        (disabling type inference on those columns).\n        ", 0},
  {(char *)"null_values", __pyx_getprop_7pyarrow_4_csv_14ConvertOptions_null_values, __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_null_values, (char *)"\n        A sequence of strings that denote nulls in the data.\n        ", 0},
  {(char *)"true_values", __pyx_getprop_7pyarrow_4_csv_14ConvertOptions_true_values, __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_true_values, (char *)"\n        A sequence of strings that denote true booleans in the data.\n        ", 0},
  {(char *)"false_values", __pyx_getprop_7pyarrow_4_csv_14ConvertOptions_false_values, __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_false_values, (char *)"\n        A sequence of strings that denote false booleans in the data.\n        ", 0},
  {(char *)"auto_dict_encode", __pyx_getprop_7pyarrow_4_csv_14ConvertOptions_auto_dict_encode, __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_auto_dict_encode, (char *)"\n        Whether to try to automatically dict-encode string / binary data.\n        ", 0},
  {(char *)"auto_dict_max_cardinality", __pyx_getprop_7pyarrow_4_csv_14ConvertOptions_auto_dict_max_cardinality, __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_auto_dict_max_cardinality, (char *)"\n        The maximum dictionary cardinality for `auto_dict_encode`.\n\n        This value is per chunk.\n        ", 0},
  {(char *)"include_columns", __pyx_getprop_7pyarrow_4_csv_14ConvertOptions_include_columns, __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_include_columns, (char *)"\n        The names of columns to include in the Table.\n\n        If empty, the Table will include all columns from the CSV file.\n        If not empty, only these columns will be included, in this order.\n        ", 0},
  {(char *)"include_missing_columns", __pyx_getprop_7pyarrow_4_csv_14ConvertOptions_include_missing_columns, __pyx_setprop_7pyarrow_4_csv_14ConvertOptions_include_missing_columns, (char *)"\n        If false, columns in `include_columns` but not in the CSV file will\n        error out.\n        If true, columns in `include_columns` but not in the CSV file will\n        produce a null column (whose type is selected using `column_types`,\n        or null by default).\n        This option is ignored if `include_columns` is empty.\n        ", 0},
  {0, 0, 0, 0, 0}
};

static PyTypeObject __pyx_type_7pyarrow_4_csv_ConvertOptions = {
  PyVarObject_HEAD_INIT(0, 0)
  "pyarrow._csv.ConvertOptions", /*tp_name*/
  sizeof(struct __pyx_obj_7pyarrow_4_csv_ConvertOptions), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_7pyarrow_4_csv_ConvertOptions, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "ConvertOptions(check_utf8=None, column_types=None, null_values=None, true_values=None, false_values=None, strings_can_be_null=None, include_columns=None, include_missing_columns=None, auto_dict_encode=None, auto_dict_max_cardinality=None)\n\n    Options for converting CSV data.\n\n    Parameters\n    ----------\n    check_utf8 : bool, optional (default True)\n        Whether to check UTF8 validity of string columns.\n    column_types: dict, optional\n        Map column names to column types\n        (disabling type inference on those columns).\n    null_values: list, optional\n        A sequence of strings that denote nulls in the data\n        (defaults are appropriate in most cases).\n    true_values: list, optional\n        A sequence of strings that denote true booleans in the data\n        (defaults are appropriate in most cases).\n    false_values: list, optional\n        A sequence of strings that denote false booleans in the data\n        (defaults are appropriate in most cases).\n    strings_can_be_null: bool, optional (default False)\n        Whether string / binary columns can have null values.\n        If true, then strings in null_values are considered null for\n        string columns.\n        If false, then all strings are valid string values.\n\n    auto_dict_encode: bool, optional (default False)\n        Whether to try to automatically dict-encode string / binary data.\n        If true, then when type inference detects a string or binary column,\n        it it dict-encoded up to `auto_dict_max_cardinality` distinct values\n        (per chunk), after which it switches to regular encoding.\n        This setting is ignored for non-inferred columns (those in\n        `column_types`).\n    auto_dict_max_cardinality: int, optional\n        The maximum dictionary cardinality for `auto_dict_encode`.\n        This value is per chunk.\n\n    include_columns: list, optional\n        The names of columns to include in the Table.\n        If empty, the Table wi""ll include all columns from the CSV file.\n        If not empty, only these columns will be included, in this order.\n    include_missing_columns: bool, optional (default False)\n        If false, columns in `include_columns` but not in the CSV file will\n        error out.\n        If true, columns in `include_columns` but not in the CSV file will\n        produce a column of nulls (whose type is selected using\n        `column_types`, or null by default).\n        This option is ignored if `include_columns` is empty.\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_7pyarrow_4_csv_ConvertOptions, /*tp_methods*/
  0, /*tp_members*/
  __pyx_getsets_7pyarrow_4_csv_ConvertOptions, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_7pyarrow_4_csv_14ConvertOptions_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_7pyarrow_4_csv_ConvertOptions, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
};

static PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
#if CYTHON_PEP489_MULTI_PHASE_INIT
static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
static int __pyx_pymod_exec__csv(PyObject* module); /*proto*/
static PyModuleDef_Slot __pyx_moduledef_slots[] = {
  {Py_mod_create, (void*)__pyx_pymod_create},
  {Py_mod_exec, (void*)__pyx_pymod_exec__csv},
  {0, NULL}
};
#endif

static struct PyModuleDef __pyx_moduledef = {
    PyModuleDef_HEAD_INIT,
    "_csv",
    0, /* m_doc */
  #if CYTHON_PEP489_MULTI_PHASE_INIT
    0, /* m_size */
  #else
    -1, /* m_size */
  #endif
    __pyx_methods /* m_methods */,
  #if CYTHON_PEP489_MULTI_PHASE_INIT
    __pyx_moduledef_slots, /* m_slots */
  #else
    NULL, /* m_reload */
  #endif
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif
#ifndef CYTHON_SMALL_CODE
#if defined(__clang__)
    #define CYTHON_SMALL_CODE
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))
    #define CYTHON_SMALL_CODE __attribute__((cold))
#else
    #define CYTHON_SMALL_CODE
#endif
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_n_s_ConvertOptions, __pyx_k_ConvertOptions, sizeof(__pyx_k_ConvertOptions), 0, 0, 1, 1},
  {&__pyx_kp_u_Expecting_an_ASCII_character, __pyx_k_Expecting_an_ASCII_character, sizeof(__pyx_k_Expecting_an_ASCII_character), 0, 1, 0, 0},
  {&__pyx_n_s_Mapping, __pyx_k_Mapping, sizeof(__pyx_k_Mapping), 0, 0, 1, 1},
  {&__pyx_n_s_ParseOptions, __pyx_k_ParseOptions, sizeof(__pyx_k_ParseOptions), 0, 0, 1, 1},
  {&__pyx_n_s_ReadOptions, __pyx_k_ReadOptions, sizeof(__pyx_k_ReadOptions), 0, 0, 1, 1},
  {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
  {&__pyx_n_s_auto_dict_encode, __pyx_k_auto_dict_encode, sizeof(__pyx_k_auto_dict_encode), 0, 0, 1, 1},
  {&__pyx_n_s_auto_dict_max_cardinality, __pyx_k_auto_dict_max_cardinality, sizeof(__pyx_k_auto_dict_max_cardinality), 0, 0, 1, 1},
  {&__pyx_n_s_autogenerate_column_names, __pyx_k_autogenerate_column_names, sizeof(__pyx_k_autogenerate_column_names), 0, 0, 1, 1},
  {&__pyx_n_s_block_size, __pyx_k_block_size, sizeof(__pyx_k_block_size), 0, 0, 1, 1},
  {&__pyx_n_s_c_convert_options, __pyx_k_c_convert_options, sizeof(__pyx_k_c_convert_options), 0, 0, 1, 1},
  {&__pyx_n_s_c_parse_options, __pyx_k_c_parse_options, sizeof(__pyx_k_c_parse_options), 0, 0, 1, 1},
  {&__pyx_n_s_c_read_options, __pyx_k_c_read_options, sizeof(__pyx_k_c_read_options), 0, 0, 1, 1},
  {&__pyx_n_s_check_utf8, __pyx_k_check_utf8, sizeof(__pyx_k_check_utf8), 0, 0, 1, 1},
  {&__pyx_n_s_chr, __pyx_k_chr, sizeof(__pyx_k_chr), 0, 0, 1, 1},
  {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
  {&__pyx_n_s_column_names, __pyx_k_column_names, sizeof(__pyx_k_column_names), 0, 0, 1, 1},
  {&__pyx_n_s_column_types, __pyx_k_column_types, sizeof(__pyx_k_column_types), 0, 0, 1, 1},
  {&__pyx_n_s_convert_options, __pyx_k_convert_options, sizeof(__pyx_k_convert_options), 0, 0, 1, 1},
  {&__pyx_n_s_delimiter, __pyx_k_delimiter, sizeof(__pyx_k_delimiter), 0, 0, 1, 1},
  {&__pyx_n_s_double_quote, __pyx_k_double_quote, sizeof(__pyx_k_double_quote), 0, 0, 1, 1},
  {&__pyx_n_s_escape_char, __pyx_k_escape_char, sizeof(__pyx_k_escape_char), 0, 0, 1, 1},
  {&__pyx_n_s_false_values, __pyx_k_false_values, sizeof(__pyx_k_false_values), 0, 0, 1, 1},
  {&__pyx_n_s_frombytes, __pyx_k_frombytes, sizeof(__pyx_k_frombytes), 0, 0, 1, 1},
  {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
  {&__pyx_n_s_ignore_empty_lines, __pyx_k_ignore_empty_lines, sizeof(__pyx_k_ignore_empty_lines), 0, 0, 1, 1},
  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
  {&__pyx_n_s_include_columns, __pyx_k_include_columns, sizeof(__pyx_k_include_columns), 0, 0, 1, 1},
  {&__pyx_n_s_include_missing_columns, __pyx_k_include_missing_columns, sizeof(__pyx_k_include_missing_columns), 0, 0, 1, 1},
  {&__pyx_n_s_input_file, __pyx_k_input_file, sizeof(__pyx_k_input_file), 0, 0, 1, 1},
  {&__pyx_n_s_items, __pyx_k_items, sizeof(__pyx_k_items), 0, 0, 1, 1},
  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
  {&__pyx_n_s_memory_pool, __pyx_k_memory_pool, sizeof(__pyx_k_memory_pool), 0, 0, 1, 1},
  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
  {&__pyx_n_s_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 0, 1, 1},
  {&__pyx_n_s_newlines_in_values, __pyx_k_newlines_in_values, sizeof(__pyx_k_newlines_in_values), 0, 0, 1, 1},
  {&__pyx_n_s_null_values, __pyx_k_null_values, sizeof(__pyx_k_null_values), 0, 0, 1, 1},
  {&__pyx_n_s_parse_options, __pyx_k_parse_options, sizeof(__pyx_k_parse_options), 0, 0, 1, 1},
  {&__pyx_n_s_pyarrow__csv, __pyx_k_pyarrow__csv, sizeof(__pyx_k_pyarrow__csv), 0, 0, 1, 1},
  {&__pyx_kp_s_pyarrow__csv_pyx, __pyx_k_pyarrow__csv_pyx, sizeof(__pyx_k_pyarrow__csv_pyx), 0, 0, 1, 0},
  {&__pyx_n_s_pyarrow_compat, __pyx_k_pyarrow_compat, sizeof(__pyx_k_pyarrow_compat), 0, 0, 1, 1},
  {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
  {&__pyx_n_s_quote_char, __pyx_k_quote_char, sizeof(__pyx_k_quote_char), 0, 0, 1, 1},
  {&__pyx_n_s_read_csv, __pyx_k_read_csv, sizeof(__pyx_k_read_csv), 0, 0, 1, 1},
  {&__pyx_n_s_read_options, __pyx_k_read_options, sizeof(__pyx_k_read_options), 0, 0, 1, 1},
  {&__pyx_n_s_reader, __pyx_k_reader, sizeof(__pyx_k_reader), 0, 0, 1, 1},
  {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
  {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
  {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
  {&__pyx_kp_s_self_options_cannot_be_converted, __pyx_k_self_options_cannot_be_converted, sizeof(__pyx_k_self_options_cannot_be_converted), 0, 0, 1, 0},
  {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
  {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
  {&__pyx_n_s_skip_rows, __pyx_k_skip_rows, sizeof(__pyx_k_skip_rows), 0, 0, 1, 1},
  {&__pyx_n_s_slots, __pyx_k_slots, sizeof(__pyx_k_slots), 0, 0, 1, 1},
  {&__pyx_n_s_stream, __pyx_k_stream, sizeof(__pyx_k_stream), 0, 0, 1, 1},
  {&__pyx_n_s_strings_can_be_null, __pyx_k_strings_can_be_null, sizeof(__pyx_k_strings_can_be_null), 0, 0, 1, 1},
  {&__pyx_n_s_table, __pyx_k_table, sizeof(__pyx_k_table), 0, 0, 1, 1},
  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
  {&__pyx_n_s_tobytes, __pyx_k_tobytes, sizeof(__pyx_k_tobytes), 0, 0, 1, 1},
  {&__pyx_n_s_true_values, __pyx_k_true_values, sizeof(__pyx_k_true_values), 0, 0, 1, 1},
  {&__pyx_n_s_type, __pyx_k_type, sizeof(__pyx_k_type), 0, 0, 1, 1},
  {&__pyx_n_s_use_threads, __pyx_k_use_threads, sizeof(__pyx_k_use_threads), 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 38, __pyx_L1_error)
  __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(1, 2, __pyx_L1_error)
  __pyx_builtin_chr = __Pyx_GetBuiltinName(__pyx_n_s_chr); if (!__pyx_builtin_chr) __PYX_ERR(0, 204, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "pyarrow/_csv.pyx":38
 *     val = ord(s)
 *     if val == 0 or val > 127:
 *         raise ValueError("Expecting an ASCII character")             # <<<<<<<<<<<<<<
 *     return <unsigned char> val
 * 
 */
  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_u_Expecting_an_ASCII_character); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 38, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple_);
  __Pyx_GIVEREF(__pyx_tuple_);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_self_options_cannot_be_converted); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__2);
  __Pyx_GIVEREF(__pyx_tuple__2);

  /* "(tree fragment)":4
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_self_options_cannot_be_converted); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__3);
  __Pyx_GIVEREF(__pyx_tuple__3);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_self_options_cannot_be_converted); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__4);
  __Pyx_GIVEREF(__pyx_tuple__4);

  /* "(tree fragment)":4
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_self_options_cannot_be_converted); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__5);
  __Pyx_GIVEREF(__pyx_tuple__5);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_s_self_options_cannot_be_converted); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__6);
  __Pyx_GIVEREF(__pyx_tuple__6);

  /* "(tree fragment)":4
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self.options cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_s_self_options_cannot_be_converted); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__7);
  __Pyx_GIVEREF(__pyx_tuple__7);

  /* "pyarrow/_csv.pyx":537
 * 
 * 
 * def read_csv(input_file, read_options=None, parse_options=None,             # <<<<<<<<<<<<<<
 *              convert_options=None, MemoryPool memory_pool=None):
 *     """
 */
  __pyx_tuple__8 = PyTuple_Pack(11, __pyx_n_s_input_file, __pyx_n_s_read_options, __pyx_n_s_parse_options, __pyx_n_s_convert_options, __pyx_n_s_memory_pool, __pyx_n_s_stream, __pyx_n_s_c_read_options, __pyx_n_s_c_parse_options, __pyx_n_s_c_convert_options, __pyx_n_s_reader, __pyx_n_s_table); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(0, 537, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__8);
  __Pyx_GIVEREF(__pyx_tuple__8);
  __pyx_codeobj__9 = (PyObject*)__Pyx_PyCode_New(5, 0, 11, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__8, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyarrow__csv_pyx, __pyx_n_s_read_csv, 537, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__9)) __PYX_ERR(0, 537, __pyx_L1_error)
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
  return 0;
  __pyx_L1_error:;
  return -1;
}

static CYTHON_SMALL_CODE int __Pyx_modinit_global_init_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_variable_export_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_function_export_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_type_init_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_type_import_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_variable_import_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_function_import_code(void); /*proto*/

static int __Pyx_modinit_global_init_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_global_init_code", 0);
  /*--- Global init code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_variable_export_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_variable_export_code", 0);
  /*--- Variable export code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_function_export_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_function_export_code", 0);
  /*--- Function export code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_type_init_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
  /*--- Type init code ---*/
  if (PyType_Ready(&__pyx_type_7pyarrow_4_csv_ReadOptions) < 0) __PYX_ERR(0, 42, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_7pyarrow_4_csv_ReadOptions.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_7pyarrow_4_csv_ReadOptions.tp_dictoffset && __pyx_type_7pyarrow_4_csv_ReadOptions.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_7pyarrow_4_csv_ReadOptions.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_ReadOptions, (PyObject *)&__pyx_type_7pyarrow_4_csv_ReadOptions) < 0) __PYX_ERR(0, 42, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_7pyarrow_4_csv_ReadOptions) < 0) __PYX_ERR(0, 42, __pyx_L1_error)
  __pyx_ptype_7pyarrow_4_csv_ReadOptions = &__pyx_type_7pyarrow_4_csv_ReadOptions;
  if (PyType_Ready(&__pyx_type_7pyarrow_4_csv_ParseOptions) < 0) __PYX_ERR(0, 151, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_7pyarrow_4_csv_ParseOptions.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_7pyarrow_4_csv_ParseOptions.tp_dictoffset && __pyx_type_7pyarrow_4_csv_ParseOptions.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_7pyarrow_4_csv_ParseOptions.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_ParseOptions, (PyObject *)&__pyx_type_7pyarrow_4_csv_ParseOptions) < 0) __PYX_ERR(0, 151, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_7pyarrow_4_csv_ParseOptions) < 0) __PYX_ERR(0, 151, __pyx_L1_error)
  __pyx_ptype_7pyarrow_4_csv_ParseOptions = &__pyx_type_7pyarrow_4_csv_ParseOptions;
  if (PyType_Ready(&__pyx_type_7pyarrow_4_csv_ConvertOptions) < 0) __PYX_ERR(0, 287, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_7pyarrow_4_csv_ConvertOptions.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_7pyarrow_4_csv_ConvertOptions.tp_dictoffset && __pyx_type_7pyarrow_4_csv_ConvertOptions.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_7pyarrow_4_csv_ConvertOptions.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_ConvertOptions, (PyObject *)&__pyx_type_7pyarrow_4_csv_ConvertOptions) < 0) __PYX_ERR(0, 287, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_7pyarrow_4_csv_ConvertOptions) < 0) __PYX_ERR(0, 287, __pyx_L1_error)
  __pyx_ptype_7pyarrow_4_csv_ConvertOptions = &__pyx_type_7pyarrow_4_csv_ConvertOptions;
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_modinit_type_import_code(void) {
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
  /*--- Type import code ---*/
  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 9, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
  #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000
  sizeof(PyTypeObject),
  #else
  sizeof(PyHeapTypeObject),
  #endif
  __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(3, 9, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 8, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "bool", sizeof(PyBoolObject), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7cpython_4bool_bool) __PYX_ERR(4, 8, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(5, 15, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "complex", sizeof(PyComplexObject), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7cpython_7complex_complex) __PYX_ERR(5, 15, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyImport_ImportModule("datetime"); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 9, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_ptype_7cpython_8datetime_date = __Pyx_ImportType(__pyx_t_1, "datetime", "date", sizeof(PyDateTime_Date), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7cpython_8datetime_date) __PYX_ERR(2, 9, __pyx_L1_error)
  __pyx_ptype_7cpython_8datetime_time = __Pyx_ImportType(__pyx_t_1, "datetime", "time", sizeof(PyDateTime_Time), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7cpython_8datetime_time) __PYX_ERR(2, 12, __pyx_L1_error)
  __pyx_ptype_7cpython_8datetime_datetime = __Pyx_ImportType(__pyx_t_1, "datetime", "datetime", sizeof(PyDateTime_DateTime), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7cpython_8datetime_datetime) __PYX_ERR(2, 15, __pyx_L1_error)
  __pyx_ptype_7cpython_8datetime_timedelta = __Pyx_ImportType(__pyx_t_1, "datetime", "timedelta", sizeof(PyDateTime_Delta), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7cpython_8datetime_timedelta) __PYX_ERR(2, 18, __pyx_L1_error)
  __pyx_ptype_7cpython_8datetime_tzinfo = __Pyx_ImportType(__pyx_t_1, "datetime", "tzinfo", sizeof(PyDateTime_TZInfo), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7cpython_8datetime_tzinfo) __PYX_ERR(2, 21, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyImport_ImportModule("pyarrow.lib"); if (unlikely(!__pyx_t_1)) __PYX_ERR(6, 36, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_ptype_7pyarrow_3lib_Message = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "Message", sizeof(struct __pyx_obj_7pyarrow_3lib_Message), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_Message) __PYX_ERR(6, 36, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_MemoryPool = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "MemoryPool", sizeof(struct __pyx_obj_7pyarrow_3lib_MemoryPool), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_MemoryPool) __PYX_ERR(6, 41, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_MemoryPool = (struct __pyx_vtabstruct_7pyarrow_3lib_MemoryPool*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_MemoryPool->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_MemoryPool)) __PYX_ERR(6, 41, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_DataType = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "DataType", sizeof(struct __pyx_obj_7pyarrow_3lib_DataType), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_DataType) __PYX_ERR(6, 51, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_DataType = (struct __pyx_vtabstruct_7pyarrow_3lib_DataType*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_DataType->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_DataType)) __PYX_ERR(6, 51, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_ListType = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "ListType", sizeof(struct __pyx_obj_7pyarrow_3lib_ListType), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_ListType) __PYX_ERR(6, 62, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_ListType = (struct __pyx_vtabstruct_7pyarrow_3lib_ListType*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_ListType->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_ListType)) __PYX_ERR(6, 62, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_LargeListType = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "LargeListType", sizeof(struct __pyx_obj_7pyarrow_3lib_LargeListType), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_LargeListType) __PYX_ERR(6, 67, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_LargeListType = (struct __pyx_vtabstruct_7pyarrow_3lib_LargeListType*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_LargeListType->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_LargeListType)) __PYX_ERR(6, 67, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_MapType = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "MapType", sizeof(struct __pyx_obj_7pyarrow_3lib_MapType), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_MapType) __PYX_ERR(6, 72, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_MapType = (struct __pyx_vtabstruct_7pyarrow_3lib_MapType*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_MapType->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_MapType)) __PYX_ERR(6, 72, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_FixedSizeListType = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "FixedSizeListType", sizeof(struct __pyx_obj_7pyarrow_3lib_FixedSizeListType), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_FixedSizeListType) __PYX_ERR(6, 77, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_FixedSizeListType = (struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeListType*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_FixedSizeListType->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_FixedSizeListType)) __PYX_ERR(6, 77, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_StructType = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "StructType", sizeof(struct __pyx_obj_7pyarrow_3lib_StructType), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_StructType) __PYX_ERR(6, 82, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_StructType = (struct __pyx_vtabstruct_7pyarrow_3lib_StructType*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_StructType->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_StructType)) __PYX_ERR(6, 82, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_DictionaryMemo = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "DictionaryMemo", sizeof(struct __pyx_obj_7pyarrow_3lib_DictionaryMemo), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_DictionaryMemo) __PYX_ERR(6, 90, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_DictionaryType = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "DictionaryType", sizeof(struct __pyx_obj_7pyarrow_3lib_DictionaryType), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_DictionaryType) __PYX_ERR(6, 98, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_DictionaryType = (struct __pyx_vtabstruct_7pyarrow_3lib_DictionaryType*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_DictionaryType->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_DictionaryType)) __PYX_ERR(6, 98, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_TimestampType = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "TimestampType", sizeof(struct __pyx_obj_7pyarrow_3lib_TimestampType), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_TimestampType) __PYX_ERR(6, 103, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_TimestampType = (struct __pyx_vtabstruct_7pyarrow_3lib_TimestampType*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_TimestampType->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_TimestampType)) __PYX_ERR(6, 103, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_Time32Type = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "Time32Type", sizeof(struct __pyx_obj_7pyarrow_3lib_Time32Type), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_Time32Type) __PYX_ERR(6, 108, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_Time32Type = (struct __pyx_vtabstruct_7pyarrow_3lib_Time32Type*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_Time32Type->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_Time32Type)) __PYX_ERR(6, 108, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_Time64Type = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "Time64Type", sizeof(struct __pyx_obj_7pyarrow_3lib_Time64Type), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_Time64Type) __PYX_ERR(6, 113, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_Time64Type = (struct __pyx_vtabstruct_7pyarrow_3lib_Time64Type*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_Time64Type->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_Time64Type)) __PYX_ERR(6, 113, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_DurationType = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "DurationType", sizeof(struct __pyx_obj_7pyarrow_3lib_DurationType), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_DurationType) __PYX_ERR(6, 118, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_DurationType = (struct __pyx_vtabstruct_7pyarrow_3lib_DurationType*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_DurationType->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_DurationType)) __PYX_ERR(6, 118, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_FixedSizeBinaryType = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "FixedSizeBinaryType", sizeof(struct __pyx_obj_7pyarrow_3lib_FixedSizeBinaryType), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_FixedSizeBinaryType) __PYX_ERR(6, 123, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_FixedSizeBinaryType = (struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeBinaryType*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_FixedSizeBinaryType->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_FixedSizeBinaryType)) __PYX_ERR(6, 123, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_Decimal128Type = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "Decimal128Type", sizeof(struct __pyx_obj_7pyarrow_3lib_Decimal128Type), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_Decimal128Type) __PYX_ERR(6, 128, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_Decimal128Type = (struct __pyx_vtabstruct_7pyarrow_3lib_Decimal128Type*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_Decimal128Type->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_Decimal128Type)) __PYX_ERR(6, 128, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_BaseExtensionType = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "BaseExtensionType", sizeof(struct __pyx_obj_7pyarrow_3lib_BaseExtensionType), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_BaseExtensionType) __PYX_ERR(6, 133, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_BaseExtensionType = (struct __pyx_vtabstruct_7pyarrow_3lib_BaseExtensionType*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_BaseExtensionType->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_BaseExtensionType)) __PYX_ERR(6, 133, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_ExtensionType = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "ExtensionType", sizeof(struct __pyx_obj_7pyarrow_3lib_ExtensionType), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_ExtensionType) __PYX_ERR(6, 138, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_ExtensionType = (struct __pyx_vtabstruct_7pyarrow_3lib_ExtensionType*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_ExtensionType->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_ExtensionType)) __PYX_ERR(6, 138, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_PyExtensionType = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "PyExtensionType", sizeof(struct __pyx_obj_7pyarrow_3lib_PyExtensionType), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_PyExtensionType) __PYX_ERR(6, 143, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_PyExtensionType = (struct __pyx_vtabstruct_7pyarrow_3lib_PyExtensionType*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_PyExtensionType->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_PyExtensionType)) __PYX_ERR(6, 143, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_Field = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "Field", sizeof(struct __pyx_obj_7pyarrow_3lib_Field), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_Field) __PYX_ERR(6, 147, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_Field = (struct __pyx_vtabstruct_7pyarrow_3lib_Field*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_Field->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_Field)) __PYX_ERR(6, 147, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_Schema = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "Schema", sizeof(struct __pyx_obj_7pyarrow_3lib_Schema), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_Schema) __PYX_ERR(6, 158, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_Schema = (struct __pyx_vtabstruct_7pyarrow_3lib_Schema*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_Schema->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_Schema)) __PYX_ERR(6, 158, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_Scalar = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "Scalar", sizeof(struct __pyx_obj_7pyarrow_3lib_Scalar), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_Scalar) __PYX_ERR(6, 167, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_NAType = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "NAType", sizeof(struct __pyx_obj_7pyarrow_3lib_NAType), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_NAType) __PYX_ERR(6, 172, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_ArrayValue = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "ArrayValue", sizeof(struct __pyx_obj_7pyarrow_3lib_ArrayValue), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_ArrayValue) __PYX_ERR(6, 176, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_ArrayValue = (struct __pyx_vtabstruct_7pyarrow_3lib_ArrayValue*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_ArrayValue->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_ArrayValue)) __PYX_ERR(6, 176, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_ScalarValue = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "ScalarValue", sizeof(struct __pyx_obj_7pyarrow_3lib_ScalarValue), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_ScalarValue) __PYX_ERR(6, 186, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_ScalarValue = (struct __pyx_vtabstruct_7pyarrow_3lib_ScalarValue*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_ScalarValue->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_ScalarValue)) __PYX_ERR(6, 186, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_Int8Value = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "Int8Value", sizeof(struct __pyx_obj_7pyarrow_3lib_Int8Value), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_Int8Value) __PYX_ERR(6, 192, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_Int8Value = (struct __pyx_vtabstruct_7pyarrow_3lib_Int8Value*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_Int8Value->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_Int8Value)) __PYX_ERR(6, 192, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_Int64Value = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "Int64Value", sizeof(struct __pyx_obj_7pyarrow_3lib_Int64Value), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_Int64Value) __PYX_ERR(6, 196, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_Int64Value = (struct __pyx_vtabstruct_7pyarrow_3lib_Int64Value*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_Int64Value->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_Int64Value)) __PYX_ERR(6, 196, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_ListValue = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "ListValue", sizeof(struct __pyx_obj_7pyarrow_3lib_ListValue), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_ListValue) __PYX_ERR(6, 200, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_ListValue = (struct __pyx_vtabstruct_7pyarrow_3lib_ListValue*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_ListValue->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_ListValue)) __PYX_ERR(6, 200, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_LargeListValue = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "LargeListValue", sizeof(struct __pyx_obj_7pyarrow_3lib_LargeListValue), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_LargeListValue) __PYX_ERR(6, 211, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_LargeListValue = (struct __pyx_vtabstruct_7pyarrow_3lib_LargeListValue*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_LargeListValue->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_LargeListValue)) __PYX_ERR(6, 211, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_MapValue = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "MapValue", sizeof(struct __pyx_obj_7pyarrow_3lib_MapValue), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_MapValue) __PYX_ERR(6, 222, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_MapValue = (struct __pyx_vtabstruct_7pyarrow_3lib_MapValue*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_MapValue->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_MapValue)) __PYX_ERR(6, 222, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_FixedSizeListValue = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "FixedSizeListValue", sizeof(struct __pyx_obj_7pyarrow_3lib_FixedSizeListValue), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_FixedSizeListValue) __PYX_ERR(6, 234, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_FixedSizeListValue = (struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeListValue*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_FixedSizeListValue->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_FixedSizeListValue)) __PYX_ERR(6, 234, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_StructValue = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "StructValue", sizeof(struct __pyx_obj_7pyarrow_3lib_StructValue), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_StructValue) __PYX_ERR(6, 245, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_StructValue = (struct __pyx_vtabstruct_7pyarrow_3lib_StructValue*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_StructValue->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_StructValue)) __PYX_ERR(6, 245, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_UnionValue = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "UnionValue", sizeof(struct __pyx_obj_7pyarrow_3lib_UnionValue), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_UnionValue) __PYX_ERR(6, 250, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_UnionValue = (struct __pyx_vtabstruct_7pyarrow_3lib_UnionValue*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_UnionValue->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_UnionValue)) __PYX_ERR(6, 250, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_StringValue = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "StringValue", sizeof(struct __pyx_obj_7pyarrow_3lib_StringValue), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_StringValue) __PYX_ERR(6, 258, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_StringValue = (struct __pyx_vtabstruct_7pyarrow_3lib_StringValue*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_StringValue->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_StringValue)) __PYX_ERR(6, 258, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_FixedSizeBinaryValue = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "FixedSizeBinaryValue", sizeof(struct __pyx_obj_7pyarrow_3lib_FixedSizeBinaryValue), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_FixedSizeBinaryValue) __PYX_ERR(6, 262, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_FixedSizeBinaryValue = (struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeBinaryValue*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_FixedSizeBinaryValue->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_FixedSizeBinaryValue)) __PYX_ERR(6, 262, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib__PandasConvertible = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "_PandasConvertible", sizeof(struct __pyx_obj_7pyarrow_3lib__PandasConvertible), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib__PandasConvertible) __PYX_ERR(6, 266, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_Array = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "Array", sizeof(struct __pyx_obj_7pyarrow_3lib_Array), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_Array) __PYX_ERR(6, 270, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_Array = (struct __pyx_vtabstruct_7pyarrow_3lib_Array*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_Array->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_Array)) __PYX_ERR(6, 270, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_Tensor = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "Tensor", sizeof(struct __pyx_obj_7pyarrow_3lib_Tensor), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_Tensor) __PYX_ERR(6, 286, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_Tensor = (struct __pyx_vtabstruct_7pyarrow_3lib_Tensor*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_Tensor->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_Tensor)) __PYX_ERR(6, 286, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_SparseCSRMatrix = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "SparseCSRMatrix", sizeof(struct __pyx_obj_7pyarrow_3lib_SparseCSRMatrix), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_SparseCSRMatrix) __PYX_ERR(6, 297, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_SparseCSRMatrix = (struct __pyx_vtabstruct_7pyarrow_3lib_SparseCSRMatrix*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_SparseCSRMatrix->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_SparseCSRMatrix)) __PYX_ERR(6, 297, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_SparseCOOTensor = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "SparseCOOTensor", sizeof(struct __pyx_obj_7pyarrow_3lib_SparseCOOTensor), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_SparseCOOTensor) __PYX_ERR(6, 308, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_SparseCOOTensor = (struct __pyx_vtabstruct_7pyarrow_3lib_SparseCOOTensor*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_SparseCOOTensor->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_SparseCOOTensor)) __PYX_ERR(6, 308, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_NullArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "NullArray", sizeof(struct __pyx_obj_7pyarrow_3lib_NullArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_NullArray) __PYX_ERR(6, 319, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_NullArray = (struct __pyx_vtabstruct_7pyarrow_3lib_NullArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_NullArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_NullArray)) __PYX_ERR(6, 319, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_BooleanArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "BooleanArray", sizeof(struct __pyx_obj_7pyarrow_3lib_BooleanArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_BooleanArray) __PYX_ERR(6, 323, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_BooleanArray = (struct __pyx_vtabstruct_7pyarrow_3lib_BooleanArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_BooleanArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_BooleanArray)) __PYX_ERR(6, 323, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_NumericArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "NumericArray", sizeof(struct __pyx_obj_7pyarrow_3lib_NumericArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_NumericArray) __PYX_ERR(6, 327, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_NumericArray = (struct __pyx_vtabstruct_7pyarrow_3lib_NumericArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_NumericArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_NumericArray)) __PYX_ERR(6, 327, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_IntegerArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "IntegerArray", sizeof(struct __pyx_obj_7pyarrow_3lib_IntegerArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_IntegerArray) __PYX_ERR(6, 331, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_IntegerArray = (struct __pyx_vtabstruct_7pyarrow_3lib_IntegerArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_IntegerArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_IntegerArray)) __PYX_ERR(6, 331, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_FloatingPointArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "FloatingPointArray", sizeof(struct __pyx_obj_7pyarrow_3lib_FloatingPointArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_FloatingPointArray) __PYX_ERR(6, 335, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_FloatingPointArray = (struct __pyx_vtabstruct_7pyarrow_3lib_FloatingPointArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_FloatingPointArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_FloatingPointArray)) __PYX_ERR(6, 335, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_Int8Array = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "Int8Array", sizeof(struct __pyx_obj_7pyarrow_3lib_Int8Array), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_Int8Array) __PYX_ERR(6, 339, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_Int8Array = (struct __pyx_vtabstruct_7pyarrow_3lib_Int8Array*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_Int8Array->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_Int8Array)) __PYX_ERR(6, 339, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_UInt8Array = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "UInt8Array", sizeof(struct __pyx_obj_7pyarrow_3lib_UInt8Array), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_UInt8Array) __PYX_ERR(6, 343, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_UInt8Array = (struct __pyx_vtabstruct_7pyarrow_3lib_UInt8Array*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_UInt8Array->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_UInt8Array)) __PYX_ERR(6, 343, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_Int16Array = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "Int16Array", sizeof(struct __pyx_obj_7pyarrow_3lib_Int16Array), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_Int16Array) __PYX_ERR(6, 347, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_Int16Array = (struct __pyx_vtabstruct_7pyarrow_3lib_Int16Array*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_Int16Array->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_Int16Array)) __PYX_ERR(6, 347, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_UInt16Array = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "UInt16Array", sizeof(struct __pyx_obj_7pyarrow_3lib_UInt16Array), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_UInt16Array) __PYX_ERR(6, 351, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_UInt16Array = (struct __pyx_vtabstruct_7pyarrow_3lib_UInt16Array*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_UInt16Array->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_UInt16Array)) __PYX_ERR(6, 351, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_Int32Array = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "Int32Array", sizeof(struct __pyx_obj_7pyarrow_3lib_Int32Array), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_Int32Array) __PYX_ERR(6, 355, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_Int32Array = (struct __pyx_vtabstruct_7pyarrow_3lib_Int32Array*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_Int32Array->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_Int32Array)) __PYX_ERR(6, 355, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_UInt32Array = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "UInt32Array", sizeof(struct __pyx_obj_7pyarrow_3lib_UInt32Array), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_UInt32Array) __PYX_ERR(6, 359, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_UInt32Array = (struct __pyx_vtabstruct_7pyarrow_3lib_UInt32Array*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_UInt32Array->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_UInt32Array)) __PYX_ERR(6, 359, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_Int64Array = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "Int64Array", sizeof(struct __pyx_obj_7pyarrow_3lib_Int64Array), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_Int64Array) __PYX_ERR(6, 363, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_Int64Array = (struct __pyx_vtabstruct_7pyarrow_3lib_Int64Array*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_Int64Array->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_Int64Array)) __PYX_ERR(6, 363, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_UInt64Array = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "UInt64Array", sizeof(struct __pyx_obj_7pyarrow_3lib_UInt64Array), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_UInt64Array) __PYX_ERR(6, 367, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_UInt64Array = (struct __pyx_vtabstruct_7pyarrow_3lib_UInt64Array*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_UInt64Array->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_UInt64Array)) __PYX_ERR(6, 367, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_HalfFloatArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "HalfFloatArray", sizeof(struct __pyx_obj_7pyarrow_3lib_HalfFloatArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_HalfFloatArray) __PYX_ERR(6, 371, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_HalfFloatArray = (struct __pyx_vtabstruct_7pyarrow_3lib_HalfFloatArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_HalfFloatArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_HalfFloatArray)) __PYX_ERR(6, 371, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_FloatArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "FloatArray", sizeof(struct __pyx_obj_7pyarrow_3lib_FloatArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_FloatArray) __PYX_ERR(6, 375, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_FloatArray = (struct __pyx_vtabstruct_7pyarrow_3lib_FloatArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_FloatArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_FloatArray)) __PYX_ERR(6, 375, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_DoubleArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "DoubleArray", sizeof(struct __pyx_obj_7pyarrow_3lib_DoubleArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_DoubleArray) __PYX_ERR(6, 379, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_DoubleArray = (struct __pyx_vtabstruct_7pyarrow_3lib_DoubleArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_DoubleArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_DoubleArray)) __PYX_ERR(6, 379, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_FixedSizeBinaryArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "FixedSizeBinaryArray", sizeof(struct __pyx_obj_7pyarrow_3lib_FixedSizeBinaryArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_FixedSizeBinaryArray) __PYX_ERR(6, 383, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_FixedSizeBinaryArray = (struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeBinaryArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_FixedSizeBinaryArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_FixedSizeBinaryArray)) __PYX_ERR(6, 383, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_Decimal128Array = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "Decimal128Array", sizeof(struct __pyx_obj_7pyarrow_3lib_Decimal128Array), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_Decimal128Array) __PYX_ERR(6, 387, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_Decimal128Array = (struct __pyx_vtabstruct_7pyarrow_3lib_Decimal128Array*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_Decimal128Array->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_Decimal128Array)) __PYX_ERR(6, 387, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_StructArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "StructArray", sizeof(struct __pyx_obj_7pyarrow_3lib_StructArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_StructArray) __PYX_ERR(6, 391, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_StructArray = (struct __pyx_vtabstruct_7pyarrow_3lib_StructArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_StructArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_StructArray)) __PYX_ERR(6, 391, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_ListArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "ListArray", sizeof(struct __pyx_obj_7pyarrow_3lib_ListArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_ListArray) __PYX_ERR(6, 395, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_ListArray = (struct __pyx_vtabstruct_7pyarrow_3lib_ListArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_ListArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_ListArray)) __PYX_ERR(6, 395, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_LargeListArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "LargeListArray", sizeof(struct __pyx_obj_7pyarrow_3lib_LargeListArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_LargeListArray) __PYX_ERR(6, 399, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_LargeListArray = (struct __pyx_vtabstruct_7pyarrow_3lib_LargeListArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_LargeListArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_LargeListArray)) __PYX_ERR(6, 399, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_MapArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "MapArray", sizeof(struct __pyx_obj_7pyarrow_3lib_MapArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_MapArray) __PYX_ERR(6, 403, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_MapArray = (struct __pyx_vtabstruct_7pyarrow_3lib_MapArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_MapArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_MapArray)) __PYX_ERR(6, 403, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_FixedSizeListArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "FixedSizeListArray", sizeof(struct __pyx_obj_7pyarrow_3lib_FixedSizeListArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_FixedSizeListArray) __PYX_ERR(6, 407, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_FixedSizeListArray = (struct __pyx_vtabstruct_7pyarrow_3lib_FixedSizeListArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_FixedSizeListArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_FixedSizeListArray)) __PYX_ERR(6, 407, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_UnionArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "UnionArray", sizeof(struct __pyx_obj_7pyarrow_3lib_UnionArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_UnionArray) __PYX_ERR(6, 411, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_UnionArray = (struct __pyx_vtabstruct_7pyarrow_3lib_UnionArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_UnionArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_UnionArray)) __PYX_ERR(6, 411, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_StringArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "StringArray", sizeof(struct __pyx_obj_7pyarrow_3lib_StringArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_StringArray) __PYX_ERR(6, 415, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_StringArray = (struct __pyx_vtabstruct_7pyarrow_3lib_StringArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_StringArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_StringArray)) __PYX_ERR(6, 415, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_BinaryArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "BinaryArray", sizeof(struct __pyx_obj_7pyarrow_3lib_BinaryArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_BinaryArray) __PYX_ERR(6, 419, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_BinaryArray = (struct __pyx_vtabstruct_7pyarrow_3lib_BinaryArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_BinaryArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_BinaryArray)) __PYX_ERR(6, 419, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_DictionaryArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "DictionaryArray", sizeof(struct __pyx_obj_7pyarrow_3lib_DictionaryArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_DictionaryArray) __PYX_ERR(6, 423, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_DictionaryArray = (struct __pyx_vtabstruct_7pyarrow_3lib_DictionaryArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_DictionaryArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_DictionaryArray)) __PYX_ERR(6, 423, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_ExtensionArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "ExtensionArray", sizeof(struct __pyx_obj_7pyarrow_3lib_ExtensionArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_ExtensionArray) __PYX_ERR(6, 428, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_ExtensionArray = (struct __pyx_vtabstruct_7pyarrow_3lib_ExtensionArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_ExtensionArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_ExtensionArray)) __PYX_ERR(6, 428, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_ChunkedArray = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "ChunkedArray", sizeof(struct __pyx_obj_7pyarrow_3lib_ChunkedArray), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_ChunkedArray) __PYX_ERR(6, 439, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_ChunkedArray = (struct __pyx_vtabstruct_7pyarrow_3lib_ChunkedArray*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_ChunkedArray->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_ChunkedArray)) __PYX_ERR(6, 439, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_Table = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "Table", sizeof(struct __pyx_obj_7pyarrow_3lib_Table), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_Table) __PYX_ERR(6, 452, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_Table = (struct __pyx_vtabstruct_7pyarrow_3lib_Table*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_Table->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_Table)) __PYX_ERR(6, 452, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_RecordBatch = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "RecordBatch", sizeof(struct __pyx_obj_7pyarrow_3lib_RecordBatch), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_RecordBatch) __PYX_ERR(6, 460, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_RecordBatch = (struct __pyx_vtabstruct_7pyarrow_3lib_RecordBatch*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_RecordBatch->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_RecordBatch)) __PYX_ERR(6, 460, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_Buffer = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "Buffer", sizeof(struct __pyx_obj_7pyarrow_3lib_Buffer), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_Buffer) __PYX_ERR(6, 469, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_Buffer = (struct __pyx_vtabstruct_7pyarrow_3lib_Buffer*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_Buffer->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_Buffer)) __PYX_ERR(6, 469, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_ResizableBuffer = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "ResizableBuffer", sizeof(struct __pyx_obj_7pyarrow_3lib_ResizableBuffer), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_ResizableBuffer) __PYX_ERR(6, 479, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_ResizableBuffer = (struct __pyx_vtabstruct_7pyarrow_3lib_ResizableBuffer*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_ResizableBuffer->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_ResizableBuffer)) __PYX_ERR(6, 479, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_NativeFile = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "NativeFile", sizeof(struct __pyx_obj_7pyarrow_3lib_NativeFile), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_NativeFile) __PYX_ERR(6, 484, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_NativeFile = (struct __pyx_vtabstruct_7pyarrow_3lib_NativeFile*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_NativeFile->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_NativeFile)) __PYX_ERR(6, 484, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_BufferedInputStream = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "BufferedInputStream", sizeof(struct __pyx_obj_7pyarrow_3lib_BufferedInputStream), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_BufferedInputStream) __PYX_ERR(6, 508, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_BufferedInputStream = (struct __pyx_vtabstruct_7pyarrow_3lib_BufferedInputStream*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_BufferedInputStream->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_BufferedInputStream)) __PYX_ERR(6, 508, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_BufferedOutputStream = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "BufferedOutputStream", sizeof(struct __pyx_obj_7pyarrow_3lib_BufferedOutputStream), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_BufferedOutputStream) __PYX_ERR(6, 512, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_BufferedOutputStream = (struct __pyx_vtabstruct_7pyarrow_3lib_BufferedOutputStream*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_BufferedOutputStream->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_BufferedOutputStream)) __PYX_ERR(6, 512, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_CompressedInputStream = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "CompressedInputStream", sizeof(struct __pyx_obj_7pyarrow_3lib_CompressedInputStream), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_CompressedInputStream) __PYX_ERR(6, 516, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_CompressedInputStream = (struct __pyx_vtabstruct_7pyarrow_3lib_CompressedInputStream*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_CompressedInputStream->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_CompressedInputStream)) __PYX_ERR(6, 516, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_CompressedOutputStream = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "CompressedOutputStream", sizeof(struct __pyx_obj_7pyarrow_3lib_CompressedOutputStream), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_CompressedOutputStream) __PYX_ERR(6, 520, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_CompressedOutputStream = (struct __pyx_vtabstruct_7pyarrow_3lib_CompressedOutputStream*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_CompressedOutputStream->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_CompressedOutputStream)) __PYX_ERR(6, 520, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib__CRecordBatchWriter = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "_CRecordBatchWriter", sizeof(struct __pyx_obj_7pyarrow_3lib__CRecordBatchWriter), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib__CRecordBatchWriter) __PYX_ERR(6, 524, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib__CRecordBatchReader = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "_CRecordBatchReader", sizeof(struct __pyx_obj_7pyarrow_3lib__CRecordBatchReader), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib__CRecordBatchReader) __PYX_ERR(6, 529, __pyx_L1_error)
  __pyx_ptype_7pyarrow_3lib_CastOptions = __Pyx_ImportType(__pyx_t_1, "pyarrow.lib", "CastOptions", sizeof(struct __pyx_obj_7pyarrow_3lib_CastOptions), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7pyarrow_3lib_CastOptions) __PYX_ERR(6, 534, __pyx_L1_error)
  __pyx_vtabptr_7pyarrow_3lib_CastOptions = (struct __pyx_vtabstruct_7pyarrow_3lib_CastOptions*)__Pyx_GetVtable(__pyx_ptype_7pyarrow_3lib_CastOptions->tp_dict); if (unlikely(!__pyx_vtabptr_7pyarrow_3lib_CastOptions)) __PYX_ERR(6, 534, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_modinit_variable_import_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_variable_import_code", 0);
  /*--- Variable import code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_function_import_code(void) {
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__Pyx_modinit_function_import_code", 0);
  /*--- Function import code ---*/
  __pyx_t_1 = PyImport_ImportModule("pyarrow.lib"); if (!__pyx_t_1) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ImportFunction(__pyx_t_1, "check_status", (void (**)(void))&__pyx_f_7pyarrow_3lib_check_status, "int (arrow::Status const &)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ImportFunction(__pyx_t_1, "maybe_unbox_memory_pool", (void (**)(void))&__pyx_f_7pyarrow_3lib_maybe_unbox_memory_pool, " arrow::MemoryPool *(struct __pyx_obj_7pyarrow_3lib_MemoryPool *)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ImportFunction(__pyx_t_1, "get_input_stream", (void (**)(void))&__pyx_f_7pyarrow_3lib_get_input_stream, "PyObject *(PyObject *, bool, std::shared_ptr< arrow::io::InputStream>  *)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ImportFunction(__pyx_t_1, "ensure_type", (void (**)(void))&__pyx_f_7pyarrow_3lib_ensure_type, "struct __pyx_obj_7pyarrow_3lib_DataType *(PyObject *, struct __pyx_opt_args_7pyarrow_3lib_ensure_type *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ImportFunction(__pyx_t_1, "pyarrow_wrap_data_type", (void (**)(void))&__pyx_f_7pyarrow_3lib_pyarrow_wrap_data_type, "PyObject *(std::shared_ptr< arrow::DataType>  const &)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ImportFunction(__pyx_t_1, "pyarrow_wrap_table", (void (**)(void))&__pyx_f_7pyarrow_3lib_pyarrow_wrap_table, "PyObject *(std::shared_ptr< arrow::Table>  const &)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ImportFunction(__pyx_t_1, "pyarrow_unwrap_data_type", (void (**)(void))&__pyx_f_7pyarrow_3lib_pyarrow_unwrap_data_type, "std::shared_ptr< arrow::DataType>  (PyObject *)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_RefNannyFinishContext();
  return -1;
}


#if PY_MAJOR_VERSION < 3
#ifdef CYTHON_NO_PYINIT_EXPORT
#define __Pyx_PyMODINIT_FUNC void
#else
#define __Pyx_PyMODINIT_FUNC PyMODINIT_FUNC
#endif
#else
#ifdef CYTHON_NO_PYINIT_EXPORT
#define __Pyx_PyMODINIT_FUNC PyObject *
#else
#define __Pyx_PyMODINIT_FUNC PyMODINIT_FUNC
#endif
#endif


#if PY_MAJOR_VERSION < 3
__Pyx_PyMODINIT_FUNC init_csv(void) CYTHON_SMALL_CODE; /*proto*/
__Pyx_PyMODINIT_FUNC init_csv(void)
#else
__Pyx_PyMODINIT_FUNC PyInit__csv(void) CYTHON_SMALL_CODE; /*proto*/
__Pyx_PyMODINIT_FUNC PyInit__csv(void)
#if CYTHON_PEP489_MULTI_PHASE_INIT
{
  return PyModuleDef_Init(&__pyx_moduledef);
}
static CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {
    #if PY_VERSION_HEX >= 0x030700A1
    static PY_INT64_T main_interpreter_id = -1;
    PY_INT64_T current_id = PyInterpreterState_GetID(PyThreadState_Get()->interp);
    if (main_interpreter_id == -1) {
        main_interpreter_id = current_id;
        return (unlikely(current_id == -1)) ? -1 : 0;
    } else if (unlikely(main_interpreter_id != current_id))
    #else
    static PyInterpreterState *main_interpreter = NULL;
    PyInterpreterState *current_interpreter = PyThreadState_Get()->interp;
    if (!main_interpreter) {
        main_interpreter = current_interpreter;
    } else if (unlikely(main_interpreter != current_interpreter))
    #endif
    {
        PyErr_SetString(
            PyExc_ImportError,
            "Interpreter change detected - this module can only be loaded into one interpreter per process.");
        return -1;
    }
    return 0;
}
static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none) {
    PyObject *value = PyObject_GetAttrString(spec, from_name);
    int result = 0;
    if (likely(value)) {
        if (allow_none || value != Py_None) {
            result = PyDict_SetItemString(moddict, to_name, value);
        }
        Py_DECREF(value);
    } else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
        PyErr_Clear();
    } else {
        result = -1;
    }
    return result;
}
static CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {
    PyObject *module = NULL, *moddict, *modname;
    if (__Pyx_check_single_interpreter())
        return NULL;
    if (__pyx_m)
        return __Pyx_NewRef(__pyx_m);
    modname = PyObject_GetAttrString(spec, "name");
    if (unlikely(!modname)) goto bad;
    module = PyModule_NewObject(modname);
    Py_DECREF(modname);
    if (unlikely(!module)) goto bad;
    moddict = PyModule_GetDict(module);
    if (unlikely(!moddict)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "loader", "__loader__", 1) < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "origin", "__file__", 1) < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "parent", "__package__", 1) < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "submodule_search_locations", "__path__", 0) < 0)) goto bad;
    return module;
bad:
    Py_XDECREF(module);
    return NULL;
}


static CYTHON_SMALL_CODE int __pyx_pymod_exec__csv(PyObject *__pyx_pyinit_module)
#endif
#endif
{
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannyDeclarations
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  if (__pyx_m) {
    if (__pyx_m == __pyx_pyinit_module) return 0;
    PyErr_SetString(PyExc_RuntimeError, "Module '_csv' has already been imported. Re-initialisation is not supported.");
    return -1;
  }
  #elif PY_MAJOR_VERSION >= 3
  if (__pyx_m) return __Pyx_NewRef(__pyx_m);
  #endif
  #if CYTHON_REFNANNY
__Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
if (!__Pyx_RefNanny) {
  PyErr_Clear();
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
  if (!__Pyx_RefNanny)
      Py_FatalError("failed to import 'refnanny' module");
}
#endif
  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit__csv(void)", 0);
  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #ifdef __Pxy_PyFrame_Initialize_Offsets
  __Pxy_PyFrame_Initialize_Offsets();
  #endif
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
  #ifdef __Pyx_CyFunction_USED
  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Coroutine_USED
  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_AsyncGen_USED
  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_StopAsyncIteration_USED
  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Module creation code ---*/
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  __pyx_m = __pyx_pyinit_module;
  Py_INCREF(__pyx_m);
  #else
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4("_csv", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_d);
  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_b);
  __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_cython_runtime);
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
  /*--- Initialize various global constants etc. ---*/
  if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  if (__pyx_module_is_main_pyarrow___csv) {
    if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name_2, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  }
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
    if (!PyDict_GetItemString(modules, "pyarrow._csv")) {
      if (unlikely(PyDict_SetItemString(modules, "pyarrow._csv", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
    }
  }
  #endif
  /*--- Builtin init code ---*/
  if (__Pyx_InitCachedBuiltins() < 0) goto __pyx_L1_error;
  /*--- Constants init code ---*/
  if (__Pyx_InitCachedConstants() < 0) goto __pyx_L1_error;
  /*--- Global type/function init code ---*/
  (void)__Pyx_modinit_global_init_code();
  (void)__Pyx_modinit_variable_export_code();
  (void)__Pyx_modinit_function_export_code();
  if (unlikely(__Pyx_modinit_type_init_code() != 0)) goto __pyx_L1_error;
  if (unlikely(__Pyx_modinit_type_import_code() != 0)) goto __pyx_L1_error;
  (void)__Pyx_modinit_variable_import_code();
  if (unlikely(__Pyx_modinit_function_import_code() != 0)) goto __pyx_L1_error;
  /*--- Execution code ---*/
  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif

  /* "pyarrow/_csv.pyx":32
 *                           pyarrow_unwrap_data_type)
 * 
 * from pyarrow.compat import frombytes, tobytes, Mapping             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_1 = PyList_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 32, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_frombytes);
  __Pyx_GIVEREF(__pyx_n_s_frombytes);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_frombytes);
  __Pyx_INCREF(__pyx_n_s_tobytes);
  __Pyx_GIVEREF(__pyx_n_s_tobytes);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_tobytes);
  __Pyx_INCREF(__pyx_n_s_Mapping);
  __Pyx_GIVEREF(__pyx_n_s_Mapping);
  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_n_s_Mapping);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_pyarrow_compat, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 32, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_frombytes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 32, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_frombytes, __pyx_t_1) < 0) __PYX_ERR(0, 32, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_tobytes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 32, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_tobytes, __pyx_t_1) < 0) __PYX_ERR(0, 32, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_Mapping); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 32, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Mapping, __pyx_t_1) < 0) __PYX_ERR(0, 32, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pyarrow/_csv.pyx":70
 * 
 *     # Avoid mistakingly creating attributes
 *     __slots__ = ()             # <<<<<<<<<<<<<<
 * 
 *     def __init__(self, use_threads=None, block_size=None, skip_rows=None,
 */
  if (PyDict_SetItem((PyObject *)__pyx_ptype_7pyarrow_4_csv_ReadOptions->tp_dict, __pyx_n_s_slots, __pyx_empty_tuple) < 0) __PYX_ERR(0, 70, __pyx_L1_error)
  PyType_Modified(__pyx_ptype_7pyarrow_4_csv_ReadOptions);

  /* "pyarrow/_csv.pyx":180
 *         CCSVParseOptions options
 * 
 *     __slots__ = ()             # <<<<<<<<<<<<<<
 * 
 *     def __init__(self, delimiter=None, quote_char=None, double_quote=None,
 */
  if (PyDict_SetItem((PyObject *)__pyx_ptype_7pyarrow_4_csv_ParseOptions->tp_dict, __pyx_n_s_slots, __pyx_empty_tuple) < 0) __PYX_ERR(0, 180, __pyx_L1_error)
  PyType_Modified(__pyx_ptype_7pyarrow_4_csv_ParseOptions);

  /* "pyarrow/_csv.pyx":340
 * 
 *     # Avoid mistakingly creating attributes
 *     __slots__ = ()             # <<<<<<<<<<<<<<
 * 
 *     def __init__(self, check_utf8=None, column_types=None, null_values=None,
 */
  if (PyDict_SetItem((PyObject *)__pyx_ptype_7pyarrow_4_csv_ConvertOptions->tp_dict, __pyx_n_s_slots, __pyx_empty_tuple) < 0) __PYX_ERR(0, 340, __pyx_L1_error)
  PyType_Modified(__pyx_ptype_7pyarrow_4_csv_ConvertOptions);

  /* "pyarrow/_csv.pyx":537
 * 
 * 
 * def read_csv(input_file, read_options=None, parse_options=None,             # <<<<<<<<<<<<<<
 *              convert_options=None, MemoryPool memory_pool=None):
 *     """
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_7pyarrow_4_csv_1read_csv, NULL, __pyx_n_s_pyarrow__csv); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 537, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_read_csv, __pyx_t_2) < 0) __PYX_ERR(0, 537, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pyarrow/_csv.pyx":1
 * # Licensed to the Apache Software Foundation (ASF) under one             # <<<<<<<<<<<<<<
 * # or more contributor license agreements.  See the NOTICE file
 * # distributed with this work for additional information
 */
  __pyx_t_2 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_2) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "vector.from_py":45
 * 
 * @cname("__pyx_convert_vector_from_py_std_3a__3a_string")
 * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:             # <<<<<<<<<<<<<<
 *     cdef vector[X] v
 *     for item in o:
 */

  /*--- Wrapped vars code ---*/

  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  if (__pyx_m) {
    if (__pyx_d) {
      __Pyx_AddTraceback("init pyarrow._csv", __pyx_clineno, __pyx_lineno, __pyx_filename);
    }
    Py_CLEAR(__pyx_m);
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init pyarrow._csv");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  return (__pyx_m != NULL) ? 0 : -1;
  #elif PY_MAJOR_VERSION >= 3
  return __pyx_m;
  #else
  return;
  #endif
}

/* --- Runtime support code --- */
/* Refnanny */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule(modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, "RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif

/* PyObjectGetAttrStr */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_getattro))
        return tp->tp_getattro(obj, attr_name);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_getattr))
        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
#endif
    return PyObject_GetAttr(obj, attr_name);
}
#endif

/* GetBuiltinName */
static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
    if (unlikely(!result)) {
        PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
            "name '%U' is not defined", name);
#else
            "name '%.200s' is not defined", PyString_AS_STRING(name));
#endif
    }
    return result;
}

/* UnicodeAsUCS4 */
static CYTHON_INLINE Py_UCS4 __Pyx_PyUnicode_AsPy_UCS4(PyObject* x) {
   Py_ssize_t length;
   #if CYTHON_PEP393_ENABLED
   length = PyUnicode_GET_LENGTH(x);
   if (likely(length == 1)) {
       return PyUnicode_READ_CHAR(x, 0);
   }
   #else
   length = PyUnicode_GET_SIZE(x);
   if (likely(length == 1)) {
       return PyUnicode_AS_UNICODE(x)[0];
   }
   #if Py_UNICODE_SIZE == 2
   else if (PyUnicode_GET_SIZE(x) == 2) {
       Py_UCS4 high_val = PyUnicode_AS_UNICODE(x)[0];
       if (high_val >= 0xD800 && high_val <= 0xDBFF) {
           Py_UCS4 low_val = PyUnicode_AS_UNICODE(x)[1];
           if (low_val >= 0xDC00 && low_val <= 0xDFFF) {
               return 0x10000 + (((high_val & ((1<<10)-1)) << 10) | (low_val & ((1<<10)-1)));
           }
       }
   }
   #endif
   #endif
   PyErr_Format(PyExc_ValueError,
                "only single character unicode strings can be converted to Py_UCS4, "
                "got length %" CYTHON_FORMAT_SSIZE_T "d", length);
   return (Py_UCS4)-1;
}

/* object_ord */
static long __Pyx__PyObject_Ord(PyObject* c) {
    Py_ssize_t size;
    if (PyBytes_Check(c)) {
        size = PyBytes_GET_SIZE(c);
        if (likely(size == 1)) {
            return (unsigned char) PyBytes_AS_STRING(c)[0];
        }
#if PY_MAJOR_VERSION < 3
    } else if (PyUnicode_Check(c)) {
        return (long)__Pyx_PyUnicode_AsPy_UCS4(c);
#endif
#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
    } else if (PyByteArray_Check(c)) {
        size = PyByteArray_GET_SIZE(c);
        if (likely(size == 1)) {
            return (unsigned char) PyByteArray_AS_STRING(c)[0];
        }
#endif
    } else {
        PyErr_Format(PyExc_TypeError,
            "ord() expected string of length 1, but %.200s found", c->ob_type->tp_name);
        return (long)(Py_UCS4)-1;
    }
    PyErr_Format(PyExc_TypeError,
        "ord() expected a character, but string of length %zd found", size);
    return (long)(Py_UCS4)-1;
}

/* PyObjectCall */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    PyObject *result;
    ternaryfunc call = func->ob_type->tp_call;
    if (unlikely(!call))
        return PyObject_Call(func, arg, kw);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = (*call)(func, arg, kw);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyErrFetchRestore */
#if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
}
#endif

/* RaiseException */
#if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                        CYTHON_UNUSED PyObject *cause) {
    __Pyx_PyThreadState_declare
    Py_XINCREF(type);
    if (!value || value == Py_None)
        value = NULL;
    else
        Py_INCREF(value);
    if (!tb || tb == Py_None)
        tb = NULL;
    else {
        Py_INCREF(tb);
        if (!PyTraceBack_Check(tb)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: arg 3 must be a traceback or None");
            goto raise_error;
        }
    }
    if (PyType_Check(type)) {
#if CYTHON_COMPILING_IN_PYPY
        if (!value) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#endif
        PyErr_NormalizeException(&type, &value, &tb);
    } else {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        value = type;
        type = (PyObject*) Py_TYPE(type);
        Py_INCREF(type);
        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: exception class must be a subclass of BaseException");
            goto raise_error;
        }
    }
    __Pyx_PyThreadState_assign
    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}
#else
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
    PyObject* owned_instance = NULL;
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;
    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (PyExceptionClass_Check(type)) {
        PyObject *instance_class = NULL;
        if (value && PyExceptionInstance_Check(value)) {
            instance_class = (PyObject*) Py_TYPE(value);
            if (instance_class != type) {
                int is_subclass = PyObject_IsSubclass(instance_class, type);
                if (!is_subclass) {
                    instance_class = NULL;
                } else if (unlikely(is_subclass == -1)) {
                    goto bad;
                } else {
                    type = instance_class;
                }
            }
        }
        if (!instance_class) {
            PyObject *args;
            if (!value)
                args = PyTuple_New(0);
            else if (PyTuple_Check(value)) {
                Py_INCREF(value);
                args = value;
            } else
                args = PyTuple_Pack(1, value);
            if (!args)
                goto bad;
            owned_instance = PyObject_Call(type, args, NULL);
            Py_DECREF(args);
            if (!owned_instance)
                goto bad;
            value = owned_instance;
            if (!PyExceptionInstance_Check(value)) {
                PyErr_Format(PyExc_TypeError,
                             "calling %R should have returned an instance of "
                             "BaseException, not %R",
                             type, Py_TYPE(value));
                goto bad;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }
    if (cause) {
        PyObject *fixed_cause;
        if (cause == Py_None) {
            fixed_cause = NULL;
        } else if (PyExceptionClass_Check(cause)) {
            fixed_cause = PyObject_CallObject(cause, NULL);
            if (fixed_cause == NULL)
                goto bad;
        } else if (PyExceptionInstance_Check(cause)) {
            fixed_cause = cause;
            Py_INCREF(fixed_cause);
        } else {
            PyErr_SetString(PyExc_TypeError,
                            "exception causes must derive from "
                            "BaseException");
            goto bad;
        }
        PyException_SetCause(value, fixed_cause);
    }
    PyErr_SetObject(type, value);
    if (tb) {
#if CYTHON_COMPILING_IN_PYPY
        PyObject *tmp_type, *tmp_value, *tmp_tb;
        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
        Py_INCREF(tb);
        PyErr_Restore(tmp_type, tmp_value, tb);
        Py_XDECREF(tmp_tb);
#else
        PyThreadState *tstate = __Pyx_PyThreadState_Current;
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
#endif
    }
bad:
    Py_XDECREF(owned_instance);
    return;
}
#endif

/* RaiseDoubleKeywords */
static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AsString(kw_name));
        #endif
}

/* ParseKeywords */
static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;
    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
            continue;
        }
        name = first_kw_arg;
        #if PY_MAJOR_VERSION < 3
        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
            while (*name) {
                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
                        && _PyString_Eq(**name, key)) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    if ((**argname == key) || (
                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
                             && _PyString_Eq(**argname, key))) {
                        goto arg_passed_twice;
                    }
                    argname++;
                }
            }
        } else
        #endif
        if (likely(PyUnicode_Check(key))) {
            while (*name) {
                int cmp = (**name == key) ? 0 :
                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
                #endif
                    PyUnicode_Compare(**name, key);
                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                if (cmp == 0) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    int cmp = (**argname == key) ? 0 :
                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
                    #endif
                        PyUnicode_Compare(**argname, key);
                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                    if (cmp == 0) goto arg_passed_twice;
                    argname++;
                }
            }
        } else
            goto invalid_keyword_type;
        if (kwds2) {
            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
        } else {
            goto invalid_keyword;
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, key);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

/* RaiseArgTupleInvalid */
static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *more_or_less;
    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    PyErr_Format(PyExc_TypeError,
                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
                 func_name, more_or_less, num_expected,
                 (num_expected == 1) ? "" : "s", num_found);
}

/* PyObjectSetAttrStr */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_setattro))
        return tp->tp_setattro(obj, attr_name, value);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_setattr))
        return tp->tp_setattr(obj, PyString_AS_STRING(attr_name), value);
#endif
    return PyObject_SetAttr(obj, attr_name, value);
}
#endif

/* PyDictVersioning */
#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
    PyObject *dict = Py_TYPE(obj)->tp_dict;
    return likely(dict) ? __PYX_GET_DICT_VERSION(dict) : 0;
}
static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj) {
    PyObject **dictptr = NULL;
    Py_ssize_t offset = Py_TYPE(obj)->tp_dictoffset;
    if (offset) {
#if CYTHON_COMPILING_IN_CPYTHON
        dictptr = (likely(offset > 0)) ? (PyObject **) ((char *)obj + offset) : _PyObject_GetDictPtr(obj);
#else
        dictptr = _PyObject_GetDictPtr(obj);
#endif
    }
    return (dictptr && *dictptr) ? __PYX_GET_DICT_VERSION(*dictptr) : 0;
}
static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version) {
    PyObject *dict = Py_TYPE(obj)->tp_dict;
    if (unlikely(!dict) || unlikely(tp_dict_version != __PYX_GET_DICT_VERSION(dict)))
        return 0;
    return obj_dict_version == __Pyx_get_object_dict_version(obj);
}
#endif

/* GetModuleGlobalName */
#if CYTHON_USE_DICT_VERSIONS
static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value)
#else
static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name)
#endif
{
    PyObject *result;
#if !CYTHON_AVOID_BORROWED_REFS
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1
    result = _PyDict_GetItem_KnownHash(__pyx_d, name, ((PyASCIIObject *) name)->hash);
    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
    if (likely(result)) {
        return __Pyx_NewRef(result);
    } else if (unlikely(PyErr_Occurred())) {
        return NULL;
    }
#else
    result = PyDict_GetItem(__pyx_d, name);
    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
    if (likely(result)) {
        return __Pyx_NewRef(result);
    }
#endif
#else
    result = PyObject_GetItem(__pyx_d, name);
    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
    if (likely(result)) {
        return __Pyx_NewRef(result);
    }
    PyErr_Clear();
#endif
    return __Pyx_GetBuiltinName(name);
}

/* PyCFunctionFastCall */
#if CYTHON_FAST_PYCCALL
static CYTHON_INLINE PyObject * __Pyx_PyCFunction_FastCall(PyObject *func_obj, PyObject **args, Py_ssize_t nargs) {
    PyCFunctionObject *func = (PyCFunctionObject*)func_obj;
    PyCFunction meth = PyCFunction_GET_FUNCTION(func);
    PyObject *self = PyCFunction_GET_SELF(func);
    int flags = PyCFunction_GET_FLAGS(func);
    assert(PyCFunction_Check(func));
    assert(METH_FASTCALL == (flags & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)));
    assert(nargs >= 0);
    assert(nargs == 0 || args != NULL);
    /* _PyCFunction_FastCallDict() must not be called with an exception set,
       because it may clear it (directly or indirectly) and so the
       caller loses its exception */
    assert(!PyErr_Occurred());
    if ((PY_VERSION_HEX < 0x030700A0) || unlikely(flags & METH_KEYWORDS)) {
        return (*((__Pyx_PyCFunctionFastWithKeywords)(void*)meth)) (self, args, nargs, NULL);
    } else {
        return (*((__Pyx_PyCFunctionFast)(void*)meth)) (self, args, nargs);
    }
}
#endif

/* PyFunctionFastCall */
#if CYTHON_FAST_PYCALL
static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
                                               PyObject *globals) {
    PyFrameObject *f;
    PyThreadState *tstate = __Pyx_PyThreadState_Current;
    PyObject **fastlocals;
    Py_ssize_t i;
    PyObject *result;
    assert(globals != NULL);
    /* XXX Perhaps we should create a specialized
       PyFrame_New() that doesn't take locals, but does
       take builtins without sanity checking them.
       */
    assert(tstate != NULL);
    f = PyFrame_New(tstate, co, globals, NULL);
    if (f == NULL) {
        return NULL;
    }
    fastlocals = __Pyx_PyFrame_GetLocalsplus(f);
    for (i = 0; i < na; i++) {
        Py_INCREF(*args);
        fastlocals[i] = *args++;
    }
    result = PyEval_EvalFrameEx(f,0);
    ++tstate->recursion_depth;
    Py_DECREF(f);
    --tstate->recursion_depth;
    return result;
}
#if 1 || PY_VERSION_HEX < 0x030600B1
static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs) {
    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
    PyObject *globals = PyFunction_GET_GLOBALS(func);
    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
    PyObject *closure;
#if PY_MAJOR_VERSION >= 3
    PyObject *kwdefs;
#endif
    PyObject *kwtuple, **k;
    PyObject **d;
    Py_ssize_t nd;
    Py_ssize_t nk;
    PyObject *result;
    assert(kwargs == NULL || PyDict_Check(kwargs));
    nk = kwargs ? PyDict_Size(kwargs) : 0;
    if (Py_EnterRecursiveCall((char*)" while calling a Python object")) {
        return NULL;
    }
    if (
#if PY_MAJOR_VERSION >= 3
            co->co_kwonlyargcount == 0 &&
#endif
            likely(kwargs == NULL || nk == 0) &&
            co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
        if (argdefs == NULL && co->co_argcount == nargs) {
            result = __Pyx_PyFunction_FastCallNoKw(co, args, nargs, globals);
            goto done;
        }
        else if (nargs == 0 && argdefs != NULL
                 && co->co_argcount == Py_SIZE(argdefs)) {
            /* function called with no arguments, but all parameters have
               a default value: use default values as arguments .*/
            args = &PyTuple_GET_ITEM(argdefs, 0);
            result =__Pyx_PyFunction_FastCallNoKw(co, args, Py_SIZE(argdefs), globals);
            goto done;
        }
    }
    if (kwargs != NULL) {
        Py_ssize_t pos, i;
        kwtuple = PyTuple_New(2 * nk);
        if (kwtuple == NULL) {
            result = NULL;
            goto done;
        }
        k = &PyTuple_GET_ITEM(kwtuple, 0);
        pos = i = 0;
        while (PyDict_Next(kwargs, &pos, &k[i], &k[i+1])) {
            Py_INCREF(k[i]);
            Py_INCREF(k[i+1]);
            i += 2;
        }
        nk = i / 2;
    }
    else {
        kwtuple = NULL;
        k = NULL;
    }
    closure = PyFunction_GET_CLOSURE(func);
#if PY_MAJOR_VERSION >= 3
    kwdefs = PyFunction_GET_KW_DEFAULTS(func);
#endif
    if (argdefs != NULL) {
        d = &PyTuple_GET_ITEM(argdefs, 0);
        nd = Py_SIZE(argdefs);
    }
    else {
        d = NULL;
        nd = 0;
    }
#if PY_MAJOR_VERSION >= 3
    result = PyEval_EvalCodeEx((PyObject*)co, globals, (PyObject *)NULL,
                               args, (int)nargs,
                               k, (int)nk,
                               d, (int)nd, kwdefs, closure);
#else
    result = PyEval_EvalCodeEx(co, globals, (PyObject *)NULL,
                               args, (int)nargs,
                               k, (int)nk,
                               d, (int)nd, closure);
#endif
    Py_XDECREF(kwtuple);
done:
    Py_LeaveRecursiveCall();
    return result;
}
#endif
#endif

/* PyObjectCall2Args */
static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2) {
    PyObject *args, *result = NULL;
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(function)) {
        PyObject *args[2] = {arg1, arg2};
        return __Pyx_PyFunction_FastCall(function, args, 2);
    }
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(function)) {
        PyObject *args[2] = {arg1, arg2};
        return __Pyx_PyCFunction_FastCall(function, args, 2);
    }
    #endif
    args = PyTuple_New(2);
    if (unlikely(!args)) goto done;
    Py_INCREF(arg1);
    PyTuple_SET_ITEM(args, 0, arg1);
    Py_INCREF(arg2);
    PyTuple_SET_ITEM(args, 1, arg2);
    Py_INCREF(function);
    result = __Pyx_PyObject_Call(function, args, NULL);
    Py_DECREF(args);
    Py_DECREF(function);
done:
    return result;
}

/* PyObjectCallMethO */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
    PyObject *self, *result;
    PyCFunction cfunc;
    cfunc = PyCFunction_GET_FUNCTION(func);
    self = PyCFunction_GET_SELF(func);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = cfunc(self, arg);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyObjectCallOneArg */
#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_New(1);
    if (unlikely(!args)) return NULL;
    Py_INCREF(arg);
    PyTuple_SET_ITEM(args, 0, arg);
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
#if CYTHON_FAST_PYCALL
    if (PyFunction_Check(func)) {
        return __Pyx_PyFunction_FastCall(func, &arg, 1);
    }
#endif
    if (likely(PyCFunction_Check(func))) {
        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
            return __Pyx_PyObject_CallMethO(func, arg);
#if CYTHON_FAST_PYCCALL
        } else if (PyCFunction_GET_FLAGS(func) & METH_FASTCALL) {
            return __Pyx_PyCFunction_FastCall(func, &arg, 1);
#endif
        }
    }
    return __Pyx__PyObject_CallOneArg(func, arg);
}
#else
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_Pack(1, arg);
    if (unlikely(!args)) return NULL;
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
#endif

/* PyObjectCallNoArg */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
#if CYTHON_FAST_PYCALL
    if (PyFunction_Check(func)) {
        return __Pyx_PyFunction_FastCall(func, NULL, 0);
    }
#endif
#ifdef __Pyx_CyFunction_USED
    if (likely(PyCFunction_Check(func) || __Pyx_CyFunction_Check(func)))
#else
    if (likely(PyCFunction_Check(func)))
#endif
    {
        if (likely(PyCFunction_GET_FLAGS(func) & METH_NOARGS)) {
            return __Pyx_PyObject_CallMethO(func, NULL);
        }
    }
    return __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL);
}
#endif

/* RaiseTooManyValuesToUnpack */
static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
    PyErr_Format(PyExc_ValueError,
                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
}

/* RaiseNeedMoreValuesToUnpack */
static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
    PyErr_Format(PyExc_ValueError,
                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
                 index, (index == 1) ? "" : "s");
}

/* IterFinish */
static CYTHON_INLINE int __Pyx_IterFinish(void) {
#if CYTHON_FAST_THREAD_STATE
    PyThreadState *tstate = __Pyx_PyThreadState_Current;
    PyObject* exc_type = tstate->curexc_type;
    if (unlikely(exc_type)) {
        if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) {
            PyObject *exc_value, *exc_tb;
            exc_value = tstate->curexc_value;
            exc_tb = tstate->curexc_traceback;
            tstate->curexc_type = 0;
            tstate->curexc_value = 0;
            tstate->curexc_traceback = 0;
            Py_DECREF(exc_type);
            Py_XDECREF(exc_value);
            Py_XDECREF(exc_tb);
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#else
    if (unlikely(PyErr_Occurred())) {
        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
            PyErr_Clear();
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#endif
}

/* UnpackItemEndCheck */
static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
    if (unlikely(retval)) {
        Py_DECREF(retval);
        __Pyx_RaiseTooManyValuesError(expected);
        return -1;
    } else {
        return __Pyx_IterFinish();
    }
    return 0;
}

/* ArgTypeTest */
static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact)
{
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    else if (exact) {
        #if PY_MAJOR_VERSION == 2
        if ((type == &PyBaseString_Type) && likely(__Pyx_PyBaseString_CheckExact(obj))) return 1;
        #endif
    }
    else {
        if (likely(__Pyx_TypeCheck(obj, type))) return 1;
    }
    PyErr_Format(PyExc_TypeError,
        "Argument '%.200s' has incorrect type (expected %.200s, got %.200s)",
        name, type->tp_name, Py_TYPE(obj)->tp_name);
    return 0;
}

/* ExtTypeTest */
static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (likely(__Pyx_TypeCheck(obj, type)))
        return 1;
    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
                 Py_TYPE(obj)->tp_name, type->tp_name);
    return 0;
}

/* PyObject_GenericGetAttrNoDict */
#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
static PyObject *__Pyx_RaiseGenericGetAttributeError(PyTypeObject *tp, PyObject *attr_name) {
    PyErr_Format(PyExc_AttributeError,
#if PY_MAJOR_VERSION >= 3
                 "'%.50s' object has no attribute '%U'",
                 tp->tp_name, attr_name);
#else
                 "'%.50s' object has no attribute '%.400s'",
                 tp->tp_name, PyString_AS_STRING(attr_name));
#endif
    return NULL;
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name) {
    PyObject *descr;
    PyTypeObject *tp = Py_TYPE(obj);
    if (unlikely(!PyString_Check(attr_name))) {
        return PyObject_GenericGetAttr(obj, attr_name);
    }
    assert(!tp->tp_dictoffset);
    descr = _PyType_Lookup(tp, attr_name);
    if (unlikely(!descr)) {
        return __Pyx_RaiseGenericGetAttributeError(tp, attr_name);
    }
    Py_INCREF(descr);
    #if PY_MAJOR_VERSION < 3
    if (likely(PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_HAVE_CLASS)))
    #endif
    {
        descrgetfunc f = Py_TYPE(descr)->tp_descr_get;
        if (unlikely(f)) {
            PyObject *res = f(descr, obj, (PyObject *)tp);
            Py_DECREF(descr);
            return res;
        }
    }
    return descr;
}
#endif

/* PyObject_GenericGetAttr */
#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name) {
    if (unlikely(Py_TYPE(obj)->tp_dictoffset)) {
        return PyObject_GenericGetAttr(obj, attr_name);
    }
    return __Pyx_PyObject_GenericGetAttrNoDict(obj, attr_name);
}
#endif

/* SetupReduce */
static int __Pyx_setup_reduce_is_named(PyObject* meth, PyObject* name) {
  int ret;
  PyObject *name_attr;
  name_attr = __Pyx_PyObject_GetAttrStr(meth, __pyx_n_s_name_2);
  if (likely(name_attr)) {
      ret = PyObject_RichCompareBool(name_attr, name, Py_EQ);
  } else {
      ret = -1;
  }
  if (unlikely(ret < 0)) {
      PyErr_Clear();
      ret = 0;
  }
  Py_XDECREF(name_attr);
  return ret;
}
static int __Pyx_setup_reduce(PyObject* type_obj) {
    int ret = 0;
    PyObject *object_reduce = NULL;
    PyObject *object_reduce_ex = NULL;
    PyObject *reduce = NULL;
    PyObject *reduce_ex = NULL;
    PyObject *reduce_cython = NULL;
    PyObject *setstate = NULL;
    PyObject *setstate_cython = NULL;
#if CYTHON_USE_PYTYPE_LOOKUP
    if (_PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate)) goto GOOD;
#else
    if (PyObject_HasAttr(type_obj, __pyx_n_s_getstate)) goto GOOD;
#endif
#if CYTHON_USE_PYTYPE_LOOKUP
    object_reduce_ex = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto BAD;
#else
    object_reduce_ex = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto BAD;
#endif
    reduce_ex = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce_ex); if (unlikely(!reduce_ex)) goto BAD;
    if (reduce_ex == object_reduce_ex) {
#if CYTHON_USE_PYTYPE_LOOKUP
        object_reduce = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce); if (!object_reduce) goto BAD;
#else
        object_reduce = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce); if (!object_reduce) goto BAD;
#endif
        reduce = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce); if (unlikely(!reduce)) goto BAD;
        if (reduce == object_reduce || __Pyx_setup_reduce_is_named(reduce, __pyx_n_s_reduce_cython)) {
            reduce_cython = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce_cython); if (unlikely(!reduce_cython)) goto BAD;
            ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce, reduce_cython); if (unlikely(ret < 0)) goto BAD;
            ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce_cython); if (unlikely(ret < 0)) goto BAD;
            setstate = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_setstate);
            if (!setstate) PyErr_Clear();
            if (!setstate || __Pyx_setup_reduce_is_named(setstate, __pyx_n_s_setstate_cython)) {
                setstate_cython = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_setstate_cython); if (unlikely(!setstate_cython)) goto BAD;
                ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate, setstate_cython); if (unlikely(ret < 0)) goto BAD;
                ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate_cython); if (unlikely(ret < 0)) goto BAD;
            }
            PyType_Modified((PyTypeObject*)type_obj);
        }
    }
    goto GOOD;
BAD:
    if (!PyErr_Occurred())
        PyErr_Format(PyExc_RuntimeError, "Unable to initialize pickling for %s", ((PyTypeObject*)type_obj)->tp_name);
    ret = -1;
GOOD:
#if !CYTHON_USE_PYTYPE_LOOKUP
    Py_XDECREF(object_reduce);
    Py_XDECREF(object_reduce_ex);
#endif
    Py_XDECREF(reduce);
    Py_XDECREF(reduce_ex);
    Py_XDECREF(reduce_cython);
    Py_XDECREF(setstate);
    Py_XDECREF(setstate_cython);
    return ret;
}

/* TypeImport */
#ifndef __PYX_HAVE_RT_ImportType
#define __PYX_HAVE_RT_ImportType
static PyTypeObject *__Pyx_ImportType(PyObject *module, const char *module_name, const char *class_name,
    size_t size, enum __Pyx_ImportType_CheckSize check_size)
{
    PyObject *result = 0;
    char warning[200];
    Py_ssize_t basicsize;
#ifdef Py_LIMITED_API
    PyObject *py_basicsize;
#endif
    result = PyObject_GetAttrString(module, class_name);
    if (!result)
        goto bad;
    if (!PyType_Check(result)) {
        PyErr_Format(PyExc_TypeError,
            "%.200s.%.200s is not a type object",
            module_name, class_name);
        goto bad;
    }
#ifndef Py_LIMITED_API
    basicsize = ((PyTypeObject *)result)->tp_basicsize;
#else
    py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
    if (!py_basicsize)
        goto bad;
    basicsize = PyLong_AsSsize_t(py_basicsize);
    Py_DECREF(py_basicsize);
    py_basicsize = 0;
    if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
        goto bad;
#endif
    if ((size_t)basicsize < size) {
        PyErr_Format(PyExc_ValueError,
            "%.200s.%.200s size changed, may indicate binary incompatibility. "
            "Expected %zd from C header, got %zd from PyObject",
            module_name, class_name, size, basicsize);
        goto bad;
    }
    if (check_size == __Pyx_ImportType_CheckSize_Error && (size_t)basicsize != size) {
        PyErr_Format(PyExc_ValueError,
            "%.200s.%.200s size changed, may indicate binary incompatibility. "
            "Expected %zd from C header, got %zd from PyObject",
            module_name, class_name, size, basicsize);
        goto bad;
    }
    else if (check_size == __Pyx_ImportType_CheckSize_Warn && (size_t)basicsize > size) {
        PyOS_snprintf(warning, sizeof(warning),
            "%s.%s size changed, may indicate binary incompatibility. "
            "Expected %zd from C header, got %zd from PyObject",
            module_name, class_name, size, basicsize);
        if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
    }
    return (PyTypeObject *)result;
bad:
    Py_XDECREF(result);
    return NULL;
}
#endif

/* GetVTable */
static void* __Pyx_GetVtable(PyObject *dict) {
    void* ptr;
    PyObject *ob = PyObject_GetItem(dict, __pyx_n_s_pyx_vtable);
    if (!ob)
        goto bad;
#if PY_VERSION_HEX >= 0x02070000
    ptr = PyCapsule_GetPointer(ob, 0);
#else
    ptr = PyCObject_AsVoidPtr(ob);
#endif
    if (!ptr && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "invalid vtable found for imported type");
    Py_DECREF(ob);
    return ptr;
bad:
    Py_XDECREF(ob);
    return NULL;
}

/* Import */
static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    #if PY_MAJOR_VERSION < 3
    PyObject *py_import;
    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
    if (!py_import)
        goto bad;
    #endif
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    {
        #if PY_MAJOR_VERSION >= 3
        if (level == -1) {
            if (strchr(__Pyx_MODULE_NAME, '.')) {
                module = PyImport_ImportModuleLevelObject(
                    name, global_dict, empty_dict, list, 1);
                if (!module) {
                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                        goto bad;
                    PyErr_Clear();
                }
            }
            level = 0;
        }
        #endif
        if (!module) {
            #if PY_MAJOR_VERSION < 3
            PyObject *py_level = PyInt_FromLong(level);
            if (!py_level)
                goto bad;
            module = PyObject_CallFunctionObjArgs(py_import,
                name, global_dict, empty_dict, list, py_level, (PyObject *)NULL);
            Py_DECREF(py_level);
            #else
            module = PyImport_ImportModuleLevelObject(
                name, global_dict, empty_dict, list, level);
            #endif
        }
    }
bad:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(py_import);
    #endif
    Py_XDECREF(empty_list);
    Py_XDECREF(empty_dict);
    return module;
}

/* ImportFrom */
static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
        PyErr_Format(PyExc_ImportError,
        #if PY_MAJOR_VERSION < 3
            "cannot import name %.230s", PyString_AS_STRING(name));
        #else
            "cannot import name %S", name);
        #endif
    }
    return value;
}

/* CLineInTraceback */
#ifndef CYTHON_CLINE_IN_TRACEBACK
static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line) {
    PyObject *use_cline;
    PyObject *ptype, *pvalue, *ptraceback;
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject **cython_runtime_dict;
#endif
    if (unlikely(!__pyx_cython_runtime)) {
        return c_line;
    }
    __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
#if CYTHON_COMPILING_IN_CPYTHON
    cython_runtime_dict = _PyObject_GetDictPtr(__pyx_cython_runtime);
    if (likely(cython_runtime_dict)) {
        __PYX_PY_DICT_LOOKUP_IF_MODIFIED(
            use_cline, *cython_runtime_dict,
            __Pyx_PyDict_GetItemStr(*cython_runtime_dict, __pyx_n_s_cline_in_traceback))
    } else
#endif
    {
      PyObject *use_cline_obj = __Pyx_PyObject_GetAttrStr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
      if (use_cline_obj) {
        use_cline = PyObject_Not(use_cline_obj) ? Py_False : Py_True;
        Py_DECREF(use_cline_obj);
      } else {
        PyErr_Clear();
        use_cline = NULL;
      }
    }
    if (!use_cline) {
        c_line = 0;
        PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
    }
    else if (use_cline == Py_False || (use_cline != Py_True && PyObject_Not(use_cline) != 0)) {
        c_line = 0;
    }
    __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
    return c_line;
}
#endif

/* CodeObjectCache */
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = start + (end - start) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, (size_t)new_max*sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

/* AddTraceback */
#include "compile.h"
#include "frameobject.h"
#include "traceback.h"
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(filename);
    #else
    py_srcfile = PyUnicode_FromString(filename);
    #endif
    if (!py_srcfile) goto bad;
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_code = __Pyx_PyCode_New(
        0,
        0,
        0,
        0,
        0,
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    Py_DECREF(py_funcname);
    return py_code;
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    PyThreadState *tstate = __Pyx_PyThreadState_Current;
    if (c_line) {
        c_line = __Pyx_CLineForTraceback(tstate, c_line);
    }
    py_code = __pyx_find_code_object(c_line ? -c_line : py_line);
    if (!py_code) {
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) goto bad;
        __pyx_insert_code_object(c_line ? -c_line : py_line, py_code);
    }
    py_frame = PyFrame_New(
        tstate,            /*PyThreadState *tstate,*/
        py_code,           /*PyCodeObject *code,*/
        __pyx_d,    /*PyObject *globals,*/
        0                  /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    __Pyx_PyFrame_SetLineNumber(py_frame, py_line);
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

/* CIntToPy */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int32_t(int32_t value) {
    const int32_t neg_one = (int32_t) ((int32_t) 0 - (int32_t) 1), const_zero = (int32_t) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(int32_t) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int32_t) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int32_t) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(int32_t) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int32_t) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(int32_t),
                                     little, !is_unsigned);
    }
}

/* CIntFromPyVerify */
#define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
#define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
#define __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, exc)\
    {\
        func_type value = func_value;\
        if (sizeof(target_type) < sizeof(func_type)) {\
            if (unlikely(value != (func_type) (target_type) value)) {\
                func_type zero = 0;\
                if (exc && unlikely(value == (func_type)-1 && PyErr_Occurred()))\
                    return (target_type) -1;\
                if (is_unsigned && unlikely(value < zero))\
                    goto raise_neg_overflow;\
                else\
                    goto raise_overflow;\
            }\
        }\
        return (target_type) value;\
    }

/* CIntToPy */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_unsigned_char(unsigned char value) {
    const unsigned char neg_one = (unsigned char) ((unsigned char) 0 - (unsigned char) 1), const_zero = (unsigned char) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(unsigned char) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(unsigned char) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(unsigned char) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(unsigned char) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(unsigned char) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(unsigned char),
                                     little, !is_unsigned);
    }
}

/* None */
static CYTHON_INLINE int __Pyx_ErrOccurredWithGIL(void) {
  int err;
  #ifdef WITH_THREAD
  PyGILState_STATE _save = PyGILState_Ensure();
  #endif
  err = !!PyErr_Occurred();
  #ifdef WITH_THREAD
  PyGILState_Release(_save);
  #endif
  return err;
}

/* CIntFromPy */
static CYTHON_INLINE int32_t __Pyx_PyInt_As_int32_t(PyObject *x) {
    const int32_t neg_one = (int32_t) ((int32_t) 0 - (int32_t) 1), const_zero = (int32_t) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int32_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int32_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int32_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int32_t) 0;
                case  1: __PYX_VERIFY_RETURN_INT(int32_t, digit, digits[0])
                case 2:
                    if (8 * sizeof(int32_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) >= 2 * PyLong_SHIFT) {
                            return (int32_t) (((((int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int32_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) >= 3 * PyLong_SHIFT) {
                            return (int32_t) (((((((int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int32_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) >= 4 * PyLong_SHIFT) {
                            return (int32_t) (((((((((int32_t)digits[3]) << PyLong_SHIFT) | (int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (int32_t) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(int32_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int32_t, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int32_t) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int32_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int32_t) 0;
                case -1: __PYX_VERIFY_RETURN_INT(int32_t, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(int32_t,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(int32_t) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) - 1 > 2 * PyLong_SHIFT) {
                            return (int32_t) (((int32_t)-1)*(((((int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(int32_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) - 1 > 2 * PyLong_SHIFT) {
                            return (int32_t) ((((((int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(int32_t) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) - 1 > 3 * PyLong_SHIFT) {
                            return (int32_t) (((int32_t)-1)*(((((((int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int32_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) - 1 > 3 * PyLong_SHIFT) {
                            return (int32_t) ((((((((int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(int32_t) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) - 1 > 4 * PyLong_SHIFT) {
                            return (int32_t) (((int32_t)-1)*(((((((((int32_t)digits[3]) << PyLong_SHIFT) | (int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int32_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) - 1 > 4 * PyLong_SHIFT) {
                            return (int32_t) ((((((((((int32_t)digits[3]) << PyLong_SHIFT) | (int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(int32_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int32_t, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int32_t) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int32_t, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int32_t val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int32_t) -1;
        }
    } else {
        int32_t val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (int32_t) -1;
        val = __Pyx_PyInt_As_int32_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int32_t");
    return (int32_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int32_t");
    return (int32_t) -1;
}

/* CIntToPy */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
    const long neg_one = (long) ((long) 0 - (long) 1), const_zero = (long) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(long) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(long) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(long),
                                     little, !is_unsigned);
    }
}

/* CIntFromPy */
static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
    const long neg_one = (long) ((long) 0 - (long) 1), const_zero = (long) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(long) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (long) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {
                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {
                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (long) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(long) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(long) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            long val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (long) -1;
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (long) -1;
        val = __Pyx_PyInt_As_long(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to long");
    return (long) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to long");
    return (long) -1;
}

/* CIntFromPy */
static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
    const int neg_one = (int) ((int) 0 - (int) 1), const_zero = (int) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {
                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {
                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (int) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(int) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(int) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int) -1;
        }
    } else {
        int val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (int) -1;
        val = __Pyx_PyInt_As_int(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int");
    return (int) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int");
    return (int) -1;
}

/* FastTypeChecks */
#if CYTHON_COMPILING_IN_CPYTHON
static int __Pyx_InBases(PyTypeObject *a, PyTypeObject *b) {
    while (a) {
        a = a->tp_base;
        if (a == b)
            return 1;
    }
    return b == &PyBaseObject_Type;
}
static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b) {
    PyObject *mro;
    if (a == b) return 1;
    mro = a->tp_mro;
    if (likely(mro)) {
        Py_ssize_t i, n;
        n = PyTuple_GET_SIZE(mro);
        for (i = 0; i < n; i++) {
            if (PyTuple_GET_ITEM(mro, i) == (PyObject *)b)
                return 1;
        }
        return 0;
    }
    return __Pyx_InBases(a, b);
}
#if PY_MAJOR_VERSION == 2
static int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject* exc_type2) {
    PyObject *exception, *value, *tb;
    int res;
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ErrFetch(&exception, &value, &tb);
    res = exc_type1 ? PyObject_IsSubclass(err, exc_type1) : 0;
    if (unlikely(res == -1)) {
        PyErr_WriteUnraisable(err);
        res = 0;
    }
    if (!res) {
        res = PyObject_IsSubclass(err, exc_type2);
        if (unlikely(res == -1)) {
            PyErr_WriteUnraisable(err);
            res = 0;
        }
    }
    __Pyx_ErrRestore(exception, value, tb);
    return res;
}
#else
static CYTHON_INLINE int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject *exc_type2) {
    int res = exc_type1 ? __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type1) : 0;
    if (!res) {
        res = __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
    }
    return res;
}
#endif
static int __Pyx_PyErr_GivenExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
    Py_ssize_t i, n;
    assert(PyExceptionClass_Check(exc_type));
    n = PyTuple_GET_SIZE(tuple);
#if PY_MAJOR_VERSION >= 3
    for (i=0; i<n; i++) {
        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
    }
#endif
    for (i=0; i<n; i++) {
        PyObject *t = PyTuple_GET_ITEM(tuple, i);
        #if PY_MAJOR_VERSION < 3
        if (likely(exc_type == t)) return 1;
        #endif
        if (likely(PyExceptionClass_Check(t))) {
            if (__Pyx_inner_PyErr_GivenExceptionMatches2(exc_type, NULL, t)) return 1;
        } else {
        }
    }
    return 0;
}
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject* exc_type) {
    if (likely(err == exc_type)) return 1;
    if (likely(PyExceptionClass_Check(err))) {
        if (likely(PyExceptionClass_Check(exc_type))) {
            return __Pyx_inner_PyErr_GivenExceptionMatches2(err, NULL, exc_type);
        } else if (likely(PyTuple_Check(exc_type))) {
            return __Pyx_PyErr_GivenExceptionMatchesTuple(err, exc_type);
        } else {
        }
    }
    return PyErr_GivenExceptionMatches(err, exc_type);
}
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *exc_type1, PyObject *exc_type2) {
    assert(PyExceptionClass_Check(exc_type1));
    assert(PyExceptionClass_Check(exc_type2));
    if (likely(err == exc_type1 || err == exc_type2)) return 1;
    if (likely(PyExceptionClass_Check(err))) {
        return __Pyx_inner_PyErr_GivenExceptionMatches2(err, exc_type1, exc_type2);
    }
    return (PyErr_GivenExceptionMatches(err, exc_type1) || PyErr_GivenExceptionMatches(err, exc_type2));
}
#endif

/* CheckBinaryVersion */
static int __Pyx_check_binary_version(void) {
    char ctversion[4], rtversion[4];
    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
        char message[200];
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        return PyErr_WarnEx(NULL, message, 1);
    }
    return 0;
}

/* FunctionImport */
#ifndef __PYX_HAVE_RT_ImportFunction
#define __PYX_HAVE_RT_ImportFunction
static int __Pyx_ImportFunction(PyObject *module, const char *funcname, void (**f)(void), const char *sig) {
    PyObject *d = 0;
    PyObject *cobj = 0;
    union {
        void (*fp)(void);
        void *p;
    } tmp;
    d = PyObject_GetAttrString(module, (char *)"__pyx_capi__");
    if (!d)
        goto bad;
    cobj = PyDict_GetItemString(d, funcname);
    if (!cobj) {
        PyErr_Format(PyExc_ImportError,
            "%.200s does not export expected C function %.200s",
                PyModule_GetName(module), funcname);
        goto bad;
    }
#if PY_VERSION_HEX >= 0x02070000
    if (!PyCapsule_IsValid(cobj, sig)) {
        PyErr_Format(PyExc_TypeError,
            "C function %.200s.%.200s has wrong signature (expected %.500s, got %.500s)",
             PyModule_GetName(module), funcname, sig, PyCapsule_GetName(cobj));
        goto bad;
    }
    tmp.p = PyCapsule_GetPointer(cobj, sig);
#else
    {const char *desc, *s1, *s2;
    desc = (const char *)PyCObject_GetDesc(cobj);
    if (!desc)
        goto bad;
    s1 = desc; s2 = sig;
    while (*s1 != '\0' && *s1 == *s2) { s1++; s2++; }
    if (*s1 != *s2) {
        PyErr_Format(PyExc_TypeError,
            "C function %.200s.%.200s has wrong signature (expected %.500s, got %.500s)",
             PyModule_GetName(module), funcname, sig, desc);
        goto bad;
    }
    tmp.p = PyCObject_AsVoidPtr(cobj);}
#endif
    *f = tmp.fp;
    if (!(*f))
        goto bad;
    Py_DECREF(d);
    return 0;
bad:
    Py_XDECREF(d);
    return -1;
}
#endif

/* InitStrings */
static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        if (PyObject_Hash(*t->p) == -1)
            return -1;
        ++t;
    }
    return 0;
}

static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
}
static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject* o) {
    Py_ssize_t ignore;
    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
}
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
#if !CYTHON_PEP393_ENABLED
static const char* __Pyx_PyUnicode_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
    char* defenc_c;
    PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
    if (!defenc) return NULL;
    defenc_c = PyBytes_AS_STRING(defenc);
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
    {
        char* end = defenc_c + PyBytes_GET_SIZE(defenc);
        char* c;
        for (c = defenc_c; c < end; c++) {
            if ((unsigned char) (*c) >= 128) {
                PyUnicode_AsASCIIString(o);
                return NULL;
            }
        }
    }
#endif
    *length = PyBytes_GET_SIZE(defenc);
    return defenc_c;
}
#else
static CYTHON_INLINE const char* __Pyx_PyUnicode_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
    if (unlikely(__Pyx_PyUnicode_READY(o) == -1)) return NULL;
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
    if (likely(PyUnicode_IS_ASCII(o))) {
        *length = PyUnicode_GET_LENGTH(o);
        return PyUnicode_AsUTF8(o);
    } else {
        PyUnicode_AsASCIIString(o);
        return NULL;
    }
#else
    return PyUnicode_AsUTF8AndSize(o, length);
#endif
}
#endif
#endif
static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
    if (
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
            __Pyx_sys_getdefaultencoding_not_ascii &&
#endif
            PyUnicode_Check(o)) {
        return __Pyx_PyUnicode_AsStringAndSize(o, length);
    } else
#endif
#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
    if (PyByteArray_Check(o)) {
        *length = PyByteArray_GET_SIZE(o);
        return PyByteArray_AS_STRING(o);
    } else
#endif
    {
        char* result;
        int r = PyBytes_AsStringAndSize(o, &result, length);
        if (unlikely(r < 0)) {
            return NULL;
        } else {
            return result;
        }
    }
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject* x) {
    int retval;
    if (unlikely(!x)) return -1;
    retval = __Pyx_PyObject_IsTrue(x);
    Py_DECREF(x);
    return retval;
}
static PyObject* __Pyx_PyNumber_IntOrLongWrongResultType(PyObject* result, const char* type_name) {
#if PY_MAJOR_VERSION >= 3
    if (PyLong_Check(result)) {
        if (PyErr_WarnFormat(PyExc_DeprecationWarning, 1,
                "__int__ returned non-int (type %.200s).  "
                "The ability to return an instance of a strict subclass of int "
                "is deprecated, and may be removed in a future version of Python.",
                Py_TYPE(result)->tp_name)) {
            Py_DECREF(result);
            return NULL;
        }
        return result;
    }
#endif
    PyErr_Format(PyExc_TypeError,
                 "__%.4s__ returned non-%.4s (type %.200s)",
                 type_name, type_name, Py_TYPE(result)->tp_name);
    Py_DECREF(result);
    return NULL;
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x) {
#if CYTHON_USE_TYPE_SLOTS
  PyNumberMethods *m;
#endif
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_Check(x) || PyLong_Check(x)))
#else
  if (likely(PyLong_Check(x)))
#endif
    return __Pyx_NewRef(x);
#if CYTHON_USE_TYPE_SLOTS
  m = Py_TYPE(x)->tp_as_number;
  #if PY_MAJOR_VERSION < 3
  if (m && m->nb_int) {
    name = "int";
    res = m->nb_int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = m->nb_long(x);
  }
  #else
  if (likely(m && m->nb_int)) {
    name = "int";
    res = m->nb_int(x);
  }
  #endif
#else
  if (!PyBytes_CheckExact(x) && !PyUnicode_CheckExact(x)) {
    res = PyNumber_Int(x);
  }
#endif
  if (likely(res)) {
#if PY_MAJOR_VERSION < 3
    if (unlikely(!PyInt_Check(res) && !PyLong_Check(res))) {
#else
    if (unlikely(!PyLong_CheckExact(res))) {
#endif
        return __Pyx_PyNumber_IntOrLongWrongResultType(res, name);
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject *x;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_CheckExact(b))) {
    if (sizeof(Py_ssize_t) >= sizeof(long))
        return PyInt_AS_LONG(b);
    else
        return PyInt_AsSsize_t(b);
  }
#endif
  if (likely(PyLong_CheckExact(b))) {
    #if CYTHON_USE_PYLONG_INTERNALS
    const digit* digits = ((PyLongObject*)b)->ob_digit;
    const Py_ssize_t size = Py_SIZE(b);
    if (likely(__Pyx_sst_abs(size) <= 1)) {
        ival = likely(size) ? digits[0] : 0;
        if (size == -1) ival = -ival;
        return ival;
    } else {
      switch (size) {
         case 2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
      }
    }
    #endif
    return PyLong_AsSsize_t(b);
  }
  x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b) {
  return b ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False);
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
    return PyInt_FromSize_t(ival);
}


#endif /* Py_PYTHON_H */
